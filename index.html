<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/28/java设计模式/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/28/java设计模式/" itemprop="url">
                  java设计模式简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-28T21:32:39+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>java设计模式简介<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/28/java设计模式/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/22/spring揭秘读书笔记/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/22/spring揭秘读书笔记/" itemprop="url">
                  Untitled
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-22T19:21:36+08:00">
                2017-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="掀起Spring的盖头来"><a href="#掀起Spring的盖头来" class="headerlink" title="掀起Spring的盖头来"></a>掀起Spring的盖头来</h1><h2 id="Spring之崛起"><a href="#Spring之崛起" class="headerlink" title="Spring之崛起"></a>Spring之崛起</h2><p>敏捷与轻量级</p>
<h2 id="Spring框架概述"><a href="#Spring框架概述" class="headerlink" title="Spring框架概述"></a>Spring框架概述</h2><p>基于pojo的轻量级开发理念<br>组成整个Spring框架的各种服务实现被划分到了多个相互独立却又相互以来的模块中  </p>
<h3 id="core模块"><a href="#core模块" class="headerlink" title="core模块"></a>core模块</h3><p>整个框架的基础，提供了一个IOC实现，实现了依赖注入的方式管理对象之间的关系，还包括各种看框架内部使用的各种工具类</p>
<h3 id="AOP模块"><a href="#AOP模块" class="headerlink" title="AOP模块"></a>AOP模块</h3><p>提供了一个AOP框架，采用Proxy模式构建，与IOC容器相结合</p>
<h3 id="数据访问和事务管理的抽象和集成服务"><a href="#数据访问和事务管理的抽象和集成服务" class="headerlink" title="数据访问和事务管理的抽象和集成服务"></a>数据访问和事务管理的抽象和集成服务</h3><p>为jdbc提供了最佳实践，对大量的ORM产品提供了形式统一的继承支持</p>
<h3 id="remoting框架"><a href="#remoting框架" class="headerlink" title="remoting框架"></a>remoting框架</h3><h3 id="web模块"><a href="#web模块" class="headerlink" title="web模块"></a>web模块</h3><h2 id="Spring大观园"><a href="#Spring大观园" class="headerlink" title="Spring大观园"></a>Spring大观园</h2><h1 id="IoC的基本概念"><a href="#IoC的基本概念" class="headerlink" title="IoC的基本概念"></a>IoC的基本概念</h1><h2 id="我们的理念是：让别人为你服务"><a href="#我们的理念是：让别人为你服务" class="headerlink" title="我们的理念是：让别人为你服务"></a>我们的理念是：让别人为你服务</h2><p>解决需要自己主动获取对象的耦合  </p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>被注入对象和依赖对象由IoC Service Provider统一管理</p>
<h2 id="手语、呼喊、还是心有灵犀"><a href="#手语、呼喊、还是心有灵犀" class="headerlink" title="手语、呼喊、还是心有灵犀"></a>手语、呼喊、还是心有灵犀</h2><h3 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h3><p>在构造方法中创建依赖对象</p>
<h3 id="setter方法注入"><a href="#setter方法注入" class="headerlink" title="setter方法注入"></a>setter方法注入</h3><p>使用setter方法注入</p>
<h3 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h3><p>实现某个接口</p>
<h2 id="IoC的附加值"><a href="#IoC的附加值" class="headerlink" title="IoC的附加值"></a>IoC的附加值</h2><p>解耦了某种绑定关系</p>
<h1 id="掌管大局的IoC-Service-Provider"><a href="#掌管大局的IoC-Service-Provider" class="headerlink" title="掌管大局的IoC Service Provider"></a>掌管大局的IoC Service Provider</h1><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h2><h3 id="业务对象的构建管理"><a href="#业务对象的构建管理" class="headerlink" title="业务对象的构建管理"></a>业务对象的构建管理</h3><p>需要将对象的构建逻辑从客户端对象那里剥离出来</p>
<h3 id="业务对象的依赖绑定"><a href="#业务对象的依赖绑定" class="headerlink" title="业务对象的依赖绑定"></a>业务对象的依赖绑定</h3><p>保证每个业务对象在使用的时候，可以处于就绪状态</p>
<h2 id="如何管理对象间的依赖关系"><a href="#如何管理对象间的依赖关系" class="headerlink" title="如何管理对象间的依赖关系"></a>如何管理对象间的依赖关系</h2><p>需要知道自己所管理的和掌握的被注入对象和依赖对象之间的对应关系</p>
<h3 id="直接编码方式"><a href="#直接编码方式" class="headerlink" title="直接编码方式"></a>直接编码方式</h3><p>使用程序编码的方式将被注入对象和依赖对象注册到容器中，显示的表明他们之间的依赖关系</p>
<h3 id="配置文件方式"><a href="#配置文件方式" class="headerlink" title="配置文件方式"></a>配置文件方式</h3><p>最常用的是XML文件来管理对象注册和对象间依赖关系</p>
<h3 id="元数据方式"><a href="#元数据方式" class="headerlink" title="元数据方式"></a>元数据方式</h3><p>基于注解<br>可以算作编码方式的一种特殊情况</p>
<h1 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h1><p><strong>BeanFactory</strong><br>基础类型IoC容器，提供完整的IoC服务支持，默认使用延迟初始化策略<br><strong>ApplicationContext</strong>在BeanFactory基础上构建，是比较高级的容器实现，提供了一些高级特性，比如事件发布、国际化信息支持。在容器启动之后，默认全部初始化并绑定完成</p>
<h2 id="拥有BeanFactory之后的生活"><a href="#拥有BeanFactory之后的生活" class="headerlink" title="拥有BeanFactory之后的生活"></a>拥有BeanFactory之后的生活</h2><p>系统和业务逻辑并没有发生变化，但是对象之间的依赖关系的解决方式改变了</p>
<h2 id="BeanFactory的对象注册与依赖绑定方式"><a href="#BeanFactory的对象注册与依赖绑定方式" class="headerlink" title="BeanFactory的对象注册与依赖绑定方式"></a>BeanFactory的对象注册与依赖绑定方式</h2><h3 id="直接编码方式-1"><a href="#直接编码方式-1" class="headerlink" title="直接编码方式"></a>直接编码方式</h3><h3 id="外部文件配置方式"><a href="#外部文件配置方式" class="headerlink" title="外部文件配置方式"></a>外部文件配置方式</h3><h4 id="Properties文件"><a href="#Properties文件" class="headerlink" title="Properties文件"></a>Properties文件</h4><p>BeanDefinitionReader</p>
<h4 id="XML文件"><a href="#XML文件" class="headerlink" title="XML文件"></a>XML文件</h4><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>@Autowired和@Component  </p>
<p><context:component-scan></context:component-scan></p>
<h2 id="BeanFactory的XML之旅"><a href="#BeanFactory的XML之旅" class="headerlink" title="BeanFactory的XML之旅"></a>BeanFactory的XML之旅</h2><h3 id="和"><a href="#和" class="headerlink" title="和"></a><beans\>和<bean\></bean\></beans\></h3><p>DTD与XSD<br>并没有本质区别</p>
<h4 id="beans"><a href="#beans" class="headerlink" title="beans"></a>beans</h4><p>是xml配置文件中最顶层的元素，可以包括若干个<description\><bean\><import\><alias\><br>属性<br>default-lazy-inti：是否延迟初始化<br>default-autowire：标志全体bean使用哪一种方式默认绑定<br>default-dependency-check：依赖检查<br>default-init-method：统一指定初始化方法名<br>default-destroy-methon：指定统一销毁方法<br><strong><description\><import\><alias\></alias\></import\></description\></strong><br>分别是描述，导入其他xml和起别名的作用<br><strong><bean\></bean\></strong><br>对象与bean元素一一对应<br>属性<br>id：bean的唯一标识<br>name：起别名<br>class：指定其类型</alias\></import\></bean\></description\></p>
<h3 id="Help-Me，Help-You"><a href="#Help-Me，Help-You" class="headerlink" title="Help Me，Help You"></a>Help Me，Help You</h3><h4 id="构造方法注入-1"><a href="#构造方法注入-1" class="headerlink" title="构造方法注入"></a>构造方法注入</h4><p>需要配置constructor-arg,ref为引用类型，value为普通类型<br>type可以指定构造函数参数的类型<br>index 可以指定构造函数中参数的顺序</p>
<h4 id="setter方法注入-1"><a href="#setter方法注入-1" class="headerlink" title="setter方法注入"></a>setter方法注入</h4><p>property元素，name对应字段值，value对应普通类型值，ref对应引用类型值</p>
<h4 id="可用的配置项"><a href="#可用的配置项" class="headerlink" title="可用的配置项"></a>可用的配置项</h4><p>包括<br>bean：内部bean，可以防止被外部使用<br>ref：引用容器中其他的对象的实例<br>idref<br>value：适用于注入原始类和包装类以及String<br>null：注入null<br>list：可以有序的为当前对象注入以collection形式声明的依赖<br>set：可以无序的为当前对象注入以set形式声明的依赖<br>map：对应map对象，内嵌了entry元素。是一种键值对的形式<br>props：简化后的map，键值必须都是String  </p>
<h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends-on"></a>depends-on</h4><p>描述了一种非显示的依赖关系</p>
<h4 id="autowire"><a href="#autowire" class="headerlink" title="autowire"></a>autowire</h4><p>5种自动绑定模式：no，byName，byType，constructor，autodetect</p>
<h4 id="dependency-check"><a href="#dependency-check" class="headerlink" title="dependency-check"></a>dependency-check</h4><p>四种类型，none，simple，object，all</p>
<h4 id="lazy-init"><a href="#lazy-init" class="headerlink" title="lazy-init"></a>lazy-init</h4><h3 id="继承？我也会"><a href="#继承？我也会" class="headerlink" title="继承？我也会"></a>继承？我也会</h3><p>parent属性可以显式的表明这种继承关系<br>配合abstract可以实现模板设计模式</p>
<h3 id="bean的scope"><a href="#bean的scope" class="headerlink" title="bean的scope"></a>bean的scope</h3><p>该对象的存活时间<br>类型：singleton，prototype，Request，session，global session<br>singleton与单例模式不同</p>
<h3 id="工厂方法与FactoryBean"><a href="#工厂方法与FactoryBean" class="headerlink" title="工厂方法与FactoryBean"></a>工厂方法与FactoryBean</h3><p>适用于使用第三方类库</p>
<h4 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h4><p>需借助factory-method方法来创建实例</p>
<h4 id="非静态工厂方法"><a href="#非静态工厂方法" class="headerlink" title="非静态工厂方法"></a>非静态工厂方法</h4><p>需使用factory-bean引入工厂bean，然后指明factory-method</p>
<h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>需要类继承FactoryBean接口，是spring提供的专门的接口</p>
<h3 id="偷梁换柱"><a href="#偷梁换柱" class="headerlink" title="偷梁换柱"></a>偷梁换柱</h3><p>每次要去的新的实例</p>
<h4 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h4><p>在依赖的对象中配置<lookup-method name="getNewsBean" bean="newsBean" \=""><br>即表明在getNewsBean方法中每次注入的都是新的实例</lookup-method></p>
<h4 id="殊途同归"><a href="#殊途同归" class="headerlink" title="殊途同归"></a>殊途同归</h4><p>使用BeanFactoryAware接口，需要改配置文件<br>使用ObjectFactoryCreatingFactoryBean需要改配置文件  </p>
<h4 id="方法替换"><a href="#方法替换" class="headerlink" title="方法替换"></a>方法替换</h4><replaced-method name="getAndPersistNews" replacer="providerReplacer">

<h2 id="容器背后的秘密"><a href="#容器背后的秘密" class="headerlink" title="容器背后的秘密"></a>容器背后的秘密</h2><h3 id="战略性观望"><a href="#战略性观望" class="headerlink" title="战略性观望"></a>战略性观望</h3><h4 id="容器启动阶段"><a href="#容器启动阶段" class="headerlink" title="容器启动阶段"></a>容器启动阶段</h4><p>首先加载Configuration MetaData</p>
<h4 id="Bean实例化阶段"><a href="#Bean实例化阶段" class="headerlink" title="Bean实例化阶段"></a>Bean实例化阶段</h4><h3 id="插手容器的启动"><a href="#插手容器的启动" class="headerlink" title="插手容器的启动"></a>插手容器的启动</h3><p>BeanFactoryPostProcessor的容器扩展机制，允许我们在容器实例化相应的对象之前，对注册到容器的BeanDefinition所保存的信息做相应的修改。<br>PropertyPlaceholderConfigurer：用于占位符，例如数据库的配置<br>PropertyOverrideConfigurer：替换某些信息<br>CustomEditorConfigurer：辅助性的，对BeanDefinition没有做任何变动   </p>
<h3 id="了解bean的一生"><a href="#了解bean的一生" class="headerlink" title="了解bean的一生"></a>了解bean的一生</h3><p>对象的实例化默认是延迟初始化的，只有调用getBean才会被初始化，同样其依赖的对象同时被初始化。</p>
<h4 id="Bean的实例化与BeanWrapper"><a href="#Bean的实例化与BeanWrapper" class="headerlink" title="Bean的实例化与BeanWrapper"></a>Bean的实例化与BeanWrapper</h4><p>容器在内部实现的时候，采用策略模式来决定采用何种方式初始化bean实例<br>首先返回的是BeanWrapper的实例，然后在BeanWrapper中设置各种字段值   </p>
<h4 id="各色的Aware接口"><a href="#各色的Aware接口" class="headerlink" title="各色的Aware接口"></a>各色的Aware接口</h4><p>BeanNameAware<br>BeanClassloaderAware<br>BeanFactoryAware<br>ResourceLoaderAware<br>ApplicationEventPublisherAware：会将自身注入当前对象<br>MessageSourceAware<br>ApplicationContextAware：会将自身注入当前对象</p>
<h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>Bean-PostProcessor是存在于对象实例化阶段，而BeanFactoryPostProcessor则是存在于容器启动阶段<br>Spring的AOP则更多地使用BeanPostProcessor来为对象生成相应的代理对象，如org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator<br>在对象实例化的前后可以做一些事情</p>
<h4 id="InitializingBean和init-method"><a href="#InitializingBean和init-method" class="headerlink" title="InitializingBean和init-method"></a>InitializingBean和init-method</h4><p>org.springframework.beans.factory.InitializingBean是容器内部广泛使用的一个对象生<br>命周期标识接口</p>
<h4 id="DisposableBean与destroy-method"><a href="#DisposableBean与destroy-method" class="headerlink" title="DisposableBean与destroy-method"></a>DisposableBean与destroy-method</h4><p>DisposableBean和destroy-method为对象提供了执行自定义销毁逻辑的机会</p>
<h1 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h1><p>FileSystemXmlApplicationContext：在默认情况下，从文件系统加载bean定义以及相关资源的ApplicationContext实现<br>ClassPathXmlApplicationContext：在默认情况下，从Classpath加载bean定义以及相关资源的ApplicationContext实现<br>XmlWebApplicationContext：Spring提供的用于Web应用程序的ApplicationContext实现，我们将在第六部分更多地接触到它</p>
<h2 id="统一资源加载策略"><a href="#统一资源加载策略" class="headerlink" title="统一资源加载策略"></a>统一资源加载策略</h2><h3 id="Spring中的Resource"><a href="#Spring中的Resource" class="headerlink" title="Spring中的Resource"></a>Spring中的Resource</h3><pre><code>BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;...&quot;));
</code></pre><p>其中ClassPathResource就是Resource的一个特定类型的实现，代表的是位于Classpath中的资源</p>
<h3 id="ResourceLoader，“更广义的URL”"><a href="#ResourceLoader，“更广义的URL”" class="headerlink" title="ResourceLoader，“更广义的URL”"></a>ResourceLoader，“更广义的URL”</h3><pre><code>public interface ResourceLoader {
    String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;
    Resource getResource(String location);
    ClassLoader getClassLoader();
}
</code></pre><h4 id="可用的ResourceLoader"><a href="#可用的ResourceLoader" class="headerlink" title="可用的ResourceLoader"></a>可用的ResourceLoader</h4><p>DefaultResourceLoader<br>(1) 首先检查资源路径是否以classpath:前缀打头，如果是，则尝试构造ClassPathResource类<br>型资源并返回。<br>(2) 否则，(a) 尝试通过URL，根据资源路径来定位资源，如果没有抛出MalformedURLException，<br>有则会构造UrlResource类型的资源并返回；(b)如果还是无法根据资源路径定位指定的资源，则委派<br>getResourceByPath(String) 方法来定位， DefaultResourceLoader 的getResourceByPath(String)方法默认实现逻辑是，构造ClassPathResource类型的资源并返回。  </p>
<p>FileSystemResourceLoader  </p>
<pre><code>public void testResourceTypesWithFileSystemResourceLoader()
{
    ResourceLoader resourceLoader = new FileSystemResourceLoader();
    Resource fileResource = resourceLoader.getResource(&quot;D:/spring21site/README&quot;);
    assertTrue(fileResource instanceof FileSystemResource);
    assertTrue(fileResource.exists());
    Resource urlResource = resourceLoader.getResource(&quot;file:D:/spring21site/README&quot;);
    assertTrue(urlResource instanceof UrlResource); 15
}
</code></pre><h2 id="国际化信息支持"><a href="#国际化信息支持" class="headerlink" title="国际化信息支持"></a>国际化信息支持</h2><h2 id="容器内部事件发布"><a href="#容器内部事件发布" class="headerlink" title="容器内部事件发布"></a>容器内部事件发布</h2><h2 id="多配置模块加载的简化"><a href="#多配置模块加载的简化" class="headerlink" title="多配置模块加载的简化"></a>多配置模块加载的简化</h2></replaced-method>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/21/操作系统/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/21/操作系统/" itemprop="url">
                  Untitled
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-21T15:06:07+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h2 id="操作系统做了什么？"><a href="#操作系统做了什么？" class="headerlink" title="操作系统做了什么？"></a>操作系统做了什么？</h2><pre><code>#include &lt;stdio.h&gt; int main(int argc, char *argv[]) { 
puts(&quot;hello world&quot;); return 0; 
}
</code></pre><hr>
<ol>
<li>用户告诉操作系统执行helloworld程序(如何告知？)  </li>
<li>操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址（文件格式？）   </li>
<li>操作系统：创建一个新的进程，并将helloworld可执行文件映射到该进程结构，表示由该进程执行helloworld程序  </li>
<li>操作系统：为helloworld程序设置CPU上下文环境，并跳到程序开始处（假设调度程序选中hello程序）  </li>
<li>执行helloworld程序的第一条指令，发生缺页异常  </li>
<li>操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序   </li>
<li>helloworld程序执行puts函数（系统调用），在显示器上写一字符串   </li>
<li>操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程  </li>
<li>操作系统：控制设备的进程告诉设备的窗口系统它要显示字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区  </li>
<li>视频硬件将像素转换成显示器可接收的一组控制/数据信号  </li>
<li>显示器解释信号，激发液晶屏  </li>
<li>OK！！！我们在屏幕上看到了“hello world”</li>
</ol>
<h3 id="从上述步骤中得到了什么"><a href="#从上述步骤中得到了什么" class="headerlink" title="从上述步骤中得到了什么"></a>从上述步骤中得到了什么</h3><p>os进程与用户程序的切换  </p>
<h3 id="换个角度看用户程序的执行"><a href="#换个角度看用户程序的执行" class="headerlink" title="换个角度看用户程序的执行"></a>换个角度看用户程序的执行</h3><h2 id="操作系统的定义与作用"><a href="#操作系统的定义与作用" class="headerlink" title="操作系统的定义与作用"></a>操作系统的定义与作用</h2><h3 id="操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——"><a href="#操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——" class="headerlink" title="操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——"></a>操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——</h3><ul>
<li>它们能以尽量有效、合理的方式组织和管理计算机的软硬件资源  </li>
<li>合理地组织计算机的工作 流程，控制程序的执行并向用户提供各种服务功能  </li>
<li><p>使得用户能够灵活、方便地使用计算机，使整个计算机系统高效率运行  </p>
<h3 id="几个关键词"><a href="#几个关键词" class="headerlink" title="几个关键词"></a>几个关键词</h3><p>  有效：系统效率，资源利用率</p>
<pre><code>CPU利用率充足与否？I/O设备是否忙碌？
</code></pre><p>  合理：</p>
<pre><code>各种软硬件资源的管理是否公平合理
如果不公平、不合理，则可能会产生问题？
</code></pre><p>  方便使用：</p>
<pre><code>两种角度：用户界面 与 编程接口
</code></pre><h3 id="三个作用"><a href="#三个作用" class="headerlink" title="三个作用"></a>三个作用</h3><h4 id="资源的管理者"><a href="#资源的管理者" class="headerlink" title="资源的管理者"></a>资源的管理者</h4><p>自底向上 硬件资源：软件资源：<br><strong>怎样管理资源</strong>  </p>
<p>  跟踪记录资源的使用状况，如：哪些资源空闲，分配给谁使用，允许使用多长时间等<br>  确定资源分配策略——算法：静态分配策略，动态分配策略<br>  实施资源的分配和回收<br>  提高资源利用率<br>  保护资源的使用<br>  协调多个进程对资源请求的冲突</p>
</li>
</ul>
<p><strong>五大基本功能</strong>  </p>
<pre><code>进程/线程管理（CPU管理）
    进程线程状态、控制、同步互斥、通信、调度、……
存储管理
    分配/回收、地址转换、存储保护、内存扩充、……
文件管理
    文件目录、文件操作、磁盘空间、文件存取控制、……
设备管理
    设备驱动、分配回收、缓冲技术、……
用户接口
    系统命令、编程接口
</code></pre><h4 id="各种系统服务的提供者"><a href="#各种系统服务的提供者" class="headerlink" title="各种系统服务的提供者"></a>各种系统服务的提供者</h4><pre><code>在操作系统之上，从用户角度来看：
    操作系统为用户提供了一组功能强大、方便易用的命令或系统调用
典型的服务
    进程的创建、执行；文件和目录的操作；I/O设备的使用；各类统计信息；……
</code></pre><h4 id="对硬件机器的扩展"><a href="#对硬件机器的扩展" class="headerlink" title="对硬件机器的扩展"></a>对硬件机器的扩展</h4><pre><code>操作系统在应用程序与硬件之间建立了一个等价的扩展机器（虚拟机）  
对硬件抽象，提高可移植性；比底层硬件更容易编程
</code></pre><p>由面向底层变成了面向操作系统编程</p>
<h2 id="操作系统的主要特征"><a href="#操作系统的主要特征" class="headerlink" title="操作系统的主要特征"></a>操作系统的主要特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发(concurrency)：指处理多个同时性活动的能力  </p>
<pre><code>由于并发将会引发很多的问题：
    活动切换、保护、相互依赖的活动间的同步
在计算机系统中同时存在多个程序运行，单CPU上
    宏观上：这些程序同时在执行
    微观上：任何时刻只有一个程序真正在执行，即这些程序在CPU上是轮流执行的
并行(parallel)：与并发相似，但多指不同程序同时在多个硬件部件上执行
</code></pre><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><pre><code>共享(sharing)：
    操作系统与多个用户的程序共同使用计算机系统中的资源（共享有限的系统资源）
    操作系统要对系统资源进行合理分配和使用
    资源在一个时间段内交替被多个进程所用
互斥共享（如打印机）
同时共享（如可重入代码、磁盘文件）

问题：资源分配难以达到最优化，如何保护资源
</code></pre><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>一个物理实体映射为若干个对应的逻辑实体－－分时或分空间<br>虚拟是操作系统管理系统资源的重要手段，可提高资源利用率  </p>
<pre><code>CPU－－每个进程的&quot;虚处理机&quot;
存储器－－每个进程都有独立的虚拟地址空间（代码＋数据＋堆栈）
显示设备－－多窗口或虚拟终端
</code></pre><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>操作系统必须随时对以不可预测的次序发生的事件进行响应并处理</p>
<h2 id="典型操作系统的架构"><a href="#典型操作系统的架构" class="headerlink" title="典型操作系统的架构"></a>典型操作系统的架构</h2><h3 id="Windows架构"><a href="#Windows架构" class="headerlink" title="Windows架构"></a>Windows架构</h3><p>用户态：系统进程，服务进程，用户进程，环境子系统，动态链接库<br>内核态：系统服务分发器，内核态可调用接口，执行体，内核，设备驱动驱动程序，硬件抽象层，图形与窗口<br>物理硬件：硬件</p>
<h3 id="UNIX架构"><a href="#UNIX架构" class="headerlink" title="UNIX架构"></a>UNIX架构</h3><p>用户态：系统调用接口<br>内核态：进程控制子系统，文件系统，设备驱动程序（块设备，字符系统），硬件控制层，系统调用接口</p>
<h3 id="linux内核组间"><a href="#linux内核组间" class="headerlink" title="linux内核组间"></a>linux内核组间</h3><p>内核态：进程调度，文件系统，设备驱动程序，网络服务</p>
<h2 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h2><h3 id="操作系统的发展历程"><a href="#操作系统的发展历程" class="headerlink" title="操作系统的发展历程"></a>操作系统的发展历程</h3><p>操作系统发展是随着计算机硬件技术、应用需求的发展、软件新技术的出现而发展的</p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>充分利用硬件<br>提供更好的服务  </p>
<h3 id="传统操作系统的分类"><a href="#传统操作系统的分类" class="headerlink" title="传统操作系统的分类"></a>传统操作系统的分类</h3><p>批处理操作系统<br>分时系统<br>实时操作系统<br>个人计算机操作系统<br>网络操作系统<br>分布式操作系统<br>嵌入式操作系统  </p>
<h4 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h4><ol>
<li>用户将作业交给系统操作员  </li>
<li>系统操作员将许多用户的作业组成一批作业，输入到计算机系统中，在系统中形成一个自动转接的连续的作业流  </li>
<li>启动操作系统  </li>
<li>系统自动、依次执行每个作业  </li>
<li>由操作员将作业结果交给用户  </li>
</ol>
<hr>
<p>目标：提高资源利用率，增加作业处理吞吐量  </p>
<hr>
<pre><code>批处理系统中的作业包括： 
1. 用户程序  
2. 数据  
3. 作业说明书（用作业控制语言编写）
</code></pre><hr>
<p> 成批：通常由若干个作业组成，用户提交作业后只能等待处理结果，不能干预自己作业的执行</p>
<hr>
<p>批作业处理：<br>对一批作业中的每个作业进行相同的处理：从磁带读入用户作业和编译链接程序，编译链接用户作业以生成可执行程序；启动执行；执行并输出结果  </p>
<hr>
<pre><code>问题：慢速的输入输出处理直接由主机来完成，输入输出时，CPU处于等待状态  
解决方案：卫星机：完成面向用户的输入输出（纸带或卡片），中间结果暂存在磁带或磁盘上
</code></pre><hr>
<pre><code>SPOOLING系統（技術）  
利用磁盘作缓冲，将输入、计算、输出分别组织成独立的任务流，使I/O和计算真正并行  
工作原理：  
用户作业加载到磁盘上的输入井
按某种调度策略选择几个搭配得当的作业，调入内存
作业运行的结果输出到磁盘上的输出井
运行结果从磁盘上的输出井送到打印机 
</code></pre><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><pre><code>操作系统将CPU的时间划分成若干个片段，称为时间片
    操作系统以时间片为单位，轮流为每个终端用户服务，每次服务一个时间片
    其特点是利用人的错觉，使用户感觉不到计算机在服务他人
</code></pre><hr>
<pre><code>追求目标：
    及时响应(依据是响应时间)
响应时间：
    从终端发出命令到系统给予回答所经历的时间
</code></pre><h4 id="通过操作系统"><a href="#通过操作系统" class="headerlink" title="通过操作系统"></a>通过操作系统</h4><p>分时系统与批处理系统结合  </p>
<hr>
<pre><code>原则：分时优先，批处理在后
“前台”：需要频繁交互的作业
“后台”：时间性要求不强的作业
</code></pre><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>是指使计算机能及时响应外部事件的请求，在规定的严格时间内完成对该事件的处理，并控制所有实时设备和实时任务协调一致地工作</p>
<hr>
<pre><code>分类：
    第一类：实时过程控制
        工业控制、航空、军事控制、...
    第二类：实时通信（信息）处理
        电讯（自动交换机）、银行、飞机订票、股市行情
</code></pre><hr>
<pre><code>追求目标：
    对外部请求在严格时间范围内作出响应
    高可靠性
</code></pre><hr>
<p>硬实时系统<br>软实时系统</p>
<h4 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h4><p>计算机在某一时间内为单用户服务</p>
<hr>
<pre><code>追求目标：
    界面友好，使用方便
    丰富的应用软件
</code></pre><h4 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h4><pre><code>基于计算机网络
    在各种计算机操作系统上
        按网络体系结构协议标准开发的软件
功能：
    网络管理，通信，安全，资源共享和各种网络应用
追求目标：相互通信，资源共享
</code></pre><h4 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h4><pre><code>分布式系统：或以计算机网络为基础，或以多处理机为基础，基本特征是处理分布在不同计算机上

分布式操作系统：是一个统一的操作系统，允许若干个计算机可相互协作共同完成一项任务。操作系统可将各种系统任务在分布式系统中任何处理机上运行，自动实现全系统范围内的任务分配、自动调度、均衡各处理机的工作负载

处理能力增强、速度更快、可靠性增强、具有透明性
</code></pre><h4 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h4><pre><code>嵌入式系统
    在各种设备、装置或系统中，完成特定功能的软硬件系统汽车、手机、电视机、MP3播放器
    它们是一个大设备、装置或系统中的一部分，这个大设备、装置或系统可以不是“计算机”
    通常工作在反应式或对处理时间有较严格要求环境中

嵌入式操作系统（Embedded Operating System）
    运行在嵌入式系统环境中，对整个嵌入式系统以及它所操作、控制的各种部件装置等等资源进行统一协调、调度、指挥和控制的系统软件
</code></pre><h4 id="智能卡操作系统"><a href="#智能卡操作系统" class="headerlink" title="智能卡操作系统"></a>智能卡操作系统</h4><pre><code>智能卡：一种包含有一块CPU芯片的卡片
特点
    非常严格的运行能耗和存储空间的限制
    有些智能卡只有单项功能，诸如电子支付
专用的操作系统  

有些智能卡是面向Java的，即在智能卡的ROM中有一个Java虚拟机解释器。Java 程序被下载到卡中并由JVM解释器解释。有些卡可以同时处理多个Java 小程序，这就是多道程序，并且需要对它们进行调度。在两个或多个小程序同时运行时，资源管理和保护就成为突出的问题。这些问题必须由卡上的操作系统处理
</code></pre><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><pre><code>重点阅读教材
    第1章相关内容：1.1、1.2、1.4
    第10章相关内容：10.2.5
    第11章相关内容：11.3.1.

重点概念
    操作系统定义 操作系统的三个作用
    并发 共享 虚拟 随机 SPOOLing技术 Windows、Linux、UNIX的架构
</code></pre><h1 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h1><h2 id="处理器状态"><a href="#处理器状态" class="headerlink" title="处理器状态"></a>处理器状态</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>处理器由运算器、控制器、一系列的寄存器以及高速缓存构成  </p>
<pre><code>两类寄存器：
    用户可见寄存器：高级语言编译器通过优化算法分配并使用之，以减少程序访问内存次数
    控制和状态寄存器：用于控制处理器的操作
                        通常由操作系统代码使用
</code></pre><h4 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h4><p>用于控制处理器的操作<br>在某种特权级别下可以访问、修改  </p>
<pre><code>常见的控制和状态寄存器
    程序计数器（PC：Program Counter），记录将要取出的指令的地址
    指令寄存器（IR：Instruction Register），记录最近取出的指令
    程序状态字（PSW：Program Status Word），记录处理器的运行状态如条件码、模式、控制位等信息
</code></pre><h3 id="操作系统的需求，保护"><a href="#操作系统的需求，保护" class="headerlink" title="操作系统的需求，保护"></a>操作系统的需求，保护</h3><p>从操作系统的特征考虑<br>并发、共享<br>提出要求 → 实现保护与控制  </p>
<pre><code>需要硬件提供基本运行机制：
    处理器具有特权级别，能在不同的特权级运行的不同指令集合
     硬件机制可将OS与用户程序隔离
</code></pre><h3 id="处理器的状态"><a href="#处理器的状态" class="headerlink" title="处理器的状态"></a>处理器的状态</h3><p>现代处理器通常将CPU状态设计划分为两种、三种或四种<br>在程序状态字寄存器PSW中专门设置一位，根据运行程序对资源和指令的使用权限而设置不同的CPU状态  </p>
<h3 id="特权指令和非特权指令"><a href="#特权指令和非特权指令" class="headerlink" title="特权指令和非特权指令"></a>特权指令和非特权指令</h3><pre><code>操作系统需要两种CPU状态
    内核态(Kernel Mode)：运行操作系统程序
    用户态(User Mode)：运行用户程序
</code></pre><hr>
<p>特权(privilege)指令：只能由操作系统使用、用户程序不能使用的指令<br>非特权指令：用户程序可以使用的指令</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>X86支持4个处理器特权级别<br>特权环：R0、R1、R2和R3  </p>
<pre><code>从R0到R3，特权能力由高到低
    R0相当于内核态；R3相当于用户态；R1和R2则介于两者之间
    不同级别能够运行的指令集合不同
</code></pre><p>目前大多数基于x86处理器的操作系统<br>只用了R0和R3两个特权级别</p>
<h3 id="CPU状态之间的转换"><a href="#CPU状态之间的转换" class="headerlink" title="CPU状态之间的转换"></a>CPU状态之间的转换</h3><pre><code>用户态 → 内核态
    唯一途径 → 中断/异常/陷入机制
内核态 → 用户态
    设置程序状态字PSW
</code></pre><hr>
<pre><code>一条特殊的指令：陷入指令（又称访管指令）
    提供给用户程序的接口，用于调用操作系统的功能（服务）
    例如：int，trap，syscall，sysenter/sysexit
</code></pre><h2 id="中断和异常机制"><a href="#中断和异常机制" class="headerlink" title="中断和异常机制"></a>中断和异常机制</h2><pre><code>中断/异常 对于操作系统的重要性
    就好比：汽车的发动机、飞机的引擎
→→ 可以说 操作系统
    是由“中断驱动”或者 “事件驱动”的
</code></pre><hr>
<pre><code>主要作用
    及时处理设备发来的中断请求
    可使OS捕获用户程序提出的服务请求
    防止用户程序执行过程中的破坏性活动
    … … 等等
</code></pre><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>CPU对系统发生的某个事件作出的一种反应<br>CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序  </p>
<pre><code>特点：
•是随机发生的
•是自动处理的
•是可恢复的

事件的发生改变了处理器的控制流
</code></pre><h3 id="为什么引入中断与异常"><a href="#为什么引入中断与异常" class="headerlink" title="为什么引入中断与异常"></a>为什么引入中断与异常</h3><pre><code>中断的引入：为了支持CPU和设备之间的并行操作
    当CPU启动设备进行输入/输出后，设备便可以独立工作，CPU转去处理与此次输入/输出不相关的事情；
    当设备完成输入/输出后，通过向CPU发中断报告此次输入/输出的结果，让CPU决定如何处理以后的事情

异常的引入：表示CPU执行指令时本身出现的问题
    如算术溢出、除零、取数时的奇偶错，访存地址时越界或执行了“陷入指令” 等，
    这时硬件改变了CPU当前的执行流程，转到相应的错误处理程序或异常处理程序或执行系统调用
</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>中断：外部事件，正在运行的程序所不期望的<br>异常：由正在执行的指令引发  </p>
<pre><code>中断(外中断)
    I/O中断
    时钟中断
    硬件故障

异常(内中断)
    系统调用
    页故障/页错误
    保护性异常
    断点指令
    其他程序性异常
    (如算术溢出等)
</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>类别        原因                        异步/同步        返回行为
中断
Interrupt    来自I/O设备、其他硬件部件    异步            总是返回到下一条指令
陷入Trap    有意识安排的                  同步            返回到下一条指令

故障Fault    可恢复的错误                  同步            返回到当前指令

终止Abort    不可恢复的错误                 同步            不会返回
</code></pre><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>中断/异常机制是现代计算机系统的核心机制之一<br>硬件和软件相互配合而使计算机系统得以充分发挥能力</p>
<hr>
<pre><code>硬件该做什么事？ —— 中断/异常响应
    捕获中断源发出的中断/异常请求，以一定方式响应，将处理器控制权交给特定的处理程序
软件要做什么事？ —— 中断/异常处理程序
    识别中断/异常类型并完成相应的处理
</code></pre><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><pre><code>中断响应：
     发现中断、接收中断的过程
     由中断硬件部件完成
</code></pre><h4 id="过程示意"><a href="#过程示意" class="headerlink" title="过程示意"></a>过程示意</h4><p>开始-&gt;取下一条指令-&gt;执行指令-&gt;检查指令-&gt;处理中断</p>
<hr>
<pre><code>在每条指令执行周期的最后时刻扫描中断寄存器，查看是否有中断信号？
若有中断，中断硬件将该中断触发器内容按规定编码送入PSW的相应位，称为中断码，通过查中断向量表引出中断处理程序
若无中断信号，继续执行下一条指令
</code></pre><h4 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h4><pre><code>中断向量：
    一个内存单元，存放中断处理程序入口地址和程序运行时所需的处理机状态字
</code></pre><hr>
<p>执行流程按中断号/异常类型的不同，通过中断向量表<br>转移控制权给中断处理程序<br>中断向量表<br>中断处理程序</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><pre><code>1. 设备发中断信号
2. 硬件保存现场
3. 根据中断码查表
4. 把中断处理程序入口地址等推送到相应的寄存器
5. 执行中断处理程序
</code></pre><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>设计操作系统时，为每一类中断/异常事件编好相应的处理程序，并设置好中断向量表  </p>
<pre><code>系统运行时若响应中断，中断硬件部件将CPU控制权转给中断处理程序：
    保存相关寄存器信息
    分析中断/异常的具体原因
    执行对应的处理功能
    恢复现场，返回被事件打断的程序
</code></pre><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><pre><code>以设备输入输出中断为例： 
    打印机给CPU发中断信号
    CPU处理完当前指令后检测到中断，判断出中断来源并向相关设备发确认信号

    CPU开始为软件处理中断做准备：
        处理器状态被切换到内核态
        在系统栈中保存被中断程序的重要上下文环境，主要是程序计数器PC、程序状态字PSW

    PU根据中断码查中断向量表，获得与该中断相关的处理程序的入口地址，并将PC设置成该地址，新的指令周期开始时，CPU控制转移到中断处理程序

    中断处理程序开始工作
        在系统栈中保存现场信息
        检查I/O设备的状态信息，操纵I/O设备或者在设备和内存之间传送数据等等

    中断处理结束时，CPU检测到中断返回指令，从系统栈中恢复被中断程序的上下文环境 ，CPU状态恢复成原来的状态，PSW和PC恢复成中断前的值，CPU开始一个新的指令周期
</code></pre><hr>
<pre><code>I/O中断处理程序
通常分为两类处理：

    I/O操作正常结束
        若有程序正等待此次I/O的结果，则应将其唤醒
        若要继续I/O操作，需要准备好数据重新启动I/O

    I/O操作出现错误
        需要重新执行失败的I/O操作
        重试次数有上限，达到时系统将判定硬件故障
</code></pre><h2 id="实例：x86处理器"><a href="#实例：x86处理器" class="headerlink" title="实例：x86处理器"></a>实例：x86处理器</h2><pre><code>中断
    由硬件信号引发的，分为可屏蔽和不可屏蔽中断
异常
    由指令执行引发的，比如除零异常
    80x86处理器发布了大约20种不同的异常
    对于某些异常，CPU会在执行异常处理程序之前产生硬件出错码，并压入内核态堆栈
系统调用
    异常的一种，用户态到内核态的唯一入口
</code></pre><h2 id="x86处理器对中断的支持"><a href="#x86处理器对中断的支持" class="headerlink" title="x86处理器对中断的支持"></a>x86处理器对中断的支持</h2><pre><code>中断控制器（PIC或APIC）
    负责将硬件的中断信号转换为中断向量，并引发CPU中断

实模式：中断向量表 (Interrupt Vector)
    存放中断服务程序的入口地址
        入口地址＝段地址左移4位＋偏移地址
        不支持CPU运行状态切换
        中断处理与一般的过程调用相似

保护模式：中断描述符表 (Interrupt Descriptor Table)
    采用门(gate) 描述符数据结构表示中断向量
</code></pre><hr>
<pre><code>中断向量表/中断描述符表
    四种类型门描述符
        任务门(Task Gate)
        中断门(Interrupt Gate)
            给出段选择符 (Segment Selector)、中断/异常程序的段内偏移量 (Offset)
            通过中断门后系统会自动禁止中断
        陷阱门(Trap Gate)
            与中断门类似，但通过陷阱门后系统不会自动禁止中断
        调用门(Call Gate)
</code></pre><hr>
<pre><code>中断/异常的硬件处理过程：
    确定与中断或异常关联的向量i
    通过IDTR寄存器找到IDT表，获得中断描述符（表中的第i项）
    从GDTR寄存器获得GDT的地址；结合中断描述符中的段选择符，在GDT表获取对应的段描述符；从该段描述符中得到中断或异常处理程序所在的段基址
    特权级检查
</code></pre><hr>
<pre><code>检查是否发生了特权级的变化，如果是，则进行堆栈切换(必须使用与新的特权级相关的栈)
硬件压栈，保存上下文环境；如果异常产生了硬件出错码，也将它保存在栈中
如果是中断，清IF位
通过中断描述符中的段内偏移量和段描述符中的基地址，找到中断/异常处理程序的入口地址，执行其第一条指令
</code></pre><h2 id="系统调用机制"><a href="#系统调用机制" class="headerlink" title="系统调用机制"></a>系统调用机制</h2><pre><code>系统调用：用户在编程时可以调用的操作系统功能
</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><pre><code>系统调用是操作系统提供给编程人员的唯一接口
使CPU状态从用户态陷入内核态
</code></pre><h3 id="典型系统调用"><a href="#典型系统调用" class="headerlink" title="典型系统调用"></a>典型系统调用</h3><pre><code>每个操作系统都提供几百种系统调用（进程控制、进程通信、文件使用、目录操作、设备管理、信息维护等）
</code></pre><h3 id="系统调用机制的设计"><a href="#系统调用机制的设计" class="headerlink" title="系统调用机制的设计"></a>系统调用机制的设计</h3><pre><code>中断/异常机制
    支持系统调用服务的实现
选择一条特殊指令：陷入指令(亦称访管指令)
    引发异常，完成用户态到内核态的切换
系统调用号和参数 
    每个系统调用都事先给定一个编号(功能号)
    编译器也会参与
系统调用表
    存放系统调用服务例程的入口地址
</code></pre><h3 id="参数传递过程问题"><a href="#参数传递过程问题" class="headerlink" title="参数传递过程问题"></a>参数传递过程问题</h3><pre><code>怎样实现用户程序的参数传递给内核？

常用的3种实现方法：
    由陷入指令自带参数：陷入指令的长度有限，且还要携带系统调用功
    能号，只能自带有限的参数
    通过通用寄存器传递参数：这些寄存器是操作系统和用户程序都能访
    问的，但寄存器的个数会限制传递参数的数量
    在内存中开辟专用堆栈区来传递参数
</code></pre><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><pre><code>当CPU执行到特殊的陷入指令时：  
    中断/异常机制：硬件保护现场；通过查中断向量表把控制权转给系统调用总入口程序
    系统调用总入口程序：保存现场；将参数保存在内核堆栈里；通过查系统调用表把控制权转给相应的系统调用处理例程或内核函数
    执行系统调用例程
    恢复现场，返回用户程序
</code></pre><h2 id="基于x86处理器的linux的系统调用实现"><a href="#基于x86处理器的linux的系统调用实现" class="headerlink" title="基于x86处理器的linux的系统调用实现"></a>基于x86处理器的linux的系统调用实现</h2><pre><code>陷入指令选择128号
    int $0x80
</code></pre><hr>
<pre><code>门描述符
    系统初始化时：对IDT表中的128号门初始化
    门描述符的2、3两个字节：内核代码段选择符
    0、1、6、7四个字节：偏移量（指向system_call()）
    门类型：15，陷阱门，为什么？执行系统调用的过程中，还接收中断
    DPL：3，与用户级别相同，允许用户进程使用该门描述符
</code></pre><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><pre><code>由于特权级的改变，要切换栈
    用户栈 → 内核栈
    CPU从任务状态段TSS中装入新的栈指针（SS︰ESP），指向内核栈

内核栈
    用户栈的信息（SS︰ESP）、EFLAGS、用户态CS 、EIP 寄存器的内容压栈（返回用）
    将EFLAGS压栈后，复位TF，IF位保持不变
    用128在IDT中找到该门描述符，从中找出段选择符装入代码段寄存器CS
    代码段描述符中的基地址 + 陷阱门描述符中的偏移量 → 定位 system_call()的入口地址
</code></pre><h3 id="调用执行流程"><a href="#调用执行流程" class="headerlink" title="调用执行流程"></a>调用执行流程</h3><p>应用程序-&gt;封装例程-&gt;陷入处理-&gt;内核函数-&gt;</p>
<h3 id="OS底层工作步骤"><a href="#OS底层工作步骤" class="headerlink" title="OS底层工作步骤"></a>OS底层工作步骤</h3><pre><code>1. 硬件压栈：程序计数器等
2. 硬件从中断向量装入新的程序计数器等
3. 汇编语言过程保存寄存器值
4. 汇编语言过程设置新的堆栈
5. C语言中断服务程序运行（例：读并缓冲输入）
6. 进程调度程序决定下一个将运行的进程
7. C语言过程返回至汇编代码
8. 汇编语言过程开始运行新的当前进程
</code></pre><h2 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h2><pre><code>理解计算机系统的保护机制
    掌握处理器状态
     掌握特权指令与非特权指令
 掌握中断/异常机制
     掌握中断/异常的基本概念
     理解中断/异常机制的工作原理
 掌握系统调用机制
    掌握系统调用设计原理
    掌握系统调用执行过程
</code></pre><hr>
<pre><code>重点阅读教材
    第1章相关内容：1.3、1.6
    第2章 第52页 图2-5及说明该图思路的段落
重点概念
    CPU状态 内核态/用户态 特权指令/非特权指令
    中断 异常 中断响应 中断向量 中断处理程序
    系统调用 陷入指令 系统调用号 系统调用表
</code></pre><h1 id="进程-线程模型"><a href="#进程-线程模型" class="headerlink" title="进程/线程模型"></a>进程/线程模型</h1><h2 id="进程基本概念"><a href="#进程基本概念" class="headerlink" title="进程基本概念"></a>进程基本概念</h2><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><pre><code>多道程序设计
    允许多个程序同时进入内存并运行，其目的是为了提高系统效率
</code></pre><h3 id="并发环境与并发程序"><a href="#并发环境与并发程序" class="headerlink" title="并发环境与并发程序"></a>并发环境与并发程序</h3><pre><code>并发环境：
        一段时间间隔内，单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态，并且次序不是事先确定的

并发程序：在并发环境中执行的程序
</code></pre><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><pre><code>定义：Process
    进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位
又称 任务（Task or Job）
</code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre><code>程序的一次执行过程
是正在运行程序的抽象
将一个CPU变幻成多个虚拟的CPU
系统资源以进程为单位分配，如内存、文件、……
    每个具有独立的地址空间
操作系统将CPU调度给需要的进程
</code></pre><h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><pre><code>PCB：Process Control Block
    又称 进程描述符、进程属性
    操作系统用于管理控制进程的一个专门数据结构
    记录进程的各种属性，描述进程的动态变化过程

PCB是系统感知进程存在的唯一标志
    → 进程与PCB是一一对应的

进程表：所有进程的PCB集合
</code></pre><hr>
<pre><code>进程描述信息
    进程标识符(process ID)，唯一，通常是一个整数
    进程名，通常基于可执行文件名，不唯一
    用户标识符(user ID)
    进程组关系

当前状态
    优先级(priority)
    代码执行入口地址
    程序的磁盘地址
    运行统计信息(执行时间、页面调度)
    进程间同步和通信
    进程的队列指针
    进程的消息队列指针

所拥有的资源和使用情况
    虚拟地址空间的状况
    打开文件列表

CPU现场信息
    寄存器值(通用寄存器、程序计数器PC、程序状态字PSW、栈指针)
    指向该进程页表的指针
</code></pre><hr>
<p>Linux：task_struct<br>Windows：EPROCESS、KPROCESS、PEB  </p>
<h4 id="Linux：task-struct"><a href="#Linux：task-struct" class="headerlink" title="Linux：task_struct"></a>Linux：task_struct</h4><p>非常之多</p>
<h2 id="进程状态及状态转换"><a href="#进程状态及状态转换" class="headerlink" title="进程状态及状态转换"></a>进程状态及状态转换</h2><h3 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h3><pre><code>进程的三种基本状态：
运行态、就绪态、等待态

运行态（Running）
    占有CPU，并在CPU上运行
就绪态（Ready）
    已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
等待态（Waiting/Blocked）阻塞态、封锁态、睡眠态
    因等待某一事件而暂时不能运行
</code></pre><h3 id="三状态模型以及状态转换"><a href="#三状态模型以及状态转换" class="headerlink" title="三状态模型以及状态转换"></a>三状态模型以及状态转换</h3><pre><code>就绪 → 运行
    调度程序选择一个新的进程运行

运行 → 就绪
    运行进程用完了时间片
    一个高优先级进程进入就绪状态，抢占正在运行的进程

运行 → 等待
    当一个进程等待某个事件发生时
        请求OS服务
        对资源的访问尚不能进行
        等待I/O结果
        等待另一进程提供信息

等待 → 就绪
    所等待的事件发生了
</code></pre><h3 id="其他状态"><a href="#其他状态" class="headerlink" title="其他状态"></a>其他状态</h3><pre><code>创建
    已完成创建一进程所必要的工作
        –PID、PCB
    但尚未同意执行该进程
        –因为资源有限

终止
    终止执行后，进程进入该状态
    可完成一些数据统计工作
    资源回收

挂起
    用于调节负载
    进程不占用内存空间，其进程映像交换到磁盘上
</code></pre><h3 id="五状态进程模型"><a href="#五状态进程模型" class="headerlink" title="五状态进程模型"></a>五状态进程模型</h3><p><img src="http://i.imgur.com/Md58ooA.jpg" alt=""></p>
<h3 id="七状态进程模型"><a href="#七状态进程模型" class="headerlink" title="七状态进程模型"></a>七状态进程模型</h3><p>添加了就绪挂起和阻塞挂起<br><img src="http://i.imgur.com/QtK5q30.jpg" alt=""></p>
<h3 id="linux状态示意图"><a href="#linux状态示意图" class="headerlink" title="linux状态示意图"></a>linux状态示意图</h3><p><img src="http://i.imgur.com/zfUhtic.jpg" alt=""></p>
<h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><p>操作系统为每一类进程建立一个或多个队列<br>队列元素为PCB<br>伴随进程状态的改变，其PCB从一个队列进入另一个队列<br><img src="http://i.imgur.com/XZeZzlY.jpg" alt=""></p>
<h3 id="五状态进程的队列模型"><a href="#五状态进程的队列模型" class="headerlink" title="五状态进程的队列模型"></a>五状态进程的队列模型</h3><p><img src="http://i.imgur.com/SdcJiLx.jpg" alt=""></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><pre><code>进程控制操作完成进程各状态之间的转换，由具有特定功能的原语完成
    进程创建原语
    进程撤消原语
    阻塞原语
    唤醒原语
    挂起原语
    激活原语
    改变进程优先级
</code></pre><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><pre><code>给新进程分配一个唯一标识以及进程控制块
为进程分配地址空间
初始化进程控制块
设置默认值 (如: 状态为 New，...)
设置相应的队列指针
    如: 把新进程加到就绪队列链表中
</code></pre><h3 id="进程的撤销"><a href="#进程的撤销" class="headerlink" title="进程的撤销"></a>进程的撤销</h3><pre><code>结束进程
    收回进程所占有的资源
    关闭打开的文件、断开网络连接、回收分配的内存、……
    撤消该进程的PCB
</code></pre><h3 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h3><pre><code>处于运行状态的进程，在其运行过程中期待某一事件发生，如等待键盘输入、等待磁盘数据传输完成、等待其它进程发送消息，当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态
</code></pre><h3 id="Unix的几个进程控制操作"><a href="#Unix的几个进程控制操作" class="headerlink" title="Unix的几个进程控制操作"></a>Unix的几个进程控制操作</h3><pre><code>fork() 通过复制调用进程来建立新的进程，是最基本的进程建立过程

exec() 包括一系列系统调用，它们都是通过用一段新的程序代码覆盖原来的地址空间，实现进程执行代码的转换

wait() 提供初级进程同步操作，能使一个进程等待另外一个进程的结束

exit() 用来终止一个进程的运行
</code></pre><h4 id="Unix的FORK-的实现"><a href="#Unix的FORK-的实现" class="headerlink" title="Unix的FORK()的实现"></a>Unix的FORK()的实现</h4><pre><code>为子进程分配一个空闲的进程描述符
    proc 结构
分配给子进程唯一标识 pid
以一次一页的方式复制父进程地址空间？
从父进程处继承共享资源，如打开的文件和当前工作目录等
将子进程的状态设为就绪，插入到就绪队列
对子进程返回标识符 0
向父进程返回子进程的 pid
</code></pre><p>Linux使用了写时复制技术COW加快创建进程Copy-On-Write</p>
<p>示例方法</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
void main(int argc, char *argv[])
{
    pid_t pid;
    pid = fork(); /* 创建一个子进程 */
    if (pid &lt; 0) { /* 出错 */
        fprintf(stderr, “fork failed”);
        exit(-1); }
    else if (pid == 0) { /* 子进程 */
        execlp(“/bin/ls”, “ls”, NULL); }
    else { /* 父进程 */
        wait(NULL); /* 父进程等待子进程结束 */
        printf(“child complete”);
        exit(0);
}
}
</code></pre><h2 id="深入理解进程概念"><a href="#深入理解进程概念" class="headerlink" title="深入理解进程概念"></a>深入理解进程概念</h2><h3 id="关于进程的讨论"><a href="#关于进程的讨论" class="headerlink" title="关于进程的讨论"></a>关于进程的讨论</h3><p><img src="http://i.imgur.com/cS7YiDl.jpg" alt=""></p>
<h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><pre><code>进程更能准确刻画并发，而程序不能
程序是静态的，进程是动态的
进程有生命周期的，有诞生有消亡，是短暂的；而程序是相对长久的
一个程序可对应多个进程
进程具有创建其他进程的功能
</code></pre><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><p>操作系统给每个进程都分配了一个地址空间</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>int myval;
int main(int argc, char *argv[])
{
myval = atoi(argv[1]);
while (1)
    printf(“myval is %d, loc 0x%lx\n”,
        myval, (long) &amp;myval);
}
</code></pre><p><strong>输出结果</strong><br><img src="http://i.imgur.com/2ejIZu1.jpg" alt=""></p>
<h4 id="进程地址空间图示"><a href="#进程地址空间图示" class="headerlink" title="进程地址空间图示"></a>进程地址空间图示</h4><p><img src="http://i.imgur.com/6iYnFgF.jpg" alt=""></p>
<h3 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h3><pre><code>对进程执行活动全过程的静态描述
    由进程地址空间内容、硬件寄存器内容及与该进程相关的内核数据结构、内核栈组成

用户相关：进程地址空间（包括代码段、数据段、堆和栈、共享库……）
寄存器相关：程序计数器、指令寄存器、程序状态寄存器、栈指针、通用寄存器等的值
内核相关：
    静态部分：PCB及各种资源数据结构
    动态部分：内核栈（不同进程在进入内核后使用不同的内核栈）
</code></pre><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><pre><code>将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换

进程运行时，其硬件状态保存在CPU上的寄存器中
寄存器：程序计数器、程序状态寄存器、栈指针、通用寄存器、其他控制寄存器的值

进程不运行时，这些寄存器的值保存在进程控制块PCB中；当操作系统要运行一个新的进程时，将PCB中的相关值送到对应的寄存器中
</code></pre><h2 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h2><h3 id="为什么在进程中再派生线程？"><a href="#为什么在进程中再派生线程？" class="headerlink" title="为什么在进程中再派生线程？"></a>为什么在进程中再派生线程？</h3><pre><code>三个理由
    应用的需要
    开销的考虑
    性能的考虑
</code></pre><h3 id="典型的应用"><a href="#典型的应用" class="headerlink" title="典型的应用"></a>典型的应用</h3><pre><code>Web服务器
工作方式
    从客户端接收网页请求（http协议）
    从磁盘上检索相关网页，读入内存
    将网页返回给对应的客户端
如何提高服务器工作效率？
    网页缓存（Web page Cache）
</code></pre><h4 id="如果没有线程"><a href="#如果没有线程" class="headerlink" title="如果没有线程"></a>如果没有线程</h4><pre><code>两种解决方案：
    一个服务进程
        顺序编程；性能下降
    有限状态机
        编程模型复杂；采用非阻塞I/O
</code></pre><h4 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h4><h4 id="开销的考虑"><a href="#开销的考虑" class="headerlink" title="开销的考虑"></a>开销的考虑</h4><pre><code>进程相关的操作：
    创建进程
    撤消进程
    进程通信
    进程切换
→ 时间/空间开销大，限制了并发度的提高
</code></pre><hr>
<pre><code>线程的开销小
    创建一个新线程花费时间少（撤销亦如此）
    两个线程切换花费时间少
    线程之间相互通信无须调用内核（同一进程内的线程共享内存和文件）
</code></pre><hr>
<pre><code>多个线程，有的计算，有的I/O
    多个处理器
</code></pre><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h4><p>线程继承了进程的属性<br>线程：进程中的一个运行实体，是CPU的调度单位 有时将线程称为轻量级进程<br>在同一进程增加了多个执行序列（线程）</p>
<h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><pre><code>线程：
    有标示符ID
    有状态及状态转换 → 需要提供一些操作
    不运行时需要保存的上下文
        有上下文环境：程序计数器等寄存器
    有自己的栈和栈指针 

    共享所在进程的地址空间和其他资源

    可以创建、撤消另一个线程
        程序开始是以一个单线程进程方式运行的
</code></pre><h2 id="线程机制的实现"><a href="#线程机制的实现" class="headerlink" title="线程机制的实现"></a>线程机制的实现</h2><pre><code>用户级线程
核心级线程
混合—两者结合方法
</code></pre><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><pre><code>在用户空间建立线程库：提供一组管理线程的过程
运行时系统：完成线程的管理工作（操作、线程表）
内核管理的还是进程，不知道线程的存在
线程切换不需要内核态特权
例子：UNIX
</code></pre><h4 id="POSIX线程库"><a href="#POSIX线程库" class="headerlink" title="POSIX线程库"></a>POSIX线程库</h4><p><img src="http://i.imgur.com/0OmstJz.jpg" alt=""></p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><pre><code>优点：
    线程切换快
    调度算法是应用程序特定的
    用户级线程可运行在任何操作系统上（只需要实现线程库）
缺点：
    内核只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上
    大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中所有线程也被阻塞（如何改变？）
</code></pre><h3 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h3><pre><code>内核管理所有线程管理，并向应用程序提供API接口
内核维护进程和线程的上下文
线程的切换需要内核支持
以线程为基础进行调度
例子：Windows
</code></pre><h3 id="混合模型"><a href="#混合模型" class="headerlink" title="混合模型"></a>混合模型</h3><pre><code>线程创建在用户空间完成
线程调度等在核心态完成
</code></pre><h2 id="重点小结"><a href="#重点小结" class="headerlink" title="重点小结"></a>重点小结</h2><pre><code>并发性 任何进程都可以与其他进程一起向前推进
动态性 进程是正在执行程序的实例
    进程是动态产生，动态消亡的
    进程在其生命周期内，在三种基本状态之间转换
独立性 
    进程是资源分配的一个独立单位 例如：各进程的地址空间相互独立
交互性 
    指进程在执行过程中可能与其他进程产生直接或间接的关系
异步性 
    每个进程都以其相对独立的、不可预知的速度向前推进
进程映像 
    程序 + 数据 + 栈(用户栈、内核栈) + PCB
</code></pre><hr>
<pre><code>线程
    多线程应用场景
    线程基本概念、属性
    线程实现机制

可再入程序（可重入）：
    可被多个进程同时调用的程序，具有下列性质：
    它是纯代码的，即在执行过程中自身不改变；调用它的进程应该提供数据区
</code></pre><hr>
<pre><code>重点阅读教材
第2章相关内容：2.1、2.2(除2.2.8-2.2.10外)
</code></pre><h1 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是处理器调度"><a href="#什么是处理器调度" class="headerlink" title="什么是处理器调度"></a>什么是处理器调度</h3><pre><code>CPU调度
    —— 其任务是控制、协调进程对CPU的竞争
    即按一定的调度算法从就绪队列中选择一个进程，把CPU的使用权交给被选中的进程
    如果没有就绪进程，系统会安排一个系统空闲进程或idle进程
</code></pre><hr>
<pre><code>系统场景
    N个进程就绪、等待上CPU运行
    M个CPU，M ≥ 1
    需要决策：给哪一个进程分配哪一个CPU？
</code></pre><h3 id="要解决的三个问题"><a href="#要解决的三个问题" class="headerlink" title="要解决的三个问题"></a>要解决的三个问题</h3><pre><code>WHAT：按什么原则选择下一个要执行的进程
    — 调度算法

WHEN：何时选择
    — 调度时机

HOW： 如何让被选中的进程上CPU运行
    — 调度过程（进程的上下文切换）
</code></pre><h3 id="调度的时机"><a href="#调度的时机" class="headerlink" title="调度的时机"></a>调度的时机</h3><pre><code>事件发生 → 当前运行的进程暂停运行 → 硬件机制响应后 → 进入操作系统，处理相应的事件 → 结束处理后：
某些进程的状态会发生变化，也可能又创建了一些新的进程
→ 就绪队列有调整 → 需要进程调度根据预设的调度算法从就绪队列选一个进程
</code></pre><hr>
<pre><code>典型的事件举例：
创建、唤醒、退出等进程控制操作
进程等待I/O、I/O中断
时钟中断，如：时间片用完、计时器到时
进程执行过程中出现abort异常
</code></pre><hr>
<h4 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h4><pre><code>进程正常终止 或 由于某种错误而终止
新进程创建 或 一个等待进程变成就绪
当一个进程从运行态进入阻塞态
当一个进程从运行态变为就绪态
</code></pre><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><pre><code>进程调度程序从就绪队列选择了要运行的进程：
    这个进程可以是刚刚被暂停执行的进程，也可能是另一个新的进程
进程切换
    进程切换：是指一个进程让出处理器，由另一个进程占用处理器的过程
</code></pre><hr>
<pre><code>进程切换主要包括两部分工作：
    切换全局页目录以加载一个新的地址空间
    切换内核栈和硬件上下文，其中硬件上下文包括了内核执行新进程需要的全部信息，如CPU相关寄存器

切换过程包括了对原来运行进程各种状态的保存和对新的进程各种状态的恢复
</code></pre><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><p>场景：进程A下CPU，进程B上CPU  </p>
<pre><code>保存进程A的上下文环境（程序计数器、程序状态字、其他寄存器……）
用新状态和其他相关信息更新进程A的PCB
把进程A移至合适的队列（就绪、阻塞……）
将进程B的状态设置为运行态
从进程B的PCB中恢复上下文（程序计数器 、程序状态字、其他寄存器……）
</code></pre><h4 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h4><pre><code>直接开销：内核完成切换所用的CPU时间
    保存和恢复寄存器……
    切换地址空间（相关指令比较昂贵）
间接开销
    高速缓存(Cache)、缓冲区缓存(Buffer Cache)和TLB(Translation Look-aside Buffer)失效
</code></pre><h3 id="调度算法的设计"><a href="#调度算法的设计" class="headerlink" title="调度算法的设计"></a>调度算法的设计</h3><pre><code>什么情况下需要仔细斟酌调度算法？
    批处理系统 → 多道程序设计系统 → 批处理与分时的混合系统 → 个人计算机 → 网络服务器
</code></pre><h4 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h4><pre><code>吞吐量 Throughput — 每单位时间完成的进程数目
周转时间TT(Turnaround Time)
    每个进程从提出请求到运行完成的时间
响应时间RT(Response Time)
    从提出请求到第一次回应的时间

其他
    CPU 利用率(CPU Utilization)
        CPU做有效工作的时间比例
    等待时间(Waiting time)
        每个进程在就绪队列(ready queue)中等待的时间
</code></pre><h2 id="设计调度算法要考虑的几个问题"><a href="#设计调度算法要考虑的几个问题" class="headerlink" title="设计调度算法要考虑的几个问题"></a>设计调度算法要考虑的几个问题</h2><h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><pre><code>静态优先级：
    进程创建时指定，运行过程中不再改变
动态优先级：
    进程创建时指定了一个优先级，运行过程中可以动态变化
如：等待时间较长的进程可提升其优先级
</code></pre><h3 id="进程就绪队列组织"><a href="#进程就绪队列组织" class="headerlink" title="进程就绪队列组织"></a>进程就绪队列组织</h3><p>按优先级排队</p>
<p>另一种排队方式</p>
<h3 id="抢占与非抢占"><a href="#抢占与非抢占" class="headerlink" title="抢占与非抢占"></a>抢占与非抢占</h3><pre><code>指占用CPU的方式：
    可抢占式Preemptive（可剥夺式）
        当有比正在运行的进程优先级更高的进程就绪时，系统可强行剥夺正在运行进程的CPU，提供给具有更高优先级的进程使用
    不可抢占式Non-preemptive（不可剥夺式 ）
        某一进程被调度运行后，除非由于它自身的原因不能运行，否则一直运行下去
</code></pre><h3 id="IO密集型与CPU密集型进程"><a href="#IO密集型与CPU密集型进程" class="headerlink" title="IO密集型与CPU密集型进程"></a>IO密集型与CPU密集型进程</h3><pre><code>按进程执行过程中的行为划分：
    I/O密集型或I/O型(I/O-bound)
        频繁的进行I/O，通常会花费很多时间等待I/O操作的完成
     CPU密集型或CPU型或计算密集型(CPU-bound)
        需要大量的CPU时间进行计算
</code></pre><h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><pre><code>Time slice 或 quantum
一个时间段，分配给调度上CPU的进程，确定了允许该进程运行的时间长度
如何选择时间片呢？
</code></pre><h2 id="批处理系统的调度算法"><a href="#批处理系统的调度算法" class="headerlink" title="批处理系统的调度算法"></a>批处理系统的调度算法</h2><pre><code>先来先服务（FCFS-First Come First Serve）
最短作业优先（SJF-Shortest Job First）
最短剩余时间优先
（SRTN-Shortest Remaining Time Next）
最高相应比优先
（HRRN-Highest Response Ratio Next）
</code></pre><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><pre><code>First Come First Serve
    先进先出 First In First Out (FIFO)
    按照进程就绪的先后顺序使用CPU
    非抢占

优缺点
公平
实现简单
长进程后面的短进程需要等很长时间，不利于用户体验
</code></pre><h3 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h3><pre><code>Shortest Job First
具有最短完成时间的进程优先执行
非抢占式

最短剩余时间优先
    Shortest Remaining Time Next(SRTN)
SJF抢占式版本，即当一个新就绪的进程比当前运行进程具有更短的完成时间时，系统抢占当前进程，选择新就绪的进程执行
</code></pre><hr>
<pre><code>优缺点
    最短的平均周转时间
        在所有进程同时可运行时，采用SJF调度算法可以得到最短的平均周转时间
不公平
源源不断的短任务到来，可能使长的任务长时间得不到运行 → 产生 “饥饿”现象 (starvation)
</code></pre><h3 id="最高相应比优先HRRN"><a href="#最高相应比优先HRRN" class="headerlink" title="最高相应比优先HRRN"></a>最高相应比优先HRRN</h3><pre><code>Highest Response Ratio Next
是一个综合的算法
调度时，首先计算每个进程的响应比R；之后，总是选择 R 最高的进程执行
</code></pre><hr>
<pre><code>响应比R = 周转时间 / 处理时间 =（处理时间 + 等待时间）/ 处理时间 = 1 +（等待时间 / 处理时间）
</code></pre><h2 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a>交互式系统的调度算法</h2><p>轮转调度（RR-Round Robin）<br>最高优先级调度（HPF—Highest Priority First）<br>多级反馈队列（Multiple feedback queue）<br>最短进程优先（Shortest Process Next）</p>
<h3 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h3><pre><code>目标
    为短任务改善平均响应时间
解决问题的思路
    周期性切换
    每个进程分配一个时间片
    时钟中断 → 轮换
</code></pre><hr>
<pre><code>如何选择合适的时间片?
    太长 --大于典型的交互时间
        降级为先来先服务算法
        延长短进程的响应时间
    太短 --小于典型的交互时间
        进程切换浪费CPU时间
</code></pre><hr>
<pre><code>优缺点
    公平
    有利于交互式计算，响应时间快
    由于进程切换，时间片轮转算法要花费较高的开销
假设时间片 10ms，如果进程切换花费0.1ms，CPU开销约占1%
    RR对不同大小的进程是有利的
    但是对于相同大小的进程呢？
</code></pre><p>但是对于相同大小的进程呢？</p>
<h3 id="虚拟轮转法"><a href="#虚拟轮转法" class="headerlink" title="虚拟轮转法"></a>虚拟轮转法</h3><p>有一个辅助队列，选择其中的IO进程，辅助队列为空，再从就绪队列中选</p>
<h3 id="最高优先级调度"><a href="#最高优先级调度" class="headerlink" title="最高优先级调度"></a>最高优先级调度</h3><pre><code>选择优先级最高的进程投入运行
通常：系统进程优先级 高于 用户进程
    前台进程优先级 高于 后台进程
    操作系统更偏好 I/O型进程
优先级可以是静态不变的，也可以动态调整
    优先数可以决定优先级
就绪队列可以按照优先级组织
实现简单；不公平
</code></pre><hr>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><pre><code>又称：优先级反置、翻转、倒挂
现象
    一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行
</code></pre><hr>
<pre><code>设H是高优先级进程，L是低优先级进程， M是中优先级进程（CPU型）
    场景：L进入临界区执行，之后被抢占；
        H也要进入临界区，失败，被阻塞；
        M上CPU执行，L无法执行所以H也无法执行
</code></pre><hr>
<pre><code>影响
    系统错误
    高优先级进程停滞不前，导致系统性能降低

解决方案
    设置优先级上限
    优先级继承
    使用中断禁止
</code></pre><h2 id="多级反馈队列调度算法、各种调度算法小结等"><a href="#多级反馈队列调度算法、各种调度算法小结等" class="headerlink" title="多级反馈队列调度算法、各种调度算法小结等"></a>多级反馈队列调度算法、各种调度算法小结等</h2><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><pre><code>Multilevel Feedback
是UNIX的一个分支BSD （加州大学伯克利分校开发和发布的）5.3版所采用的调度算法
是一个综合调度算法
</code></pre><hr>
<pre><code>设置多个就绪队列，第一级队列优先级最高
给不同就绪队列中的进程分配长度不同的时间片，第一级队列时间片最小；随着队列优先级别的降低，时间片增大
当第一级队列为空时，在第二级队列调度，以此类推
各级队列按照时间片轮转方式 进行调度
当一个新创建进程就绪后，进入第一级队列
进程用完时间片而放弃CPU，进入下一级就绪队列
由于阻塞而放弃CPU的进程进入相应的等待队列，一旦等待的事件发生，该进程回到原来一级就绪队列（？）
</code></pre><hr>
<pre><code>若允许抢占
    当有一个优先级更高的进程就绪时，可以抢占CPU
    被抢占的进程回到原来一级就绪队列末尾（或者？）
</code></pre><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p><img src="img/opSystem/forth/1.jpg" alt=""></p>
<h3 id="多处理器调度算法设计"><a href="#多处理器调度算法设计" class="headerlink" title="多处理器调度算法设计"></a>多处理器调度算法设计</h3><pre><code>不仅要决定选择哪一个进程执行
    还需要决定在哪一个CPU上执行
要考虑进程在多个CPU之间迁移时的开销
    高速缓存失效、TLB失效
    尽可能使进程总是在同一个CPU上执行
        如果每个进程可以调度到所有CPU上，假如进程上次在CPU1上执行，本次被调度到CPU2，则会增加高速缓存失效、TLB失效；如果每个进程尽量调度到指定的CPU上，各种失效就会减少
考虑负载均衡问题
</code></pre><h2 id="典型操作系统的调度算法"><a href="#典型操作系统的调度算法" class="headerlink" title="典型操作系统的调度算法"></a>典型操作系统的调度算法</h2><pre><code>UNIX 动态优先数法
5.3BSD 多级反馈队列法
Linux 抢占式调度
Windows 基于优先级的抢占式多任务调度
Solaris 综合调度算法
</code></pre><h3 id="LINUX调度算法的发展历史"><a href="#LINUX调度算法的发展历史" class="headerlink" title="LINUX调度算法的发展历史"></a>LINUX调度算法的发展历史</h3><pre><code>Linux2.4简单的基于优先级调度

Linux2.6O(1)调度器

Linux2.6 SD调度器补丁

Linux2.6RSDL调度器补丁

Linux2.6CFS调度器：完全公平调度算法
</code></pre><h3 id="Windows线程调度"><a href="#Windows线程调度" class="headerlink" title="Windows线程调度"></a>Windows线程调度</h3><pre><code>调度单位是线程
采用基于动态优先级的、抢占式调度，结合时间配额的调整
</code></pre><hr>
<pre><code>就绪线程按优先级进入相应队列
系统总是选择优先级最高的就绪线程运行
同一优先级的各线程按时间片轮转进行调度
多CPU系统中允许多个线程并行运行
</code></pre><hr>
<pre><code>引发线程调度的条件：
    一个线程的优先级改变了
    一个线程改变了它的亲和(Affinity)处理机集合

    线程正常终止 或 由于某种错误而终止
    新线程创建 或 一个等待线程变成就绪
    当一个线程从运行态进入阻塞态
    当一个线程从运行态变为就绪态
</code></pre><hr>
<pre><code>Windows使用32个线程优先级，分成三类
零页线程：0级
    用于对系统中空闲物理页面清零
实时优先级线程不改变其优先级
可变优先级线程：其优先级可以在一定范围内升高或降    低 基本优先级 和 当前优先级
</code></pre><h3 id="线程的时间配额"><a href="#线程的时间配额" class="headerlink" title="线程的时间配额"></a>线程的时间配额</h3><pre><code>时间配额不是一个时间长度值，而一个称为配额单位(quantum unit)的整数
一个线程用完了自己的时间配额时，如果没有其他相同优先级的线程，Windows将重新给该线程分配一个新的时间配额，让它继续运行
</code></pre><hr>
<pre><code>时间配额的一种特殊作用
    假设用户首先启动了一个运行时间很长的电子表格计算程序，然后切换到一个游戏程序(需要复杂图形计算并显示，CPU型)
    如果前台的游戏进程提高它的优先级，则后台的电子表格计算进程就几乎得不到CPU时间了
    但增加游戏进程的时间配额，则不会停止执行电子表格计算，只是给游戏进程的CPU时间多一些而已
</code></pre><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><pre><code>主动切换
抢占
时间配额用完
</code></pre><h4 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h4><pre><code>当线程被抢占时，它被放回相应优先级的就绪队列的队首
    处于实时优先级的线程在被抢占时，时间配额被重置为一个完整的时间配额
    处于可变优先级的线程在被抢占时，时间配额不变，重新得到CPU后将运行剩余的时间配额
</code></pre><h4 id="时间配额用完"><a href="#时间配额用完" class="headerlink" title="时间配额用完"></a>时间配额用完</h4><pre><code>假设线程A的时间配额用完
    A的优先级没有降低
    如果队列中有其他就绪线程，选择下一个线程执行，A回到原来就绪队列末尾
    如果队列中没有其他就绪线程，系统给线程A分配一个新的时间配额，让它继续运行

    A的优先级降低了，Windows 将选择一个更高优先级的线程
</code></pre><h3 id="线程优先级与时间配额调整"><a href="#线程优先级与时间配额调整" class="headerlink" title="线程优先级与时间配额调整"></a>线程优先级与时间配额调整</h3><pre><code>Windows的调度策略
    如何体现对某类线程具有倾向性？
    如何解决由于调度策略中潜在的不公平性而带来饥饿现象？
    如何改善系统吞吐量、响应时间等整体特征？

解决方案
    提升线程的优先级
    给线程分配一个很大的时间配额
</code></pre><h4 id="线程优先级提升"><a href="#线程优先级提升" class="headerlink" title="线程优先级提升"></a>线程优先级提升</h4><pre><code>下列5种情况，Windows 会提升线程的当前优先级：
    I/O操作完成
    信号量或事件等待结束
    前台进程中的线程完成一个等待操作
    由于窗口活动而唤醒窗口线程
    线程处于就绪态超过了一定的时间还没有运行
        —— “饥饿”现象
针对可变优先级范围内(1至15)的线程优先级
</code></pre><hr>
<p>I/O操作完成后的线程优先级提升</p>
<pre><code>在完成I/O操作后，Windows 将临时提升等待该操作线程的优先级，保证该线程能更快上CPU运行进行数据处理
优先级的提升值由设备驱动程序决定，提升建议值保存在系统文件“Wdm.h”或“Ntddk.h”中
优先级的提升幅度与对I/O请求的响应时间要求是一致的，响应时间要求越高，优先级提升幅度越大
设备驱动程序在完成I/O请求时通过内核函数IoCompleteRequest来指定优先级提升的幅度
为避免不公平，在I/O操作完成唤醒等待线程时会将该线程的时间配额减1
</code></pre><hr>
<p>“饥饿”线程优先级提升 </p>
<pre><code>系统线程“平衡集管理器(balance set manager)” 每秒钟扫描一次就绪队列，发现是否存在等待时间超过300个时钟中断间隔的线程
平衡集管理器将这些线程的优先级提升到15，并分配给它一个长度为正常值4倍的时间配额
当被提升的线程用完它的时间配额后，立即衰减到它原来的基本优先级
</code></pre><h2 id="重点-2"><a href="#重点-2" class="headerlink" title="重点"></a>重点</h2><h3 id="本讲重点"><a href="#本讲重点" class="headerlink" title="本讲重点"></a>本讲重点</h3><pre><code>掌握处理器调度的相关概念
    调度时机、进程切换
    调度标准：吞吐量、周转时间、响应时间
    优先级/优先数、抢占/非抢占、I/O型与CPU型
掌握主要的调度算法
    先来先服务、短作业优先、最高相应比优先
    时间片轮转、 最高优先级
    多级反馈队列
了解Windows、多处理器调度的基本思想
</code></pre><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><pre><code>重点阅读教材
第2章相关内容：2.4
第11章相关内容：11.4.3中的调度部分

重点概念
调度时机 进程切换 抢占/非抢占 时间片
优先级反转 饥饿 优先级与优先数 优先级提升
先来先服务 短作业优先 最高相应比优先
时间片轮转 最高优先级 多级队列反馈
吞吐量 周转时间 响应时间
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/21/计算机组成原理/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/21/计算机组成原理/" itemprop="url">
                  Untitled
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-21T15:05:58+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机基本结构"><a href="#计算机基本结构" class="headerlink" title="计算机基本结构"></a>计算机基本结构</h1><p>ENIAC第一台通用电子计算机，10进制<br>关于EDVAC的报告草案所描述的计算机结构被简称为“冯●诺依曼结构”，2进制<br>UNIVAC开启了商用计算机的时代<br>EDSAC第一台实用的存储程序式计算机</p>
<h2 id="冯诺依曼结构的要点"><a href="#冯诺依曼结构的要点" class="headerlink" title="冯诺依曼结构的要点"></a>冯诺依曼结构的要点</h2><p>运算器CA<br>控制器CC<br>存储器M<br>输入  I<br>输出  O</p>
<h2 id="计算机的运行指令"><a href="#计算机的运行指令" class="headerlink" title="计算机的运行指令"></a>计算机的运行指令</h2><p>取指：控制器，主存<br>译码：主存，运算器<br>执行：运算器，控制器<br>回写：控制器  </p>
<h2 id="计算机结构的简化模型"><a href="#计算机结构的简化模型" class="headerlink" title="计算机结构的简化模型"></a>计算机结构的简化模型</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>按字节编址<br>MAR：用于存放CPU正在读或写的存储单元的<strong>地址</strong><br>MDR：用于存放CPU正在读出或即将写入存储单元的<strong>数据</strong>  </p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>指令寄存器<br>程序计数器<br>存储器地址寄存器<br>存储器数据寄存器<br>指令译码部件：对MAR中的指令进行译码<br>控制电路</p>
<h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p>核心是ALU：用于完成算术运算和逻辑运算<br>通用寄存器  </p>
<h3 id="内部总线"><a href="#内部总线" class="headerlink" title="内部总线"></a>内部总线</h3><p>用于在CPU内部各个部件之间传递数据</p>
<h2 id="执行指令的过程"><a href="#执行指令的过程" class="headerlink" title="执行指令的过程"></a>执行指令的过程</h2><p>ADD R0,[6]  </p>
<h3 id="取指"><a href="#取指" class="headerlink" title="取指"></a>取指</h3><p>存储器将指令的地址送往存储器<br>存储器按给定的地址读出指定内容，送回控制器</p>
<h3 id="译码"><a href="#译码" class="headerlink" title="译码"></a>译码</h3><p>控制器分析指令的操作性质<br>控制器向有关部件发出指令所需要的控制信号</p>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>控制器从通用寄存器或存储器取出操作数<br>控制器命令运算器对操作数进行指令规定的运算  </p>
<h3 id="回写"><a href="#回写" class="headerlink" title="回写"></a>回写</h3><p>将计算结果写入存储器或通用寄存器</p>
<h2 id="计算机的输入和输出"><a href="#计算机的输入和输出" class="headerlink" title="计算机的输入和输出"></a>计算机的输入和输出</h2><p>输入-&gt;存储器&lt;-&gt;运算器<br>存储器-&gt;输出<br>存储器&lt;-&gt;控制器</p>
<h3 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h3><h1 id="指令系统体系结构"><a href="#指令系统体系结构" class="headerlink" title="指令系统体系结构"></a>指令系统体系结构</h1><h2 id="一个简单的计算机指令系统"><a href="#一个简单的计算机指令系统" class="headerlink" title="一个简单的计算机指令系统"></a>一个简单的计算机指令系统</h2><h3 id="指令描述"><a href="#指令描述" class="headerlink" title="指令描述"></a>指令描述</h3><h4 id="ADD-R，M"><a href="#ADD-R，M" class="headerlink" title="ADD R，M"></a>ADD R，M</h4><p>将R的内容与M中内容相加后存入R</p>
<h4 id="LOAD-R，M"><a href="#LOAD-R，M" class="headerlink" title="LOAD R，M"></a>LOAD R，M</h4><p>将M中的内容装入R</p>
<h4 id="STORE-M-R"><a href="#STORE-M-R" class="headerlink" title="STORE M,R"></a>STORE M,R</h4><p>将R中的内容存入M中</p>
<h4 id="JMP-L"><a href="#JMP-L" class="headerlink" title="JMP L"></a>JMP L</h4><p>无条件转向L处</p>
<h3 id="指令的格式"><a href="#指令的格式" class="headerlink" title="指令的格式"></a>指令的格式</h3><p>每条指令等长，均为2个字节<br>第一个字节的高4位是操作码：LOAD 0000；ADD 0001；STORE：0010；JMP：0011<br>第一个字节的低4位是寄存器好：R0-R3：0000-0011<br>第二个字节是存储单元地址</p>
<h2 id="x86体系结构"><a href="#x86体系结构" class="headerlink" title="x86体系结构"></a>x86体系结构</h2><h3 id="8086"><a href="#8086" class="headerlink" title="8086"></a>8086</h3><p>寄存器：16位<br>对外有16根数据线和20根地址线<br>物理地址采取“段加偏移”的方式</p>
<h3 id="8088"><a href="#8088" class="headerlink" title="8088"></a>8088</h3><h3 id="80286"><a href="#80286" class="headerlink" title="80286"></a>80286</h3><p>24位地址总线<br>实模式又称为实地址模式</p>
<h3 id="80386"><a href="#80386" class="headerlink" title="80386"></a>80386</h3><p>第一款32位微处理器<br>提供32位的通用寄存器<br>改进了保护模式<br>引入虚存的概念<br>实模式——保护模式——切换——虚拟8086模式</p>
<h3 id="体系的演变"><a href="#体系的演变" class="headerlink" title="体系的演变"></a>体系的演变</h3><p>寄存器由8位——16位——32位——64位<br>AX Accumulator 存放乘除等指令的操作数<br>BX Base 存放存储单元的偏移地址<br>CX Count 存放计数值<br>DX Data  乘法运算产生的部分积    除法运算的部分被除数<br><strong>指针寄存器</strong>.<br>SP stack pointer 堆栈指针寄存器<br>BP (stack)base pointer (堆栈)基址指针寄存器<br>SI source index 源变址寄存器<br>DI destination index 目的变址寄存器<br><strong>标志寄存器</strong><br>标志位<br>◦ FLAGS寄存器中包含若干标志位<br>◦ 标志位分为两大类：状态标志和控制标志<br>状态标志反映CPU的工作状态<br>例如：<br>◦ 执行加法运算时是否产生进位<br>◦ 运算结果是否为零<br>控制标志对CPU的运行起特定控制作用<br>例如：<br>◦ 以单步方式还是连续方式运行<br>◦ 是否允许响应外部中断请求<br><strong>段寄存器</strong><br>CS 代码段寄存器（Code Segment）<br>DS 数据段寄存器（Data Segment）<br>ES 附加段寄存器（Extra Segment）<br>SS 堆栈段寄存器（Stack Segment）  </p>
<h4 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h4><p>使用段+偏移地址的方式 </p>
<h2 id="x86指令"><a href="#x86指令" class="headerlink" title="x86指令"></a>x86指令</h2><h3 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h3><p>MOV DST RSC<br>PUSH<br>POP  </p>
<h3 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a>算数运算指令</h3><h4 id="加法类指令"><a href="#加法类指令" class="headerlink" title="加法类指令"></a>加法类指令</h4><p>ADD DST， SRC<br>ADC DST， SRC<br>INC PTR 加一  </p>
<h4 id="减法类指令"><a href="#减法类指令" class="headerlink" title="减法类指令"></a>减法类指令</h4><p>SUB指令（减）<br>格式：SUB DST, SRC<br>操作：DST←DST-SRC<br>SBB指令（带借位的减）<br>格式：SBB DST, SRC<br>操作：DST←DST-SRC-CF<br>DEC指令（减1）<br>格式：DEC OPR<br>操作：OPR←OPR-1<br>CMP指令（比较）<br>格式：CMP DST, SRC<br>操作：DST - SRC<br>说明：减法操作，但不回写结果，仅影响标志位</p>
<h3 id="逻辑运算和移位指令"><a href="#逻辑运算和移位指令" class="headerlink" title="逻辑运算和移位指令"></a>逻辑运算和移位指令</h3><p>NOT指令（逻辑非）<br>格式：NOT OPR<br>操作：OPR按位求反，送回OPR<br>AND指令（逻辑与）<br>格式：AND DST, SRC<br>操作：将DST和SRC的内容按位进行“与”操作，结果<br>送到DST中  </p>
<p>SHL指令（左移）<br>格式：SHL DST, CNT<br>操作：<br>◦ 将DST的内容按图中方式移动<br>◦ 移动位数由CNT指定<br>说明：<br>◦ DST可以是寄存器或存储器操作数<br>◦ CNT可以是立即数1或CL寄存器<br>◦ 相当于无符号数乘以2n的运算  </p>
<h3 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h3><p>作用<br>◦ 改变指令执行顺序<br>说明<br>◦ 根据是否有判断条件，分为无条件转移指令和条件转移指令两大类<br>◦ 根据转移目标地址的提供方式，可分为直接转移和间接转移两种方式   </p>
<hr>
<p>短转移：JMP SHORT LABEL<br>◦ 操作：IP←IP+8位的位移量（-128~127Byte）<br>近转移：JMP NEAR PTR LABEL<br>◦ 操作：IP←IP+16位的位移量（±32KByte）<br>远转移：JMP FAR PTR LABEL<br>◦ 操作：IP←LABEL的偏移地址；CS ←LABEL的段基值  </p>
<hr>
<p>转移目标地址在寄存器中<br>◦ JMP AX ; AX → IP<br>◦ JMP EAX ; EAX → EIP<br>转移目标地址在存储器中<br>◦ JMP [SI] ; [SI] → IP<br>◦ JMP FAR PTR[SI] ; [SI] → IP, [SI+2] → CS  </p>
<hr>
<p>操作<br>◦ 根据当前的状态标志位决定是否发生转移<br>说明<br>一般在影响标志位的算术或逻辑运算指令之后<br>◦ 8086中，所有的条件转移都是短转移<br>• 同一代码段内，-128~127字节范围内<br>◦ 从80386起，条件转移指令可以使用32位的长位移量<br>• 同一代码段内，±2G字节范围  </p>
<h3 id="处理器控制指令"><a href="#处理器控制指令" class="headerlink" title="处理器控制指令"></a>处理器控制指令</h3><p>作用<br>控制CPU的功能<br>对标志位进行操作  </p>
<h2 id="复杂的X86指令"><a href="#复杂的X86指令" class="headerlink" title="复杂的X86指令"></a>复杂的X86指令</h2><h3 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h3><p>作用<br>◦ 对存储器中的数据串进行每次一个元素的操作<br>◦ 串的基本单位是字节或字（即“一个元素”）<br>◦ 串长度可达64KB<br>分类<br>◦ 共5条串操作指令<br>◦ 另有3种重复前缀，与串操作指令配合使用  </p>
<h4 id="串传送指令说明"><a href="#串传送指令说明" class="headerlink" title="串传送指令说明"></a>串传送指令说明</h4><p>MOVSB指令（字节串传送）<br>格式：MOVSB<br>操作：在存储器中将指定位置的一个字节单元传送到另<br>一个指定的位置  </p>
<p>REP前缀（无条件重复）<br>格式：REP 串操作指令<br>操作：当CX≠0时，重复执行串操作指令  </p>
<p>隐含操作数<br>. 源串地址为DS:SI，目的串地址为ES:DI<br>. 串的长度在CX寄存器中  </p>
<p>处理完一个串元素后的操作（硬件自动完成）<br>① 修改SI和DI，指向下一个串元素<br>② 若使用重复前缀，则CX ←CX-1  </p>
<p>设置DF=0<br>◦ 从“源串”的低地址开始传送<br>◦ 传送过程中，SI和DI自动增量修改  </p>
<p>设置DF=1<br>◦ 从“源串”的高地址开始传送<br>◦ 传送过程中，SI和DI自动减量修改  </p>
<p>STD 把方向标志DF置1<br>CLD 把方向标志DF清0  </p>
<h3 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h3><p>LOOPNE/LOOPNZ指令（不为零/不相等时循环）</p>
<h3 id="查表指令XLAT"><a href="#查表指令XLAT" class="headerlink" title="查表指令XLAT"></a>查表指令XLAT</h3><h3 id="十进制调整指令"><a href="#十进制调整指令" class="headerlink" title="十进制调整指令"></a>十进制调整指令</h3><h2 id="MIPS体系结构"><a href="#MIPS体系结构" class="headerlink" title="MIPS体系结构"></a>MIPS体系结构</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>固定的指令长度<br>简单的寻址模式<br>指令数量少，指令功能简单<br>只有load和store可以访问存储器  </p>
<h3 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h3><p>add a，b ，c</p>
<h2 id="mips指令简介"><a href="#mips指令简介" class="headerlink" title="mips指令简介"></a>mips指令简介</h2><p>R型，I型，J型</p>
<h1 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h1><h2 id="算术运算和逻辑运算"><a href="#算术运算和逻辑运算" class="headerlink" title="算术运算和逻辑运算"></a>算术运算和逻辑运算</h2><p>R型<br>◦ add rd,rs,rt # R[rd]=R[rs]+R[rt] (1)<br>◦ addu rd,rs,rt # R[rd]=R[rs]+R[rt]<br>◦ sub rd,rs,rt # R[rd]=R[rs]-R[rt] (1)<br>◦ subu rd,rs,rt # R[rd]=R[rs]-R[rt]<br>I型<br>◦ addi rt,rs,imm # R[rt]=R[rs]+SignExtImm  (1,2)<br>◦ addiu rt,rs,imm # R[rt]=R[rs]+SignExtImm(2)  </p>
<h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><p>R型<br>◦ and rd,rs,rt # R[rd]=R[rs]&amp;R[rt]<br>◦ or rd,rs,rt # R[rd]=R[rs]|R[rt]<br>◦ nor rd,rs,rt # R[rd]=~(R[rs]|R[rt])<br>I型<br>◦ andi rt,rs,imm # R[rt]=R[rs]&amp;ZeroExtImm(3)<br>◦ ori rt,rs,imm # R[rt]=R[rs]|ZeroExtImm(3)  </p>
<h2 id="门电路的基本原理"><a href="#门电路的基本原理" class="headerlink" title="门电路的基本原理"></a>门电路的基本原理</h2><h3 id="晶体管"><a href="#晶体管" class="headerlink" title="晶体管"></a>晶体管</h3><p>现代集成电路中通常使用MOS晶体管<br>. Metal-Oxide-Semiconductor：金属-氧化物-半导体<br>CMOS集成电路（Complementary MOS）<br>. 由PMOS和NMOS共同构成的互补型MOS集成电路<br>Gate，Source，Drain</p>
<h3 id="非门"><a href="#非门" class="headerlink" title="非门"></a>非门</h3><h3 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h3><h3 id="与非门"><a href="#与非门" class="headerlink" title="与非门"></a>与非门</h3><h3 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h3><h3 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h3><h2 id="寄存器的基本原理"><a href="#寄存器的基本原理" class="headerlink" title="寄存器的基本原理"></a>寄存器的基本原理</h2><h3 id="D触发器"><a href="#D触发器" class="headerlink" title="D触发器"></a>D触发器</h3><p>D触发器<br>◦ 具有存储信息能力的基本单元<br>◦ 由若干逻辑门构成，有多种实现方式<br>◦ 主要有一个数据输入、一个数据输出和一个时钟输入<br>◦ 在时钟clock的上升沿（0→1），采样输入D的值，传送到输出Q，其余<br>时间输出Q的值不变  </p>
<h3 id="寄存器的构成"><a href="#寄存器的构成" class="headerlink" title="寄存器的构成"></a>寄存器的构成</h3><p>32个D触发器</p>
<h2 id="逻辑运算的实现"><a href="#逻辑运算的实现" class="headerlink" title="逻辑运算的实现"></a>逻辑运算的实现</h2><p>多选器：产生一个32位的输出</p>
<h3 id="与运算的实现"><a href="#与运算的实现" class="headerlink" title="与运算的实现"></a>与运算的实现</h3><p>并联32个与门</p>
<h3 id="或运算的实现"><a href="#或运算的实现" class="headerlink" title="或运算的实现"></a>或运算的实现</h3><p>并联32个或门</p>
<h2 id="加法和减法的运算"><a href="#加法和减法的运算" class="headerlink" title="加法和减法的运算"></a>加法和减法的运算</h2><h3 id="半加器"><a href="#半加器" class="headerlink" title="半加器"></a>半加器</h3><p>半加器的功能是将两个一位二进制数相加<br>◦ 输入端口A、B<br>◦ 输出端口S（和）、C（进位）</p>
<h3 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h3><p>全加器由两个半加器构成<br>◦ 输入端口A、B、Cin（进位输入）<br>◦ 输出端口S（和）、Cout（进位输出）</p>
<h3 id="加法运算的实现示例"><a href="#加法运算的实现示例" class="headerlink" title="加法运算的实现示例"></a>加法运算的实现示例</h3><p>32个全加器并联</p>
<h3 id="注意区分“进位”和“溢出”"><a href="#注意区分“进位”和“溢出”" class="headerlink" title="注意区分“进位”和“溢出”"></a>注意区分“进位”和“溢出”</h3><p>有“溢出”时，不一定有“进位”<br> 有“进位”时，不一定有“溢出”</p>
<h3 id="对“溢出”的处理方式：MIPS"><a href="#对“溢出”的处理方式：MIPS" class="headerlink" title="对“溢出”的处理方式：MIPS"></a>对“溢出”的处理方式：MIPS</h3><p>提供两类不同的指令分别处理<br>（1）将操作数看做有符号数，发生“溢出”时产生异常<br>◦ add rd,rs,rt # R[rd]=R[rs]+R[rt]<br>◦ addi rt,rs,imm # R[rt]=R[rs]+SignExtImm<br>（2）将操作数看做无符号数，不处理“溢出”<br>◦ addu rd,rs,rt # R[rd]=R[rs]+R[rt]<br>◦ addiu rt,rs,imm # R[rt]=R[rs]+SignExtImm </p>
<h3 id="对“溢出”的处理方式：x86"><a href="#对“溢出”的处理方式：x86" class="headerlink" title="对“溢出”的处理方式：x86"></a>对“溢出”的处理方式：x86</h3><p>溢出标志OF（Overflow Flag）<br>◦ 如果把操作数看做有符号数，运算结果是否发生溢出<br>◦ 若发生溢出，则自动设置OF=1；否则，OF=0  </p>
<h3 id="减法运算"><a href="#减法运算" class="headerlink" title="减法运算"></a>减法运算</h3><p>减法运算均可转换为加法运算<br>补码表示的二进制数的相反数<br>在加法器的基础上实现减法器</p>
<h2 id="加法器的优化"><a href="#加法器的优化" class="headerlink" title="加法器的优化"></a>加法器的优化</h2><h3 id="行波进位加法器2t-1"><a href="#行波进位加法器2t-1" class="headerlink" title="行波进位加法器2t+1"></a>行波进位加法器2t+1</h3><p>结构特点<br>◦ 低位全加器的Cout连接到高一位全加器Cin<br>优点<br>◦ 电路布局简单，设计方便<br>缺点<br>◦ 高位的运算必须等待低位的运算完成，延迟时间长  </p>
<h3 id="加法器的优化思路"><a href="#加法器的优化思路" class="headerlink" title="加法器的优化思路"></a>加法器的优化思路</h3><p>主要问题<br>. 高位的运算必须等待低位的“进位输出信号”<br>优化思路<br>. 能否提前计算出“进位输出信号” ？</p>
<h4 id="完全的超前进位"><a href="#完全的超前进位" class="headerlink" title="完全的超前进位"></a>完全的超前进位</h4><p>优点：计算Ci+1的延迟时<br>间固定为三级门延迟，与<br>加法器的位数无关<br>缺点：如果进一步拓<br>宽加法器的位数，则<br>电路变得非常复杂<br>总延迟时间为4级门延迟 </p>
<h3 id="32-bit加法器的实现"><a href="#32-bit加法器的实现" class="headerlink" title="32-bit加法器的实现"></a>32-bit加法器的实现</h3><p>通常的实现方法<br>◦ 采用多个小规模的超前进位加法器拼接而成<br>◦ 例如，用4个8-bit的超前进位加法器连接成32-bit加法器  </p>
<h1 id="乘法器和除法器"><a href="#乘法器和除法器" class="headerlink" title="乘法器和除法器"></a>乘法器和除法器</h1><h2 id="乘法的运算过程"><a href="#乘法的运算过程" class="headerlink" title="乘法的运算过程"></a>乘法的运算过程</h2><p>二进制的乘法运算：要么为0，要么为被乘数本身<br>改造成适合硬件的运算方式</p>
<h2 id="乘法器的实现"><a href="#乘法器的实现" class="headerlink" title="乘法器的实现"></a>乘法器的实现</h2><h3 id="乘法器的实现结构"><a href="#乘法器的实现结构" class="headerlink" title="乘法器的实现结构"></a>乘法器的实现结构</h3><p><strong>核心是使用加法器实现</strong><br>被乘数寄存器：符号扩展，在乘的过程中不断左移<br>乘积寄存器<br>乘数寄存器：在乘的过程中不断右移<br>控制逻辑：判断循环是否结束了</p>
<h3 id="N位乘法器的工作流程图"><a href="#N位乘法器的工作流程图" class="headerlink" title="N位乘法器的工作流程图"></a>N位乘法器的工作流程图</h3><p>开始：<br>1、检查乘数寄存器的最低位<br>1a、将被乘数寄存器和沉积寄存器的内容相加，结果放入乘积寄存器（乘法寄存器的最低位为1）<br>2、将被乘数寄存器左移一位<br>3、将乘数寄存器右移一位<br>4、是否已到第N次循环</p>
<h2 id="乘法器的优化"><a href="#乘法器的优化" class="headerlink" title="乘法器的优化"></a>乘法器的优化</h2><h3 id="加法移位并行"><a href="#加法移位并行" class="headerlink" title="加法移位并行"></a>加法移位并行</h3><p>时钟上升沿到来时，寄存器根据输入改变其内容<br>优化后性能提升了三倍，1a，2，3可以并行<br>可以取消分支结构  </p>
<h2 id="减少不必要的硬件资源"><a href="#减少不必要的硬件资源" class="headerlink" title="减少不必要的硬件资源"></a>减少不必要的硬件资源</h2><p>被乘数寄存器8位宽带左移，但其中有效数字始终只有4位<br>乘数寄存器4位宽带右移，但其中有效数字每周期减少一位（可以放在乘积寄存器的低4位）<br>乘积寄存器8位宽，但初始时有效数字只有4位，每个周期增加一位（只使用高四位，数据逐步右移）<br>加法器8位宽，但参与运算的有效数字实际只有4位  </p>
<h2 id="除法的运算过程"><a href="#除法的运算过程" class="headerlink" title="除法的运算过程"></a>除法的运算过程</h2><p>被除数寄存器（余数寄存器）<br>除数寄存器<br>商寄存器  </p>
<h2 id="除法器的实现"><a href="#除法器的实现" class="headerlink" title="除法器的实现"></a>除法器的实现</h2><p>1、余数=余数-除数<br>2、检查余数<br>2a、商左移，新的最优位设置为1（余数大于等于0）<br>2b、回退第一步的操作，商左移，新的最右位设为0 （余数小于0）<br>3、除数右移一位<br>4、判断是否为第33轮循环   </p>
<h3 id="如果除数为负数，那么商和余数怎么计算"><a href="#如果除数为负数，那么商和余数怎么计算" class="headerlink" title="如果除数为负数，那么商和余数怎么计算"></a>如果除数为负数，那么商和余数怎么计算</h3><h2 id="除法器的优化"><a href="#除法器的优化" class="headerlink" title="除法器的优化"></a>除法器的优化</h2><p>除数寄存器只使用了一半<br>商寄存器初时是空的<br>余数寄存器初始是满的，但是不断右移<br>需要64位</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>除数寄存器缩小一半<br>取消商寄存器<br>32bitALU<br>余数寄存器只有高32bit参与加减法运算，余数寄存器需要支持左移和右移<br>商从右端逐位移入余数寄存器<br>运算结束时，商占据余数寄存器的低32bit  </p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h1 id="单周期处理器"><a href="#单周期处理器" class="headerlink" title="单周期处理器"></a>单周期处理器</h1><h2 id="处理器的设计步骤"><a href="#处理器的设计步骤" class="headerlink" title="处理器的设计步骤"></a>处理器的设计步骤</h2><p>分析指令系统，得出对数据通路的需求<br>为数据通路选择合适的组件<br>连接组件建立数据通路<br>分析每条指令的实现，以确定控制信号<br>集成控制信号，形成完整的控制逻辑</p>
<h3 id="MIPS指令系统的简化版本"><a href="#MIPS指令系统的简化版本" class="headerlink" title="MIPS指令系统的简化版本"></a>MIPS指令系统的简化版本</h3><p><strong>无符号的加法和减法</strong>  </p>
<p><strong>立即数的逻辑或</strong>   </p>
<p><strong>装载和存储一个字</strong>  </p>
<p><strong>条件分支</strong>  </p>
<h3 id="指令的含义"><a href="#指令的含义" class="headerlink" title="指令的含义"></a>指令的含义</h3><p>R型指令{op,rs,rt,rd,shamt,funct}<br>I型指令{op,rs,rt,Imm16}</p>
<hr>
<p><strong>需求</strong><br>存放指令的存储器，可读地址数据均为32位<br>存放指令地址的32寄存器</p>
<hr>
<p><strong>指令的操作</strong><br>ADDU:R[rd] &lt;- R[rs]+R[rt]; PC &lt;- PC + 4<br>SUBU :R[rd] &lt;- R[rs]-R[rt]; PC &lt;- PC + 4<br>ORI: R[rt]&lt;-R[rs] | zero_ext(Imm16);PC &lt;- PC + 4<br>LOAD: R[rt]&lt;-MEM[R[rs] + sign_ext(Imm16)];PC &lt;- PC + 4<br>STORE:MEM[R[rs] + sign_ext(Imm16)]&lt;-R[rt];PC &lt;- PC + 4<br>BEQ: if(R[rs]==R[rt])<br>        then PC &lt;- PC + 4   + (sign_ext(Imm16)||00)<br>        else PC &lt;- PC + 4  </p>
<h3 id="指令系统的需求"><a href="#指令系统的需求" class="headerlink" title="指令系统的需求"></a>指令系统的需求</h3><p>算术逻辑单元<br>立即数扩展部件<br>程序计数器<br>寄存器堆：两读一写<br>存储器：一个只读的指令存储器，一个可读写的数据存储器</p>
<h4 id="寄存器堆"><a href="#寄存器堆" class="headerlink" title="寄存器堆"></a>寄存器堆</h4><p>内部构成：32个32位的寄存器<br>数据接口信号：busA,busB：两组32位数据输出,BusW：一组32位数据输入<br>读写控制：都是5位，Ra（busA），Rb（busA），Rw（busW）:时钟上升沿，写入</p>
<h2 id="数据通路的建立"><a href="#数据通路的建立" class="headerlink" title="数据通路的建立"></a>数据通路的建立</h2><h3 id="建立数据通路的方法"><a href="#建立数据通路的方法" class="headerlink" title="建立数据通路的方法"></a>建立数据通路的方法</h3><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>根据指令需求，连接组件，建立数据通路</p>
<h4 id="指令的需求"><a href="#指令的需求" class="headerlink" title="指令的需求"></a>指令的需求</h4><p>所有指令的共同需求：取指令：顺序发生时，发生分支时    </p>
<pre><code>不同指令的不同需求  
    加法和减法指令的需求：
        寄存器堆的读写
        ALU控制信号
    逻辑运算指令的需求
        多选器选择执行加法还是逻辑运算
        ALU控制端增加一个多选器，连接一个零扩展部件
    访存指令的需求
        零扩展部件改造成多功能扩展部件
        增加一个数据存储器，根据数据地址取得数据
        增加一个多选器连接到寄存器
    STORE
        直接将busB连接数据存储器的输入端
        数据存储器连接一个控制信号
</code></pre><h2 id="运算指令的控制信号"><a href="#运算指令的控制信号" class="headerlink" title="运算指令的控制信号"></a>运算指令的控制信号</h2><p>运算指令，访存指令，分支指令<br>R型指令，I型指令，J型指令</p>
<h3 id="加法指令的操作步骤"><a href="#加法指令的操作步骤" class="headerlink" title="加法指令的操作步骤"></a>加法指令的操作步骤</h3><p>取指：所有指令都有此操作<br>指令指定的操作<br>计算下一条指令的地址：所有指令都有此操作   </p>
<h2 id="访存指令的控制信号"><a href="#访存指令的控制信号" class="headerlink" title="访存指令的控制信号"></a>访存指令的控制信号</h2><p>运算不能单独访存</p>
<h3 id="lw指令"><a href="#lw指令" class="headerlink" title="lw指令"></a>lw指令</h3><p>取指：所有指令都有此操作<br>指令指定的操作<br>计算下一条指令的地址：所有指令都有此操作   </p>
<h2 id="分支指令的控制信号"><a href="#分支指令的控制信号" class="headerlink" title="分支指令的控制信号"></a>分支指令的控制信号</h2><h3 id="分支指令的示例"><a href="#分支指令的示例" class="headerlink" title="分支指令的示例"></a>分支指令的示例</h3><p>beq $s3,$s4,True<br>sub $s0,$s1,$s2<br>j     Next<br>True:add $s0,$s1,$s2<br>Next:…</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>取指：所有指令都有此操作<br>判断转移条件是否成立<br>计算下一条指令的地址：所有指令都有此操作   </p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>IFU需要一个多选器<br>一个与门  </p>
<h3 id="分支目标地址生成-5"><a href="#分支目标地址生成-5" class="headerlink" title="分支目标地址生成 ###5"></a>分支目标地址生成 ###5</h3><p>PC = PC+4 + SignExt[imm16]*4</p>
<h2 id="控制信号的集成"><a href="#控制信号的集成" class="headerlink" title="控制信号的集成"></a>控制信号的集成</h2><pre><code>func            100000        100010        /
opcide(op)        000000        000000        001101        100011        101011        000100
                add            sub            ori            lw            sw            beq
RegDst            1            1            0            0            x            x
ALUSrc            0            0            1            1            1            0
MemtoReg        0            0            0            1            x            x
RegWr            1            1            1            1            0            0
MemWr            0            0            0            0            1            0
nPc_sel            0            0            0            0            0            1
ExtOp            x            x            0            1            1            x
ALUctr&lt;1:0&gt;    00            01            10            00            00            01
</code></pre><h1 id="流水线处理器"><a href="#流水线处理器" class="headerlink" title="流水线处理器"></a>流水线处理器</h1><h2 id="流水线的基本原理"><a href="#流水线的基本原理" class="headerlink" title="流水线的基本原理"></a>流水线的基本原理</h2><p>流水线保持填满的状态，性能大大提升<br>本质上是提升了指令的吞吐率</p>
<h3 id="单周期处理器-1"><a href="#单周期处理器-1" class="headerlink" title="单周期处理器"></a>单周期处理器</h3><p>取指<br>译码<br>执行<br>访存<br>回写<br>所有的信号都必须保持稳定的<br>每个部件都是相互独立的</p>
<h3 id="添加流水线寄存器"><a href="#添加流水线寄存器" class="headerlink" title="添加流水线寄存器"></a>添加流水线寄存器</h3><p>每个阶段的结果放到寄存器里面<br>寄存器也有延迟  </p>
<h2 id="流水线的优化"><a href="#流水线的优化" class="headerlink" title="流水线的优化"></a>流水线的优化</h2><p>流水线的平衡性<br>本质上是流水线每一级的颗粒大小尽量相等</p>
<h3 id="超级流水线"><a href="#超级流水线" class="headerlink" title="超级流水线"></a>超级流水线</h3><p>增加流水线的深度，提升时钟频率，从而提升指令吞吐率<br><strong>流水线的级数并不是越多越好</strong>  </p>
<pre><code>将五级流水线细分为更多的阶段，增加流水线的深度
保证了流水线的平衡性
提升时钟频率，从而提高指令吞吐率
</code></pre><h2 id="超标量流水线"><a href="#超标量流水线" class="headerlink" title="超标量流水线"></a>超标量流水线</h2><pre><code>具有两条或两条以上并行工作的流水线结构称为超标量结构
使用超标量结构的处理器称为超标量处理器
第一款超标量x86 CPU：Pentium微处理器（双发射：U流水，V流水）
最早采用超标量技术的计算机：CDC6600（第一台超级计算机，1964年）
</code></pre><h2 id="流水线的冒险"><a href="#流水线的冒险" class="headerlink" title="流水线的冒险"></a>流水线的冒险</h2><h3 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h3><p>阻止下一条指令在下一个时钟周期开始执行的情况</p>
<pre><code>结构冒险：所需的硬件部件正在为之前的指令工作
数据冒险：需要等待之前的指令完成数据的读写
控制冒险：需要根据之前指令的结果决定下一步的行为
</code></pre><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h4><pre><code>如果指令和数据放在同一个存储器中，则不能同时读存储器 
解决方案：
    流水线停顿，产生空泡
    指令和数据放在不同的存储器中

如果读寄存器和写寄存器同时发生 
解决方案：
    前半个时钟周期写，后半个时钟周期读，并且设置独立的读写口
</code></pre><h4 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h4><pre><code>一条指令需要使用之前指令的运算结果，但是结果还没有写回 
解决方案：
    软件解决方案：插入nop指令（不好用，不知道流水线深度）
    流水线停顿，产生空泡
    数据前递：出现了数据冒险，则可以设置选择信号，将流水线寄存器中的值传到需要的组件中 

如果一条指令需要使用之前指令的访存结果，则数据前递无法解决，需要使用流水线停顿+数据前递
</code></pre><h2 id="控制冒险的处理"><a href="#控制冒险的处理" class="headerlink" title="控制冒险的处理"></a>控制冒险的处理</h2><h3 id="转移指令对流水线的影响"><a href="#转移指令对流水线的影响" class="headerlink" title="转移指令对流水线的影响"></a>转移指令对流水线的影响</h3><p>会导致错误的取指操作</p>
<h3 id="处理的方法"><a href="#处理的方法" class="headerlink" title="处理的方法"></a>处理的方法</h3><pre><code>转移指令：改变指令流向，破坏流水模式

转移开销：
    将按顺序预取的指令废除（排空流水线）
    从转移目标地址重新取指令

举例：MIPS转移指令：
    j Target（不停顿）
    jr $t0（停顿1周期）
    beq $t0, $t1, Target（停顿2周期，可按下图方式改进为1周期）
</code></pre><h3 id="延迟转移技术"><a href="#延迟转移技术" class="headerlink" title="延迟转移技术"></a>延迟转移技术</h3><p>即将一条必然执行的指令移动到条件转移指令之后执行，这样既解决了控制冒险问题，又没有损失性能<br>编译上优化</p>
<p>#存储层次结构 #</p>
<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>非易失性：断电后也不会丢失<br>可读可写的<br>随机访问<br>访问时间</p>
<h3 id="CPU和存储器的特性对比"><a href="#CPU和存储器的特性对比" class="headerlink" title="CPU和存储器的特性对比"></a>CPU和存储器的特性对比</h3><h3 id="存储器的特性对比"><a href="#存储器的特性对比" class="headerlink" title="存储器的特性对比"></a>存储器的特性对比</h3><p>高速缓存大大提升了性能</p>
<h3 id="存储器结构"><a href="#存储器结构" class="headerlink" title="存储器结构"></a>存储器结构</h3><p><img src="img/computerComposition/eighth/2.jpg" alt=""></p>
<h2 id="DRAM和SRAM"><a href="#DRAM和SRAM" class="headerlink" title="DRAM和SRAM"></a>DRAM和SRAM</h2><h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p><img src="img/computerComposition/eighth/DRAM1.jpg" alt=""></p>
<p><img src="img/computerComposition/eighth/DRAM2.jpg" alt=""></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>集成度高<br>功耗低<br>价格低<br>速度慢<br>定时刷新</p>
<h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h3><p><img src="img/computerComposition/eighth/3.jpg" alt=""></p>
<h4 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h4><p><img src="img/computerComposition/eighth/4.jpg" alt=""></p>
<h4 id="读出过程"><a href="#读出过程" class="headerlink" title="读出过程"></a>读出过程</h4><p><img src="img/computerComposition/eighth/6.jpg" alt=""></p>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>地址线，片选线，数据线，读写控制线</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>速度快<br>集成度低<br>功耗高<br>价格高  </p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="img/computerComposition/eighth/7.jpg" alt=""></p>
<h2 id="主存的工作原理"><a href="#主存的工作原理" class="headerlink" title="主存的工作原理"></a>主存的工作原理</h2><h3 id="DRAM芯片的内部结构"><a href="#DRAM芯片的内部结构" class="headerlink" title="DRAM芯片的内部结构"></a>DRAM芯片的内部结构</h3><p><img src="img/computerComposition/eighth/8.jpg" alt=""></p>
<h4 id="操作时序图"><a href="#操作时序图" class="headerlink" title="操作时序图"></a>操作时序图</h4><p><img src="img/computerComposition/eighth/9.jpg" alt=""></p>
<p><img src="img/computerComposition/eighth/10.jpg" alt=""></p>
<p>一次读一整行送入缓存区<br>预充电：放弃被缓存的数据  </p>
<h4 id="关键性能参数"><a href="#关键性能参数" class="headerlink" title="关键性能参数"></a>关键性能参数</h4><p><img src="img/computerComposition/eighth/11.jpg" alt=""></p>
<h4 id="典型访问过程"><a href="#典型访问过程" class="headerlink" title="典型访问过程"></a>典型访问过程</h4><p><img src="img/computerComposition/eighth/12.jpg" alt=""></p>
<h2 id="主存技术的发展"><a href="#主存技术的发展" class="headerlink" title="主存技术的发展"></a>主存技术的发展</h2><h3 id="典型规格"><a href="#典型规格" class="headerlink" title="典型规格"></a>典型规格</h3><p><img src="img/computerComposition/eighth/13.jpg" alt=""></p>
<h3 id="影响性能的关键因素"><a href="#影响性能的关键因素" class="headerlink" title="影响性能的关键因素"></a>影响性能的关键因素</h3><h4 id="DDR的基本概念"><a href="#DDR的基本概念" class="headerlink" title="DDR的基本概念"></a>DDR的基本概念</h4><p><img src="img/computerComposition/eighth/14.jpg" alt=""><br>时钟上升沿和下降沿都传输数据</p>
<h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p><img src="img/computerComposition/eighth/15.jpg" alt=""></p>
<h4 id="DDR2"><a href="#DDR2" class="headerlink" title="DDR2"></a>DDR2</h4><p><img src="img/computerComposition/eighth/16.jpg" alt=""></p>
<p>DDR2升级到DDR3套路一样的</p>
<h2 id="高速缓存的工作原理"><a href="#高速缓存的工作原理" class="headerlink" title="高速缓存的工作原理"></a>高速缓存的工作原理</h2><h3 id="程序的局部性原理"><a href="#程序的局部性原理" class="headerlink" title="程序的局部性原理"></a>程序的局部性原理</h3><p><img src="img/computerComposition/eighth/17.jpg" alt=""></p>
<h3 id="Cache对空间局部性的利用"><a href="#Cache对空间局部性的利用" class="headerlink" title="Cache对空间局部性的利用"></a>Cache对空间局部性的利用</h3><p><img src="img/computerComposition/eighth/18.jpg" alt=""></p>
<h3 id="Cache的访问过程"><a href="#Cache的访问过程" class="headerlink" title="Cache的访问过程"></a>Cache的访问过程</h3><p><img src="img/computerComposition/eighth/19.jpg" alt=""></p>
<h4 id="读过程示例"><a href="#读过程示例" class="headerlink" title="读过程示例"></a>读过程示例</h4><p><img src="img/computerComposition/eighth/20.jpg" alt=""></p>
<p><img src="img/computerComposition/eighth/21.jpg" alt=""></p>
<p><img src="img/computerComposition/eighth/22.jpg" alt=""></p>
<h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><p><img src="img/computerComposition/eighth/23.jpg" alt=""></p>
<h2 id="设计高速缓存的设计要点"><a href="#设计高速缓存的设计要点" class="headerlink" title="设计高速缓存的设计要点"></a>设计高速缓存的设计要点</h2><p><img src="img/computerComposition/eighth/24.jpg" alt=""></p>
<h3 id="平均访存时间"><a href="#平均访存时间" class="headerlink" title="平均访存时间"></a>平均访存时间</h3><p><img src="img/computerComposition/eighth/25.jpg" alt=""></p>
<h3 id="失效原因"><a href="#失效原因" class="headerlink" title="失效原因"></a>失效原因</h3><p><img src="img/computerComposition/eighth/26.jpg" alt=""></p>
<h3 id="映射策略"><a href="#映射策略" class="headerlink" title="映射策略"></a>映射策略</h3><p><img src="img/computerComposition/eighth/27.jpg" alt=""></p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p><img src="img/computerComposition/eighth/28.jpg" alt=""></p>
<h4 id="进一步切分"><a href="#进一步切分" class="headerlink" title="进一步切分"></a>进一步切分</h4><p><img src="img/computerComposition/eighth/29.jpg" alt=""><br>增加了延迟和功耗等等，需要协调</p>
<h3 id="corei7的缓存结构"><a href="#corei7的缓存结构" class="headerlink" title="corei7的缓存结构"></a>corei7的缓存结构</h3><p><img src="img/computerComposition/eighth/30.jpg" alt=""></p>
<h2 id="存储容量的计算"><a href="#存储容量的计算" class="headerlink" title="存储容量的计算"></a>存储容量的计算</h2><p>1024与1000单位不同</p>
<h3 id="内存单位"><a href="#内存单位" class="headerlink" title="内存单位"></a>内存单位</h3><h3 id="硬盘容量单位"><a href="#硬盘容量单位" class="headerlink" title="硬盘容量单位"></a>硬盘容量单位</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/21/编译原理学习笔记/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/21/编译原理学习笔记/" itemprop="url">
                  Untitled
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-21T14:00:50+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一课"><a href="#第一课" class="headerlink" title="第一课"></a>第一课</h1><h2 id="编译器简介"><a href="#编译器简介" class="headerlink" title="编译器简介"></a>编译器简介</h2><h3 id="什么是编译器"><a href="#什么是编译器" class="headerlink" title="什么是编译器"></a>什么是编译器</h3><pre><code>计算设备包括个人计算机、大型机、嵌 入式系统、智能设备等

核心的问题都是软件的构造
    而目前绝大部分软件都由高级语言书写
    成百种高级语言

这些语言写成的程序是如何运行在计算 机上的？
    编译器
</code></pre><hr>
<p>编译器是一个程序<br>核心功能是把源代码翻译成目标代码</p>
<hr>
<h3 id="编译器的核心功能"><a href="#编译器的核心功能" class="headerlink" title="编译器的核心功能"></a>编译器的核心功能</h3><p>目标程序和源代码语义相同（通过静态计算保证一致性）<br>目标程序通过动态计算得到计算结果</p>
<h3 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h3><p>解释器也是一类处理程序的程序</p>
<h2 id="编译器结构"><a href="#编译器结构" class="headerlink" title="编译器结构"></a>编译器结构</h2><h3 id="编译器的高层结构"><a href="#编译器的高层结构" class="headerlink" title="编译器的高层结构"></a>编译器的高层结构</h3><p>编译器具有非常模块化的高层结构<br>前后端结构</p>
<h3 id="抽象的多个阶段"><a href="#抽象的多个阶段" class="headerlink" title="抽象的多个阶段"></a>抽象的多个阶段</h3><p>编译器可看成多个阶段构成的“流水 线”结构</p>
<h3 id="一种没有优化的编译器结构"><a href="#一种没有优化的编译器结构" class="headerlink" title="一种没有优化的编译器结构"></a>一种没有优化的编译器结构</h3><pre><code>符号表贯穿所有阶段
    字符序列
词法分析
    记号序列
语法分析
    抽象语法树
语义分析
    中间代码
代码生成
    目标代码
</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>编译器由多个阶段组成，每个阶段都要 处理不同的问题
    使用不同的理论、数据结构和算法
因此，编译器设计中的重要问题是如何 合理的划分组织各个阶段
    接口清晰
    编译器容易实现、维护
</code></pre><h2 id="简单的编译器实例"><a href="#简单的编译器实例" class="headerlink" title="简单的编译器实例"></a>简单的编译器实例</h2><h3 id="简单的编译器实例-1"><a href="#简单的编译器实例-1" class="headerlink" title="简单的编译器实例"></a>简单的编译器实例</h3><pre><code>源语言：加法表 达式语言Sum
    两种语法形式
        整型数字：n
        加法 ：e1+e2

目标机器：栈式 计算机Stack
    一个操作数栈
    两条指令：
        压栈指令：push n
        加法 指令：add
</code></pre><h3 id="栈式计算机Stack"><a href="#栈式计算机Stack" class="headerlink" title="栈式计算机Stack"></a>栈式计算机Stack</h3><pre><code>一个操作数栈
两条指令：
    压栈指令：push n
    加法 指令：add
</code></pre><h3 id="编译器的阶段"><a href="#编译器的阶段" class="headerlink" title="编译器的阶段"></a>编译器的阶段</h3><pre><code>任务：编译程序1+2+3到栈式计算机
阶段一：词法语法分析
    拆分成五个部分
阶段二：语法树构建
    这五个部分是否符合Sum的语法规则
阶段三：代码生成
    对树的后序遍历补全代码
阶段四：代码优化（常量折叠优化）
</code></pre><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>编译器的结构与编译器的目标是相关的</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/20/SSM整合思路和配置文件/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/20/SSM整合思路和配置文件/" itemprop="url">
                  SSM整合思路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-20T22:23:46+08:00">
                2017-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>SSM整合思路<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/20/SSM整合思路和配置文件/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/20/MyBatis逆向工程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/20/MyBatis逆向工程/" itemprop="url">
                  MyBatis逆向工程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-20T22:04:41+08:00">
                2017-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>MyBatis逆向工程<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/20/MyBatis逆向工程/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/20/Hibernate学习笔记1/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/20/Hibernate学习笔记1/" itemprop="url">
                  Hibernate学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-20T19:42:53+08:00">
                2017-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>Hibernate学习笔记<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/20/Hibernate学习笔记1/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/15/redis集群/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/15/redis集群/" itemprop="url">
                  Untitled
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-15T19:10:02+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>./redis-trib.rb create –replicas 1 192.168.25.133:7001 192.168.25.133:7002 192.168.25.133:7003 192.168.25.133:7004 192.168.25.133:7005 192.168.25.133:7006  </p>
<p>redis01/redis-cli -p 7001 -c</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/14/FastBFS入门详解/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/FastBFS入门详解/" itemprop="url">
                  FastBFS入门详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-14T23:01:59+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>FastBFS入门详解<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/14/FastBFS入门详解/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="lily" />
          <p class="site-author-name" itemprop="name">lily</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lily</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>

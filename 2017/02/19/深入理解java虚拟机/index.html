<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="深入理解java虚拟机（前7章）">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解java虚拟机（前7章）">
<meta property="og:url" content="http://yoursite.com/2017/02/19/深入理解java虚拟机/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="深入理解java虚拟机（前7章）">
<meta property="og:updated_time" content="2017-02-25T12:40:22.645Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解java虚拟机（前7章）">
<meta name="twitter:description" content="深入理解java虚拟机（前7章）">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/02/19/深入理解java虚拟机/"/>





  <title> 深入理解java虚拟机（前7章） | Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/19/深入理解java虚拟机/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="John Doe">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                深入理解java虚拟机（前7章）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-19T21:23:59+08:00">
                2017-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>深入理解java虚拟机（前7章）<br><a id="more"></a></p>
<h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h4 id="java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域"><a href="#java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域" class="headerlink" title="java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域"></a>java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域</h4><ol>
<li>方法区</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>程序计数器<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><h4 id="作用：当前线程所执行的字节码的行号显示器"><a href="#作用：当前线程所执行的字节码的行号显示器" class="headerlink" title="作用：当前线程所执行的字节码的行号显示器"></a>作用：当前线程所执行的字节码的行号显示器</h4>字节码解释器工作时就是通过改变这个计数器的值来选去下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成<h4 id="每个线程有独立的程序计数器，彼此之间没有影响"><a href="#每个线程有独立的程序计数器，彼此之间没有影响" class="headerlink" title="每个线程有独立的程序计数器，彼此之间没有影响"></a>每个线程有独立的程序计数器，彼此之间没有影响</h4><h4 id="注：native方法是内存区域唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的情况的区域"><a href="#注：native方法是内存区域唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的情况的区域" class="headerlink" title="注：native方法是内存区域唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的情况的区域"></a>注：native方法是内存区域唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的情况的区域</h4></li>
</ol>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>也是线程私有的，它的生命周期和线程相同<br>描述的是Java方法执行的内存模型，每个方法被执行的同时会创建一个栈帧，用于存储局部变量表、操作站、动态链接、方法出口等信息</p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>存放了编译期可知的各种基本数据类型，对象引用和returnAddress类型</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈所发挥的作用是非常相似的，但是本地方法栈是为虚拟机使用到的Native方法服务</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>java堆是被所有线程共享得一块内存区域，在虚拟机启动时创建，此内存区域唯一目的就是存放对象实例<br>java堆是垃圾收集器管理的主要区域，”GC堆”</p>
<h4 id="可继续细分为新生代和老年代以及Eden空间、FromSurvivor空间、ToSurvivor空间等"><a href="#可继续细分为新生代和老年代以及Eden空间、FromSurvivor空间、ToSurvivor空间等" class="headerlink" title="可继续细分为新生代和老年代以及Eden空间、FromSurvivor空间、ToSurvivor空间等"></a>可继续细分为新生代和老年代以及Eden空间、FromSurvivor空间、ToSurvivor空间等</h4><h4 id="java堆可以处于物理上不连续的内存空间中"><a href="#java堆可以处于物理上不连续的内存空间中" class="headerlink" title="java堆可以处于物理上不连续的内存空间中"></a>java堆可以处于物理上不连续的内存空间中</h4><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>是各个线程共享的内存区域  </p>
<h4 id="用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据"><a href="#用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据" class="headerlink" title="用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据"></a>用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据</h4><p>只有HotSpot虚拟机选择把GC分带收集扩展至方法区<br>垃圾回收行为在这个区域是比较少出现的<br>这个区域的内存回收目标主要是针对常量池的回收和堆类型的卸载<br>可能会抛出OutOfMemoryError异常</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>是方法区的一部分，常量池用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中去</p>
<h4 id="运行时常量池具备动态性，运行期间也可能将新的常量放入池中，比如String类的intern-方法"><a href="#运行时常量池具备动态性，运行期间也可能将新的常量放入池中，比如String类的intern-方法" class="headerlink" title="运行时常量池具备动态性，运行期间也可能将新的常量放入池中，比如String类的intern()方法"></a>运行时常量池具备动态性，运行期间也可能将新的常量放入池中，比如String类的intern()方法</h4><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><h4 id="对象访问的方式"><a href="#对象访问的方式" class="headerlink" title="对象访问的方式"></a>对象访问的方式</h4><ol>
<li>使用句柄：java堆中会划分出一块内存作为句柄池，reference中存储的对象就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息</li>
<li>直接指针：java堆对象的不居中必须考虑如何防止访问类型数据的相关信息，reference中直接存储的就是对象地址</li>
</ol>
<h2 id="实战：OutOfMemoryError异常"><a href="#实战：OutOfMemoryError异常" class="headerlink" title="实战：OutOfMemoryError异常"></a>实战：OutOfMemoryError异常</h2><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><pre><code>public class HeapOOM {
    public static void main(String[] args) throws UnknownHostException {

        List&lt;Integer[]&gt; list = new ArrayList&lt;&gt;();
        while (true){
            list.add(new Integer[10000]);
        }
    }
}
</code></pre><h4 id="如何解决：重点是确认内存中的对象是否是必要的，先分清时出现了内存泄漏还是内存溢出"><a href="#如何解决：重点是确认内存中的对象是否是必要的，先分清时出现了内存泄漏还是内存溢出" class="headerlink" title="如何解决：重点是确认内存中的对象是否是必要的，先分清时出现了内存泄漏还是内存溢出"></a>如何解决：重点是确认内存中的对象是否是必要的，先分清时出现了内存泄漏还是内存溢出</h4><ol>
<li>如果是内存泄漏，可以使用工具查看泄漏对象到GC Roots的引用链，就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的</li>
<li>如果不存在泄露，那么应当检查虚拟机的堆参数，看看是否可以调大，从代码上检查是否存在某些对象生命周期过长，持有状态过场等情况</li>
</ol>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><ol>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，则抛出StackOverflowError异常</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常<h4 id=""><a href="#" class="headerlink" title="#"></a>#</h4> public class JavaVMStackSOF {<pre><code>private int stacklength = 1;
public void stackLeak(){
    stacklength++;
    stackLeak();
}
public static void main(String[] args) {
    JavaVMStackSOF oom = new JavaVMStackSOF();
    try {
        oom.stackLeak();
    }catch (Exception e){
        throw e;
    }finally {
        System.out.println(&quot;stack length:&quot; + oom.stacklength);
    }
}
</code></pre> }</li>
</ol>
<h3 id="运行时常量池溢出"><a href="#运行时常量池溢出" class="headerlink" title="运行时常量池溢出"></a>运行时常量池溢出</h3><p>使用String.intern()方法向常量池中添加内容</p>
<h4 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h4><pre><code>public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        int i = 0;
        while (true) {
            list.add(String.valueOf(i++).intern());
        }
    }
}
</code></pre><h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><p>方法区用于 存放Class等相关信息，如类型、访问修饰符、常量池、字段描述、方法描述等</p>
<h4 id="-2"><a href="#-2" class="headerlink" title="#"></a>#</h4><pre><code>public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        int i = 0;
        while (true) {
            list.add(String.valueOf(i++).intern());
        }
    }
}
</code></pre><h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><pre><code>public class DirectMomeryOOM {
    private static final int _1M = 1024 * 1024;

    public static void main(String[] args) throws Exception {
        Field unsafeField = Unsafe.class.getDeclaredFields()[0];
        unsafeField.setAccessible(true);
        Unsafe unsafe = (Unsafe) unsafeField.get(null);
        while (true)
            unsafe.allocateMemory(_1M);
    }
}
</code></pre><h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h4><p>哪些内存需要回收？什么时候回收？如何回收？</p>
<h4 id="当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节"><a href="#当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节" class="headerlink" title="当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节"></a>当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节</h4><h4 id="“内存”分配与回收指的是在java堆中"><a href="#“内存”分配与回收指的是在java堆中" class="headerlink" title="“内存”分配与回收指的是在java堆中"></a>“内存”分配与回收指的是在java堆中</h4><h2 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h2><h4 id="确认哪些对象“活着”，哪些已经“死去”"><a href="#确认哪些对象“活着”，哪些已经“死去”" class="headerlink" title="确认哪些对象“活着”，哪些已经“死去”"></a>确认哪些对象“活着”，哪些已经“死去”</h4><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每次有一个地方引用它时，计数器就加1，当引用失效时，计数器值就减1；任何时刻计算器都为0的对象就是不可能再被使用的；  </p>
<h4 id="很难解决对象之间相互循环引用的问题"><a href="#很难解决对象之间相互循环引用的问题" class="headerlink" title="很难解决对象之间相互循环引用的问题"></a>很难解决对象之间相互循环引用的问题</h4><h3 id="根搜索算法（Java使用的）"><a href="#根搜索算法（Java使用的）" class="headerlink" title="根搜索算法（Java使用的）"></a>根搜索算法（Java使用的）</h3><p>通过一些列的名为“GC Roots”的对象作为起始点，从这些节点开始向下探索，搜索所走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的</p>
<h4 id="java中可作为GC-Roots的对象包括以下几种"><a href="#java中可作为GC-Roots的对象包括以下几种" class="headerlink" title="java中可作为GC Roots的对象包括以下几种"></a>java中可作为GC Roots的对象包括以下几种</h4><ol>
<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）的引用的对象</li>
</ol>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><h4 id="JDK1-2之前：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用"><a href="#JDK1-2之前：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用" class="headerlink" title="JDK1.2之前：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用"></a>JDK1.2之前：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用</h4><ol>
<li>强引用：只要存在，就不会被回收</li>
<li>软引用：描述一些还有用，但非必需的对象，在内存溢出之前，会把它们列入回收范围之中并进行第二次回收</li>
<li>弱引用：也是描述非必需对象的，但是其关联的对象只能生存到下一次垃圾收集发生之前</li>
<li>虚引用：最弱，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例</li>
</ol>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><h4 id="要真正宣告一个对象死亡，至少要经历两次标记过程"><a href="#要真正宣告一个对象死亡，至少要经历两次标记过程" class="headerlink" title="要真正宣告一个对象死亡，至少要经历两次标记过程"></a>要真正宣告一个对象死亡，至少要经历两次标记过程</h4><p>如果对象在进行跟搜索后发现没有与GC Roots相连接的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize（）方法，或者方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”</p>
<h4 id="finalize（）方法是对象逃脱死亡命运的最后一次机会，而且只能成功一次"><a href="#finalize（）方法是对象逃脱死亡命运的最后一次机会，而且只能成功一次" class="headerlink" title="finalize（）方法是对象逃脱死亡命运的最后一次机会，而且只能成功一次"></a>finalize（）方法是对象逃脱死亡命运的最后一次机会，而且只能成功一次</h4><h3 id="方法回收区"><a href="#方法回收区" class="headerlink" title="方法回收区"></a>方法回收区</h3><h4 id="在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70-95-的空间，而永久代的垃圾收集效率远低于此"><a href="#在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70-95-的空间，而永久代的垃圾收集效率远低于此" class="headerlink" title="在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾收集效率远低于此"></a>在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾收集效率远低于此</h4><p>永久代的垃圾收集主要是两部分内容：废弃常量和无用的类</p>
<h4 id="判断一个类是否是“无用的类”"><a href="#判断一个类是否是“无用的类”" class="headerlink" title="判断一个类是否是“无用的类”"></a>判断一个类是否是“无用的类”</h4><ol>
<li>该类的所有的实例都已经被回收，也就是java堆中不存在该类的任何实例；</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ol>
<h4 id="在大量使用反射、动态代理等场景下，需要保证永久代不会溢出"><a href="#在大量使用反射、动态代理等场景下，需要保证永久代不会溢出" class="headerlink" title="在大量使用反射、动态代理等场景下，需要保证永久代不会溢出"></a>在大量使用反射、动态代理等场景下，需要保证永久代不会溢出</h4><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><h4 id="首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象"><a href="#首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象" class="headerlink" title="首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象"></a>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象</h4><p>有两个缺点：一是效率问题，二是空间问题</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存使用完了，就将还存活着的对象复制到另外一块上去，然后把已经使用过的内存空间一次清理掉  </p>
<h4 id="现在的商业虚拟机都采用这种回收算法"><a href="#现在的商业虚拟机都采用这种回收算法" class="headerlink" title="现在的商业虚拟机都采用这种回收算法"></a>现在的商业虚拟机都采用这种回收算法</h4><p>新生代的对象98%是朝生暮死的，所有将内存花费为一个较大的Eden空间和两块较小的Survivor空间，每次使用其中的一块Survivor，当回收时，将Eden和Survivor中还存活着的对象一次性的拷贝到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><h4 id="让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存"><a href="#让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存" class="headerlink" title="让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存"></a>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</h4><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”算法，根据对象的存货周期的不同将内存划分为几块</p>
<h4 id="一般是将java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法"><a href="#一般是将java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法" class="headerlink" title="一般是将java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法"></a>一般是将java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法</h4><p>新生代中较多使用复制算法<br>老年代中使用标记-清理算法或标记-整理算法</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><ol>
<li>Serial</li>
<li>ParNew</li>
<li>CMS</li>
<li>Serial Old（MSC）</li>
<li>Parallel Old </li>
<li>Parallel Scavenge</li>
<li>G1</li>
</ol>
<h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>在JDK1.3.1之前是虚拟机新生代收集的唯一选择，是一个单线程收集器</p>
<h4 id="简单而高效"><a href="#简单而高效" class="headerlink" title="简单而高效"></a>简单而高效</h4><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>是Serial收集器的多线程版本</p>
<h4 id="是运行在Server模式下的虚拟机中首选的新生代收集器"><a href="#是运行在Server模式下的虚拟机中首选的新生代收集器" class="headerlink" title="是运行在Server模式下的虚拟机中首选的新生代收集器"></a>是运行在Server模式下的虚拟机中首选的新生代收集器</h4><h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>也是一个新生代收集器，使用复制算法，也是并行的多线程收集器</p>
<h4 id="目标是达到一个可控制的吞吐量"><a href="#目标是达到一个可控制的吞吐量" class="headerlink" title="目标是达到一个可控制的吞吐量"></a>目标是达到一个可控制的吞吐量</h4><h3 id="Serial-Old（MSC）"><a href="#Serial-Old（MSC）" class="headerlink" title="Serial Old（MSC）"></a>Serial Old（MSC）</h3><p>是Serial收集器的老年代版本，是一个单线程收集器，使用“标记-整理”算法</p>
<h4 id="两大用途：与Parallel-Scavenge搭配使用，另一个是作为CMS收集器的后备预案"><a href="#两大用途：与Parallel-Scavenge搭配使用，另一个是作为CMS收集器的后备预案" class="headerlink" title="两大用途：与Parallel Scavenge搭配使用，另一个是作为CMS收集器的后备预案"></a>两大用途：与Parallel Scavenge搭配使用，另一个是作为CMS收集器的后备预案</h4><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>是Parallel Scavenge的老年版本，使用多线程和“标记-整理”算法，JDK1.6之后才提供的</p>
<h4 id="与Parallel-Scavenge搭配使用"><a href="#与Parallel-Scavenge搭配使用" class="headerlink" title="与Parallel Scavenge搭配使用"></a>与Parallel Scavenge搭配使用</h4><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>是一种以获取最短回收停顿时间为目标的收集器，基于“标记-清除”算法实现的</p>
<h4 id="-3"><a href="#-3" class="headerlink" title="#"></a>#</h4><ol>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除<h4 id="-4"><a href="#-4" class="headerlink" title="#"></a>#</h4>初始标记和重新标记需要“stop the world”<br>初始标记仅仅是标记一下GC Roots能直接关联到的对象，速度很快<br>并发标记阶段就是进行GC Roots Tracing的过程<br>重新标记则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录<h4 id="整个过程耗时最长的是并发标记和并发清除"><a href="#整个过程耗时最长的是并发标记和并发清除" class="headerlink" title="整个过程耗时最长的是并发标记和并发清除"></a>整个过程耗时最长的是并发标记和并发清除</h4><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>CMS收集器堆CPU资源非常敏感  </li>
<li>CMS无法清除浮动垃圾  </li>
<li>收集结束时会产生大量的空间碎片</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><h4 id="是当前收集齐技术发展的最前沿的成果"><a href="#是当前收集齐技术发展的最前沿的成果" class="headerlink" title="是当前收集齐技术发展的最前沿的成果"></a>是当前收集齐技术发展的最前沿的成果</h4><ol>
<li>基于“标记-整理”算法</li>
<li>可以精确地控制停顿</li>
<li>基本不牺牲吞吐量<h4 id="-5"><a href="#-5" class="headerlink" title="#"></a>#</h4>G1将整个Java堆划分为多个大小固定的独立区域，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h4 id="自动内存管理最终归结为自动化的解决了两个问题，给对象分配内存以及回收分配给对象的内存"><a href="#自动内存管理最终归结为自动化的解决了两个问题，给对象分配内存以及回收分配给对象的内存" class="headerlink" title="自动内存管理最终归结为自动化的解决了两个问题，给对象分配内存以及回收分配给对象的内存"></a>自动内存管理最终归结为自动化的解决了两个问题，给对象分配内存以及回收分配给对象的内存</h4><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>Eden区没有足够的空间进行分配时，虚拟机将发起一次MinorGC（回收速度较快）</p>
<h4 id="fullGC，回收速度很慢"><a href="#fullGC，回收速度很慢" class="headerlink" title="fullGC，回收速度很慢"></a>fullGC，回收速度很慢</h4><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象意指需要大量连续内存空间的Java对象，典型的就是那种很长字符串以及数组<br>目的是避免在Eden区及两个Survivor去之间发生大量的内存拷贝</p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>如果对象在Eden出生并且经过第一次MinorGC后，那么就会被移到Survivor区中，并且对象年龄设为1，然后每熬过一次MinorGC，年龄增加一岁，年龄增加到一定程度后（默认15岁），就会被晋升到老年代中</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在出现大量对象在MinorGC后仍然存活的情况时，就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代</p>
<h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段</p>
<h2 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h2><p>借助tools.jar类库里面的接口，我们可以直接在应用程序中实现强大的监控分析功能</p>
<h3 id="jsp：JVM-Process-Status-Tool虚拟机进程状况工具"><a href="#jsp：JVM-Process-Status-Tool虚拟机进程状况工具" class="headerlink" title="jsp：JVM Process Status Tool虚拟机进程状况工具"></a>jsp：JVM Process Status Tool虚拟机进程状况工具</h3><p>可以列出正在运行的虚拟机进程，并显示虚拟机执行主类函数所在的名称，以及这些进程的本地虚拟机的唯一ID<br>对于本地虚拟进程来说，LVMID与操作系统的进程ID是一致的<br>如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就只能依赖jsp命令显示主类的功能才能区分了</p>
<h3 id="jstat-虚拟机统计信息监视工具"><a href="#jstat-虚拟机统计信息监视工具" class="headerlink" title="jstat:虚拟机统计信息监视工具"></a>jstat:虚拟机统计信息监视工具</h3><p>用于监视虚拟机各种运行状态信息的命令行工具，他可以显示本地货远程虚拟机进程中的类装载，内存，垃圾收集，JIT编译等运行数据，是运行期定位虚拟机性能问题的首选工具</p>
<h3 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h3><p>实时地查看和调整虚拟机的各项参数</p>
<h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><p>用于生成堆转储快照，还可以查询finalize执行队列，Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等</p>
<h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><p>与jmap搭配使用，来分析jmap生成的堆转储快照</p>
<h3 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h3><p>用于生成虚拟机当前时刻的线程快照</p>
<h4 id="线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，主要目的是定位线程出现长时间停顿的原因"><a href="#线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，主要目的是定位线程出现长时间停顿的原因" class="headerlink" title="线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，主要目的是定位线程出现长时间停顿的原因"></a>线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，主要目的是定位线程出现长时间停顿的原因</h4><h2 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h2><ol>
<li>JConsole  </li>
<li>VisualVM</li>
</ol>
<h3 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h3><p>是一款基于JMX的可视化监视和管理的工具</p>
<h4 id="-6"><a href="#-6" class="headerlink" title="#"></a>#</h4><ul>
<li>启动JConsole：通过JDK/bin目录下的“jconsole.exe”启动JConsole  </li>
<li>内存监控：相当于可视化的jstat命令，用于监视收集器管理的虚拟内存的变化趋势  </li>
<li>线程监控：相当于可视化的jstack命令</li>
</ul>
<h3 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h3><h4 id="VisualVM兼容范围与插件安装"><a href="#VisualVM兼容范围与插件安装" class="headerlink" title="VisualVM兼容范围与插件安装"></a>VisualVM兼容范围与插件安装</h4><ol>
<li>显示虚拟机进程及进程的配置和环境信息  </li>
<li>监视应用程序的CPU、GC、堆、方法区及线程的信息  </li>
<li>dump及分析堆转储快照  </li>
<li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法  </li>
<li>离线程序快照：手机程序的运行时配置，线程dump，内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈  </li>
<li>其他</li>
</ol>
<h4 id="BTrace插件工具"><a href="#BTrace插件工具" class="headerlink" title="BTrace插件工具"></a>BTrace插件工具</h4><h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="高性能硬件上的程序部署策略"><a href="#高性能硬件上的程序部署策略" class="headerlink" title="高性能硬件上的程序部署策略"></a>高性能硬件上的程序部署策略</h3><p>长时间才出现一次Full GC可以通过深夜执行定时任务的方式触发Full GC 甚至自动重启应用服务器来将内存可用空间保持在一个稳定的水平</p>
<h3 id="集群间同步导致的内存溢出"><a href="#集群间同步导致的内存溢出" class="headerlink" title="集群间同步导致的内存溢出"></a>集群间同步导致的内存溢出</h3><h3 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h3><h3 id="外部命令倒置系统缓慢"><a href="#外部命令倒置系统缓慢" class="headerlink" title="外部命令倒置系统缓慢"></a>外部命令倒置系统缓慢</h3><h3 id="服务器JVM进程崩溃"><a href="#服务器JVM进程崩溃" class="headerlink" title="服务器JVM进程崩溃"></a>服务器JVM进程崩溃</h3><h2 id="Eclipse运行速度调优"><a href="#Eclipse运行速度调优" class="headerlink" title="Eclipse运行速度调优"></a>Eclipse运行速度调优</h2><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><p>java虚拟机提供的语言无关性是基于.class文件实现的</p>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>Class文件是以8字节为基础单位的二进制流<br>整个Class文件本质上就是一张表</p>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>Class文件的头四个字节被称为魔数，它的唯一作用是用于确定整个文件是否为一个能被虚拟机接受的Class文件，值为0xCAFEBABE<br>紧随其后的四个字节是Class文件的版本号，前两个字节是次版本号，后两个字节是主版本号</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>紧随主版本号之后的是常量池的入口  </p>
<h4 id="其中主要存放两大类常量：字面量和符号引用"><a href="#其中主要存放两大类常量：字面量和符号引用" class="headerlink" title="其中主要存放两大类常量：字面量和符号引用"></a>其中主要存放两大类常量：字面量和符号引用</h4><p>字面量比较接近java语言层面的常量概念， 符号引用是属于编译原理的概念，包括下面三类常量：<br>类和接口的全限定名<br>字段的名称和描述符<br>方法的名称和描述符  </p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><h2 id="Class文件结构的发展"><a href="#Class文件结构的发展" class="headerlink" title="Class文件结构的发展"></a>Class文件结构的发展</h2><h1 id="虚拟机类加载机制-重点"><a href="#虚拟机类加载机制-重点" class="headerlink" title="虚拟机类加载机制-重点"></a>虚拟机类加载机制-重点</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的文件从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br>java中，类型的加载和连接过程都是在程序运行期间完成的</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><ol>
<li>加载</li>
<li>验证</li>
<li>准备</li>
<li>解析</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ol>
<p>解析阶段运行顺序是不一定的，因为java是运行时绑定的</p>
<h4 id="有且只有四种情况必须立即对类进行初始化（加载、验证、准备自然需要在此之前开始）"><a href="#有且只有四种情况必须立即对类进行初始化（加载、验证、准备自然需要在此之前开始）" class="headerlink" title="有且只有四种情况必须立即对类进行初始化（加载、验证、准备自然需要在此之前开始）"></a>有且只有四种情况必须立即对类进行初始化（加载、验证、准备自然需要在此之前开始）</h4><ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化，在java中的场景就是：使用new实例化对象、读取或设置一个类的静态字段、调用一个类的静态方法。  </li>
<li>使用java.lang.reflect包的方法对类进行发射调用的时候，如果类没有进行过初始化，则需要先触发其初始化</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类</li>
</ol>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类加载的一个阶段，需要完成三件事：  </p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流  </li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构  </li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口</li>
</ol>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全  </p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>文件格式验证  </li>
<li>元数据验证  </li>
<li>字节码验证  </li>
<li>符号引用验证</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>是虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<h4 id="四中引用的解析过程"><a href="#四中引用的解析过程" class="headerlink" title="四中引用的解析过程"></a>四中引用的解析过程</h4><p>类或接口的解析<br>字段解析<br>类方法解析<br>接口方法解析</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化是类加载阶段的最后一步<br>根据程序员通过程序制定的主管计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器的方法的过程</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提之下才有意义</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/15/计算机网络/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/22/JDBC学习/" rel="prev" title="JDBC">
                JDBC <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java内存区域与内存溢出异常"><span class="nav-number">1.</span> <span class="nav-text">Java内存区域与内存溢出异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时数据区域"><span class="nav-number">1.2.</span> <span class="nav-text">运行时数据区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器"><span class="nav-number">1.2.1.</span> <span class="nav-text">程序计数器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#作用：当前线程所执行的字节码的行号显示器"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">作用：当前线程所执行的字节码的行号显示器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#每个线程有独立的程序计数器，彼此之间没有影响"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">每个线程有独立的程序计数器，彼此之间没有影响</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注：native方法是内存区域唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的情况的区域"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">注：native方法是内存区域唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的情况的区域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java虚拟机栈"><span class="nav-number">1.2.2.</span> <span class="nav-text">Java虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#局部变量表"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">局部变量表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地方法栈"><span class="nav-number">1.2.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java堆"><span class="nav-number">1.2.4.</span> <span class="nav-text">Java堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可继续细分为新生代和老年代以及Eden空间、FromSurvivor空间、ToSurvivor空间等"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">可继续细分为新生代和老年代以及Eden空间、FromSurvivor空间、ToSurvivor空间等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java堆可以处于物理上不连续的内存空间中"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">java堆可以处于物理上不连续的内存空间中</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区"><span class="nav-number">1.2.5.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时常量池"><span class="nav-number">1.2.6.</span> <span class="nav-text">运行时常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运行时常量池具备动态性，运行期间也可能将新的常量放入池中，比如String类的intern-方法"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">运行时常量池具备动态性，运行期间也可能将新的常量放入池中，比如String类的intern()方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接内存"><span class="nav-number">1.2.7.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象访问"><span class="nav-number">1.3.</span> <span class="nav-text">对象访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象访问的方式"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">对象访问的方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实战：OutOfMemoryError异常"><span class="nav-number">1.4.</span> <span class="nav-text">实战：OutOfMemoryError异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java堆溢出"><span class="nav-number">1.4.1.</span> <span class="nav-text">Java堆溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何解决：重点是确认内存中的对象是否是必要的，先分清时出现了内存泄漏还是内存溢出"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">如何解决：重点是确认内存中的对象是否是必要的，先分清时出现了内存泄漏还是内存溢出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟机栈和本地方法栈溢出"><span class="nav-number">1.4.2.</span> <span class="nav-text">虚拟机栈和本地方法栈溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">#</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时常量池溢出"><span class="nav-number">1.4.3.</span> <span class="nav-text">运行时常量池溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#-1"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">#</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区溢出"><span class="nav-number">1.4.4.</span> <span class="nav-text">方法区溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#-2"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">#</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本机直接内存溢出"><span class="nav-number">1.4.5.</span> <span class="nav-text">本机直接内存溢出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾收集器与内存分配策略"><span class="nav-number">2.</span> <span class="nav-text">垃圾收集器与内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-1"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GC"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节"><span class="nav-number">2.1.0.2.</span> <span class="nav-text">当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#“内存”分配与回收指的是在java堆中"><span class="nav-number">2.1.0.3.</span> <span class="nav-text">“内存”分配与回收指的是在java堆中</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象已死？"><span class="nav-number">2.2.</span> <span class="nav-text">对象已死？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#确认哪些对象“活着”，哪些已经“死去”"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">确认哪些对象“活着”，哪些已经“死去”</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数法"><span class="nav-number">2.2.1.</span> <span class="nav-text">引用计数法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#很难解决对象之间相互循环引用的问题"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">很难解决对象之间相互循环引用的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根搜索算法（Java使用的）"><span class="nav-number">2.2.2.</span> <span class="nav-text">根搜索算法（Java使用的）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java中可作为GC-Roots的对象包括以下几种"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">java中可作为GC Roots的对象包括以下几种</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#再谈引用"><span class="nav-number">2.2.3.</span> <span class="nav-text">再谈引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-2之前：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">JDK1.2之前：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生存还是死亡"><span class="nav-number">2.2.4.</span> <span class="nav-text">生存还是死亡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#要真正宣告一个对象死亡，至少要经历两次标记过程"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">要真正宣告一个对象死亡，至少要经历两次标记过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finalize（）方法是对象逃脱死亡命运的最后一次机会，而且只能成功一次"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">finalize（）方法是对象逃脱死亡命运的最后一次机会，而且只能成功一次</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法回收区"><span class="nav-number">2.2.5.</span> <span class="nav-text">方法回收区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70-95-的空间，而永久代的垃圾收集效率远低于此"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾收集效率远低于此</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断一个类是否是“无用的类”"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">判断一个类是否是“无用的类”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在大量使用反射、动态代理等场景下，需要保证永久代不会溢出"><span class="nav-number">2.2.5.3.</span> <span class="nav-text">在大量使用反射、动态代理等场景下，需要保证永久代不会溢出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收算法"><span class="nav-number">2.3.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-清除算法"><span class="nav-number">2.3.1.</span> <span class="nav-text">标记-清除算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制算法"><span class="nav-number">2.3.2.</span> <span class="nav-text">复制算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#现在的商业虚拟机都采用这种回收算法"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">现在的商业虚拟机都采用这种回收算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-整理算法"><span class="nav-number">2.3.3.</span> <span class="nav-text">标记-整理算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集算法"><span class="nav-number">2.3.4.</span> <span class="nav-text">分代收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一般是将java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">一般是将java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">2.4.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial"><span class="nav-number">2.4.1.</span> <span class="nav-text">Serial</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单而高效"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">简单而高效</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew"><span class="nav-number">2.4.2.</span> <span class="nav-text">ParNew</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#是运行在Server模式下的虚拟机中首选的新生代收集器"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">是运行在Server模式下的虚拟机中首选的新生代收集器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Scavenge"><span class="nav-number">2.4.3.</span> <span class="nav-text">Parallel Scavenge</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标是达到一个可控制的吞吐量"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">目标是达到一个可控制的吞吐量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-Old（MSC）"><span class="nav-number">2.4.4.</span> <span class="nav-text">Serial Old（MSC）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#两大用途：与Parallel-Scavenge搭配使用，另一个是作为CMS收集器的后备预案"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">两大用途：与Parallel Scavenge搭配使用，另一个是作为CMS收集器的后备预案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Old"><span class="nav-number">2.4.5.</span> <span class="nav-text">Parallel Old</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#与Parallel-Scavenge搭配使用"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">与Parallel Scavenge搭配使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS收集器"><span class="nav-number">2.4.6.</span> <span class="nav-text">CMS收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#-3"><span class="nav-number">2.4.6.1.</span> <span class="nav-text">#</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#-4"><span class="nav-number">2.4.6.2.</span> <span class="nav-text">#</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#整个过程耗时最长的是并发标记和并发清除"><span class="nav-number">2.4.6.3.</span> <span class="nav-text">整个过程耗时最长的是并发标记和并发清除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">2.4.6.4.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1收集器"><span class="nav-number">2.4.7.</span> <span class="nav-text">G1收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#是当前收集齐技术发展的最前沿的成果"><span class="nav-number">2.4.7.1.</span> <span class="nav-text">是当前收集齐技术发展的最前沿的成果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#-5"><span class="nav-number">2.4.7.2.</span> <span class="nav-text">#</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">2.4.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配与回收策略"><span class="nav-number">2.5.</span> <span class="nav-text">内存分配与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动内存管理最终归结为自动化的解决了两个问题，给对象分配内存以及回收分配给对象的内存"><span class="nav-number">2.5.0.1.</span> <span class="nav-text">自动内存管理最终归结为自动化的解决了两个问题，给对象分配内存以及回收分配给对象的内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象优先在Eden分配"><span class="nav-number">2.5.1.</span> <span class="nav-text">对象优先在Eden分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fullGC，回收速度很慢"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">fullGC，回收速度很慢</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大对象直接进入老年代"><span class="nav-number">2.5.2.</span> <span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#长期存活的对象将进入老年代"><span class="nav-number">2.5.3.</span> <span class="nav-text">长期存活的对象将进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态对象年龄判定"><span class="nav-number">2.5.4.</span> <span class="nav-text">动态对象年龄判定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空间分配担保"><span class="nav-number">2.5.5.</span> <span class="nav-text">空间分配担保</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机性能监控与故障处理工具"><span class="nav-number">3.</span> <span class="nav-text">虚拟机性能监控与故障处理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-2"><span class="nav-number">3.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">3.1.0.1.</span> <span class="nav-text">方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK的命令行工具"><span class="nav-number">3.2.</span> <span class="nav-text">JDK的命令行工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jsp：JVM-Process-Status-Tool虚拟机进程状况工具"><span class="nav-number">3.2.1.</span> <span class="nav-text">jsp：JVM Process Status Tool虚拟机进程状况工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jstat-虚拟机统计信息监视工具"><span class="nav-number">3.2.2.</span> <span class="nav-text">jstat:虚拟机统计信息监视工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jinfo：Java配置信息工具"><span class="nav-number">3.2.3.</span> <span class="nav-text">jinfo：Java配置信息工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jmap：Java内存映像工具"><span class="nav-number">3.2.4.</span> <span class="nav-text">jmap：Java内存映像工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jhat：虚拟机堆转储快照分析工具"><span class="nav-number">3.2.5.</span> <span class="nav-text">jhat：虚拟机堆转储快照分析工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jstack：Java堆栈跟踪工具"><span class="nav-number">3.2.6.</span> <span class="nav-text">jstack：Java堆栈跟踪工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，主要目的是定位线程出现长时间停顿的原因"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，主要目的是定位线程出现长时间停顿的原因</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK的可视化工具"><span class="nav-number">3.3.</span> <span class="nav-text">JDK的可视化工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JConsole：Java监视与管理控制台"><span class="nav-number">3.3.1.</span> <span class="nav-text">JConsole：Java监视与管理控制台</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#-6"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">#</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VisualVM：多合一故障处理工具"><span class="nav-number">3.3.2.</span> <span class="nav-text">VisualVM：多合一故障处理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#VisualVM兼容范围与插件安装"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">VisualVM兼容范围与插件安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BTrace插件工具"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">BTrace插件工具</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#调优案例分析与实战"><span class="nav-number">4.</span> <span class="nav-text">调优案例分析与实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-3"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#案例分析"><span class="nav-number">4.2.</span> <span class="nav-text">案例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#高性能硬件上的程序部署策略"><span class="nav-number">4.2.1.</span> <span class="nav-text">高性能硬件上的程序部署策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群间同步导致的内存溢出"><span class="nav-number">4.2.2.</span> <span class="nav-text">集群间同步导致的内存溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆外内存导致的溢出错误"><span class="nav-number">4.2.3.</span> <span class="nav-text">堆外内存导致的溢出错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外部命令倒置系统缓慢"><span class="nav-number">4.2.4.</span> <span class="nav-text">外部命令倒置系统缓慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器JVM进程崩溃"><span class="nav-number">4.2.5.</span> <span class="nav-text">服务器JVM进程崩溃</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Eclipse运行速度调优"><span class="nav-number">4.3.</span> <span class="nav-text">Eclipse运行速度调优</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类文件结构"><span class="nav-number">5.</span> <span class="nav-text">类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-4"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无关性的基石"><span class="nav-number">5.2.</span> <span class="nav-text">无关性的基石</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class类文件的结构"><span class="nav-number">5.3.</span> <span class="nav-text">Class类文件的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#魔数与Class文件的版本"><span class="nav-number">5.3.1.</span> <span class="nav-text">魔数与Class文件的版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量池"><span class="nav-number">5.3.2.</span> <span class="nav-text">常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#其中主要存放两大类常量：字面量和符号引用"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">其中主要存放两大类常量：字面量和符号引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问标志"><span class="nav-number">5.3.3.</span> <span class="nav-text">访问标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类索引、父类索引与接口索引集合"><span class="nav-number">5.3.4.</span> <span class="nav-text">类索引、父类索引与接口索引集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字段表集合"><span class="nav-number">5.3.5.</span> <span class="nav-text">字段表集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法表集合"><span class="nav-number">5.3.6.</span> <span class="nav-text">方法表集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性表集合"><span class="nav-number">5.3.7.</span> <span class="nav-text">属性表集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class文件结构的发展"><span class="nav-number">5.4.</span> <span class="nav-text">Class文件结构的发展</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机类加载机制-重点"><span class="nav-number">6.</span> <span class="nav-text">虚拟机类加载机制-重点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-5"><span class="nav-number">6.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载的时机"><span class="nav-number">6.2.</span> <span class="nav-text">类加载的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有且只有四种情况必须立即对类进行初始化（加载、验证、准备自然需要在此之前开始）"><span class="nav-number">6.2.0.1.</span> <span class="nav-text">有且只有四种情况必须立即对类进行初始化（加载、验证、准备自然需要在此之前开始）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载的过程"><span class="nav-number">6.3.</span> <span class="nav-text">类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载"><span class="nav-number">6.3.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证"><span class="nav-number">6.3.2.</span> <span class="nav-text">验证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#过程"><span class="nav-number">6.3.2.1.</span> <span class="nav-text">过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备"><span class="nav-number">6.3.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析"><span class="nav-number">6.3.4.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#四中引用的解析过程"><span class="nav-number">6.3.4.1.</span> <span class="nav-text">四中引用的解析过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">6.3.5.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器"><span class="nav-number">6.4.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类与类加载器"><span class="nav-number">6.4.1.</span> <span class="nav-text">类与类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">6.4.2.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#破坏双亲委派模型"><span class="nav-number">6.4.3.</span> <span class="nav-text">破坏双亲委派模型</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  

  

  

  

  


</body>
</html>

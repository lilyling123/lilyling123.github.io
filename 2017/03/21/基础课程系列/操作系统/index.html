<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://yoursite.com/2017/03/21/基础课程系列/操作系统/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="操作系统">
<meta property="og:image" content="http://i.imgur.com/Md58ooA.jpg">
<meta property="og:image" content="http://i.imgur.com/QtK5q30.jpg">
<meta property="og:image" content="http://i.imgur.com/zfUhtic.jpg">
<meta property="og:image" content="http://i.imgur.com/XZeZzlY.jpg">
<meta property="og:image" content="http://i.imgur.com/SdcJiLx.jpg">
<meta property="og:image" content="http://i.imgur.com/cS7YiDl.jpg">
<meta property="og:image" content="http://i.imgur.com/2ejIZu1.jpg">
<meta property="og:image" content="http://i.imgur.com/6iYnFgF.jpg">
<meta property="og:image" content="http://i.imgur.com/0OmstJz.jpg">
<meta property="og:image" content="http://yoursite.com/img/opSystem/forth/1.jpg">
<meta property="og:image" content="http://i.imgur.com/vl6oxdi.jpg">
<meta property="og:image" content="http://i.imgur.com/ifkpI4v.jpg">
<meta property="og:image" content="http://i.imgur.com/kiLLuu6.jpg">
<meta property="og:image" content="http://i.imgur.com/XM6g4tn.jpg">
<meta property="og:image" content="http://i.imgur.com/6CmUVag.jpg">
<meta property="og:image" content="http://i.imgur.com/QRMKEIh.jpg">
<meta property="og:image" content="http://i.imgur.com/EZuWkXa.jpg">
<meta property="og:image" content="http://i.imgur.com/uNs6069.jpg">
<meta property="og:image" content="http://i.imgur.com/gHeUaSg.jpg">
<meta property="og:image" content="http://i.imgur.com/06aIUmm.jpg">
<meta property="og:image" content="http://i.imgur.com/fwqMmfW.jpg">
<meta property="og:image" content="http://i.imgur.com/AjKr58E.jpg">
<meta property="og:image" content="http://i.imgur.com/o03xMIo.jpg">
<meta property="og:image" content="http://i.imgur.com/OKGbAYs.jpg">
<meta property="og:image" content="http://i.imgur.com/Eb0yzM5.jpg">
<meta property="og:image" content="http://i.imgur.com/kA8DNSC.jpg">
<meta property="og:image" content="http://i.imgur.com/MI0JAbj.jpg">
<meta property="og:image" content="http://i.imgur.com/0nN34dY.jpg">
<meta property="og:image" content="http://i.imgur.com/4Hqqs1l.jpg">
<meta property="og:image" content="http://i.imgur.com/8FUbFg0.jpg">
<meta property="og:image" content="http://i.imgur.com/GOJkOch.jpg">
<meta property="og:image" content="http://i.imgur.com/bwTuSX2.jpg">
<meta property="og:image" content="http://i.imgur.com/4Qe5Ut6.jpg">
<meta property="og:image" content="http://i.imgur.com/Vdvkwx9.jpg">
<meta property="og:image" content="http://i.imgur.com/gNoHuJY.jpg">
<meta property="og:image" content="http://i.imgur.com/Rg72VgG.jpg">
<meta property="og:image" content="http://i.imgur.com/AW2wlam.jpg">
<meta property="og:image" content="http://i.imgur.com/GtUXSRh.jpg">
<meta property="og:image" content="http://i.imgur.com/GBifhov.jpg">
<meta property="og:image" content="http://i.imgur.com/R4BJHEK.jpg">
<meta property="og:image" content="http://i.imgur.com/nMnv3Lr.jpg">
<meta property="og:image" content="http://i.imgur.com/GcKk41q.jpg">
<meta property="og:image" content="http://i.imgur.com/seqF0Kr.jpg">
<meta property="og:image" content="http://i.imgur.com/o8Z7jBy.jpg">
<meta property="og:image" content="http://i.imgur.com/TF590Yi.jpg">
<meta property="og:image" content="http://i.imgur.com/NjeyTDR.jpg">
<meta property="og:image" content="http://i.imgur.com/hXiBAwP.jpg">
<meta property="og:image" content="http://i.imgur.com/u0UATB2.jpg">
<meta property="og:image" content="http://i.imgur.com/wZApwUZ.jpg">
<meta property="og:image" content="http://i.imgur.com/UfGf1qL.jpg">
<meta property="og:image" content="http://i.imgur.com/P69ab36.jpg">
<meta property="og:image" content="http://i.imgur.com/kZqpNzz.jpg">
<meta property="og:image" content="http://i.imgur.com/cbpVl9o.jpg">
<meta property="og:image" content="http://i.imgur.com/4Gmd9k9.jpg">
<meta property="og:image" content="http://i.imgur.com/og7vCy9.jpg">
<meta property="og:image" content="http://i.imgur.com/OxfPaj9.jpg">
<meta property="og:image" content="http://i.imgur.com/fU0A0n1.jpg">
<meta property="og:image" content="http://i.imgur.com/Z8oBZSM.jpg">
<meta property="og:image" content="http://i.imgur.com/rraj0Tg.jpg">
<meta property="og:image" content="http://i.imgur.com/Gx80llz.jpg">
<meta property="og:image" content="http://i.imgur.com/uEkZTqR.jpg">
<meta property="og:image" content="http://i.imgur.com/HpAfESH.jpg">
<meta property="og:image" content="http://i.imgur.com/t7FqtDl.jpg">
<meta property="og:image" content="http://i.imgur.com/Pod6xY5.jpg">
<meta property="og:image" content="http://i.imgur.com/hPpR6D8.jpg">
<meta property="og:image" content="http://i.imgur.com/cBBl8TE.jpg">
<meta property="og:image" content="http://i.imgur.com/elBrrzN.jpg">
<meta property="og:image" content="http://i.imgur.com/FtzqVa1.jpg">
<meta property="og:image" content="http://i.imgur.com/zborPzO.jpg">
<meta property="og:image" content="http://i.imgur.com/JxZK6r8.jpg">
<meta property="og:image" content="http://i.imgur.com/d42pFgT.jpg">
<meta property="og:image" content="http://i.imgur.com/EvVlCQR.jpg">
<meta property="og:image" content="http://i.imgur.com/cT9MlgX.jpg">
<meta property="og:image" content="http://i.imgur.com/oJpAh57.jpg">
<meta property="og:image" content="http://i.imgur.com/zeI9sce.jpg">
<meta property="og:image" content="http://i.imgur.com/HXAthY5.jpg">
<meta property="og:image" content="http://i.imgur.com/dyAyDXB.jpg">
<meta property="og:image" content="http://i.imgur.com/8HmEBKU.jpg">
<meta property="og:image" content="http://i.imgur.com/6BcN6Yq.jpg">
<meta property="og:image" content="http://i.imgur.com/zFvbSW0.jpg">
<meta property="og:image" content="http://i.imgur.com/cFD0BTq.jpg">
<meta property="og:image" content="http://i.imgur.com/WdrBNlK.jpg">
<meta property="og:image" content="http://i.imgur.com/W84CYYD.jpg">
<meta property="og:image" content="http://i.imgur.com/dFXYIHM.jpg">
<meta property="og:image" content="http://i.imgur.com/6Q1OUHB.jpg">
<meta property="og:image" content="http://i.imgur.com/AE7e0jn.jpg">
<meta property="og:image" content="http://i.imgur.com/tISM41l.jpg">
<meta property="og:image" content="http://i.imgur.com/1ZODV8H.jpg">
<meta property="og:image" content="http://i.imgur.com/aeoMgze.jpg">
<meta property="og:image" content="http://i.imgur.com/V4GAMsS.jpg">
<meta property="og:image" content="http://i.imgur.com/sy1vNWg.jpg">
<meta property="og:image" content="http://i.imgur.com/pUhPOp8.jpg">
<meta property="og:image" content="http://i.imgur.com/HiwHH5I.jpg">
<meta property="og:image" content="http://i.imgur.com/r2Um1j1.jpg">
<meta property="og:image" content="http://i.imgur.com/0bSWgxc.jpg">
<meta property="og:image" content="http://i.imgur.com/0XhFMmd.jpg">
<meta property="og:image" content="http://i.imgur.com/ne8R5P7.jpg">
<meta property="og:image" content="http://i.imgur.com/cvaaipU.jpg">
<meta property="og:image" content="http://i.imgur.com/0cTg2Hz.jpg">
<meta property="og:image" content="http://i.imgur.com/PmmyzaM.jpg">
<meta property="og:image" content="http://i.imgur.com/GInbPIl.jpg">
<meta property="og:image" content="http://i.imgur.com/dEFMsFV.jpg">
<meta property="og:image" content="http://i.imgur.com/cVKm03X.jpg">
<meta property="og:image" content="http://i.imgur.com/GMauPrZ.jpg">
<meta property="og:image" content="http://i.imgur.com/5WYcjiP.jpg">
<meta property="og:image" content="http://i.imgur.com/Qi79YU9.jpg">
<meta property="og:image" content="http://i.imgur.com/nDBF9Ba.jpg">
<meta property="og:image" content="http://i.imgur.com/HX2pl0F.jpg">
<meta property="og:image" content="http://i.imgur.com/nBH0yIj.jpg">
<meta property="og:updated_time" content="2017-04-05T06:49:52.012Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统">
<meta name="twitter:description" content="操作系统">
<meta name="twitter:image" content="http://i.imgur.com/Md58ooA.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/03/21/基础课程系列/操作系统/"/>





  <title> 操作系统 | Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/21/基础课程系列/操作系统/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                操作系统
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-21T15:06:07+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>操作系统<br><a id="more"></a> </p>
<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h2 id="操作系统做了什么？"><a href="#操作系统做了什么？" class="headerlink" title="操作系统做了什么？"></a>操作系统做了什么？</h2><pre><code>#include &lt;stdio.h&gt; int main(int argc, char *argv[]) { 
puts(&quot;hello world&quot;); return 0; 
}
</code></pre><hr>
<pre><code>1. 用户告诉操作系统执行helloworld程序(如何告知？)  
2. 操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址（文件格式？）   
3. 操作系统：创建一个新的进程，并将helloworld可执行文件映射到该进程结构，表示由该进程执行helloworld程序  
4. 操作系统：为helloworld程序设置CPU上下文环境，并跳到程序开始处（假设调度程序选中hello程序）  
5. 执行helloworld程序的第一条指令，发生缺页异常  
6. 操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序   
7. helloworld程序执行puts函数（系统调用），在显示器上写一字符串   
8. 操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程  
9. 操作系统：控制设备的进程告诉设备的窗口系统它要显示字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区  
10. 视频硬件将像素转换成显示器可接收的一组控制/数据信号  
11. 显示器解释信号，激发液晶屏  
12. OK！！！我们在屏幕上看到了“hello world”
</code></pre><h3 id="从上述步骤中得到了什么"><a href="#从上述步骤中得到了什么" class="headerlink" title="从上述步骤中得到了什么"></a>从上述步骤中得到了什么</h3><p>os进程与用户程序的切换  </p>
<h3 id="换个角度看用户程序的执行"><a href="#换个角度看用户程序的执行" class="headerlink" title="换个角度看用户程序的执行"></a>换个角度看用户程序的执行</h3><h2 id="操作系统的定义与作用"><a href="#操作系统的定义与作用" class="headerlink" title="操作系统的定义与作用"></a>操作系统的定义与作用</h2><h3 id="操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——"><a href="#操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——" class="headerlink" title="操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——"></a>操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——</h3><ul>
<li>它们能以尽量有效、合理的方式组织和管理计算机的软硬件资源  </li>
<li>合理地组织计算机的工作 流程，控制程序的执行并向用户提供各种服务功能  </li>
<li><p>使得用户能够灵活、方便地使用计算机，使整个计算机系统高效率运行  </p>
<h3 id="几个关键词"><a href="#几个关键词" class="headerlink" title="几个关键词"></a>几个关键词</h3><p>  有效：系统效率，资源利用率</p>
<pre><code>CPU利用率充足与否？I/O设备是否忙碌？
</code></pre><p>  合理：</p>
<pre><code>各种软硬件资源的管理是否公平合理
如果不公平、不合理，则可能会产生问题？
</code></pre><p>  方便使用：</p>
<pre><code>两种角度：用户界面 与 编程接口
</code></pre><h3 id="三个作用"><a href="#三个作用" class="headerlink" title="三个作用"></a>三个作用</h3><h4 id="资源的管理者"><a href="#资源的管理者" class="headerlink" title="资源的管理者"></a>资源的管理者</h4><p>自底向上 硬件资源：软件资源：<br><strong>怎样管理资源</strong><br><pre><br>跟踪记录资源的使用状况，如：哪些资源空闲，分配给谁使用，允许使用多长时间等<br>确定资源分配策略——算法：静态分配策略，动态分配策略<br>实施资源的分配和回收<br>提高资源利用率<br>保护资源的使用<br>协调多个进程对资源请求的冲突<br></pre><br><strong>五大基本功能</strong>  </p>
<p>  进程/线程管理（CPU管理）</p>
<pre><code>进程线程状态、控制、同步互斥、通信、调度、……
</code></pre><p>  存储管理</p>
<pre><code>分配/回收、地址转换、存储保护、内存扩充、……
</code></pre><p>  文件管理</p>
<pre><code>文件目录、文件操作、磁盘空间、文件存取控制、……
</code></pre><p>  设备管理</p>
<pre><code>设备驱动、分配回收、缓冲技术、……
</code></pre><p>  用户接口</p>
<pre><code>系统命令、编程接口
</code></pre><h4 id="各种系统服务的提供者"><a href="#各种系统服务的提供者" class="headerlink" title="各种系统服务的提供者"></a>各种系统服务的提供者</h4><p>  在操作系统之上，从用户角度来看：</p>
<pre><code>操作系统为用户提供了一组功能强大、方便易用的命令或系统调用
</code></pre><p>  典型的服务</p>
<pre><code>进程的创建、执行；文件和目录的操作；I/O设备的使用；各类统计信息；……
</code></pre><h4 id="对硬件机器的扩展"><a href="#对硬件机器的扩展" class="headerlink" title="对硬件机器的扩展"></a>对硬件机器的扩展</h4><p>  操作系统在应用程序与硬件之间建立了一个等价的扩展机器（虚拟机）<br>  对硬件抽象，提高可移植性；比底层硬件更容易编程</p>
</li>
</ul>
<p>由面向底层变成了面向操作系统编程</p>
<h2 id="操作系统的主要特征"><a href="#操作系统的主要特征" class="headerlink" title="操作系统的主要特征"></a>操作系统的主要特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发(concurrency)：指处理多个同时性活动的能力  </p>
<pre><code>由于并发将会引发很多的问题：
    活动切换、保护、相互依赖的活动间的同步
在计算机系统中同时存在多个程序运行，单CPU上
    宏观上：这些程序同时在执行
    微观上：任何时刻只有一个程序真正在执行，即这些程序在CPU上是轮流执行的
并行(parallel)：与并发相似，但多指不同程序同时在多个硬件部件上执行
</code></pre><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><pre><code>共享(sharing)：
    操作系统与多个用户的程序共同使用计算机系统中的资源（共享有限的系统资源）
    操作系统要对系统资源进行合理分配和使用
    资源在一个时间段内交替被多个进程所用
互斥共享（如打印机）
同时共享（如可重入代码、磁盘文件）

问题：资源分配难以达到最优化，如何保护资源
</code></pre><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>一个物理实体映射为若干个对应的逻辑实体－－分时或分空间<br>虚拟是操作系统管理系统资源的重要手段，可提高资源利用率  </p>
<pre><code>CPU－－每个进程的&quot;虚处理机&quot;
存储器－－每个进程都有独立的虚拟地址空间（代码＋数据＋堆栈）
显示设备－－多窗口或虚拟终端
</code></pre><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>操作系统必须随时对以不可预测的次序发生的事件进行响应并处理</p>
<h2 id="典型操作系统的架构"><a href="#典型操作系统的架构" class="headerlink" title="典型操作系统的架构"></a>典型操作系统的架构</h2><h3 id="Windows架构"><a href="#Windows架构" class="headerlink" title="Windows架构"></a>Windows架构</h3><p>用户态：系统进程，服务进程，用户进程，环境子系统，动态链接库<br>内核态：系统服务分发器，内核态可调用接口，执行体，内核，设备驱动驱动程序，硬件抽象层，图形与窗口<br>物理硬件：硬件</p>
<h3 id="UNIX架构"><a href="#UNIX架构" class="headerlink" title="UNIX架构"></a>UNIX架构</h3><p>用户态：系统调用接口<br>内核态：进程控制子系统，文件系统，设备驱动程序（块设备，字符系统），硬件控制层，系统调用接口</p>
<h3 id="linux内核组间"><a href="#linux内核组间" class="headerlink" title="linux内核组间"></a>linux内核组间</h3><p>内核态：进程调度，文件系统，设备驱动程序，网络服务</p>
<h2 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h2><h3 id="操作系统的发展历程"><a href="#操作系统的发展历程" class="headerlink" title="操作系统的发展历程"></a>操作系统的发展历程</h3><p>操作系统发展是随着计算机硬件技术、应用需求的发展、软件新技术的出现而发展的</p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>充分利用硬件<br>提供更好的服务  </p>
<h3 id="传统操作系统的分类"><a href="#传统操作系统的分类" class="headerlink" title="传统操作系统的分类"></a>传统操作系统的分类</h3><p>批处理操作系统<br>分时系统<br>实时操作系统<br>个人计算机操作系统<br>网络操作系统<br>分布式操作系统<br>嵌入式操作系统  </p>
<h4 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h4><ol>
<li>用户将作业交给系统操作员  </li>
<li>系统操作员将许多用户的作业组成一批作业，输入到计算机系统中，在系统中形成一个自动转接的连续的作业流  </li>
<li>启动操作系统  </li>
<li>系统自动、依次执行每个作业  </li>
<li>由操作员将作业结果交给用户  </li>
</ol>
<hr>
<p>目标：提高资源利用率，增加作业处理吞吐量  </p>
<hr>
<pre><code>批处理系统中的作业包括： 
1. 用户程序  
2. 数据  
3. 作业说明书（用作业控制语言编写）
</code></pre><hr>
<p> 成批：通常由若干个作业组成，用户提交作业后只能等待处理结果，不能干预自己作业的执行</p>
<hr>
<p>批作业处理：<br>对一批作业中的每个作业进行相同的处理：从磁带读入用户作业和编译链接程序，编译链接用户作业以生成可执行程序；启动执行；执行并输出结果  </p>
<hr>
<pre><code>问题：慢速的输入输出处理直接由主机来完成，输入输出时，CPU处于等待状态  
解决方案：卫星机：完成面向用户的输入输出（纸带或卡片），中间结果暂存在磁带或磁盘上
</code></pre><hr>
<pre><code>SPOOLING系統（技術）  
利用磁盘作缓冲，将输入、计算、输出分别组织成独立的任务流，使I/O和计算真正并行  
工作原理：  
用户作业加载到磁盘上的输入井
按某种调度策略选择几个搭配得当的作业，调入内存
作业运行的结果输出到磁盘上的输出井
运行结果从磁盘上的输出井送到打印机 
</code></pre><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><pre><code>操作系统将CPU的时间划分成若干个片段，称为时间片
    操作系统以时间片为单位，轮流为每个终端用户服务，每次服务一个时间片
    其特点是利用人的错觉，使用户感觉不到计算机在服务他人
</code></pre><hr>
<pre><code>追求目标：
    及时响应(依据是响应时间)
响应时间：
    从终端发出命令到系统给予回答所经历的时间
</code></pre><h4 id="通过操作系统"><a href="#通过操作系统" class="headerlink" title="通过操作系统"></a>通过操作系统</h4><p>分时系统与批处理系统结合  </p>
<hr>
<pre><code>原则：分时优先，批处理在后
“前台”：需要频繁交互的作业
“后台”：时间性要求不强的作业
</code></pre><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>是指使计算机能及时响应外部事件的请求，在规定的严格时间内完成对该事件的处理，并控制所有实时设备和实时任务协调一致地工作</p>
<hr>
<pre><code>分类：
    第一类：实时过程控制
        工业控制、航空、军事控制、...
    第二类：实时通信（信息）处理
        电讯（自动交换机）、银行、飞机订票、股市行情
</code></pre><hr>
<pre><code>追求目标：
    对外部请求在严格时间范围内作出响应
    高可靠性
</code></pre><hr>
<p>硬实时系统<br>软实时系统</p>
<h4 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h4><p>计算机在某一时间内为单用户服务</p>
<hr>
<pre><code>追求目标：
    界面友好，使用方便
    丰富的应用软件
</code></pre><h4 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h4><pre><code>基于计算机网络
    在各种计算机操作系统上
        按网络体系结构协议标准开发的软件
功能：
    网络管理，通信，安全，资源共享和各种网络应用
追求目标：相互通信，资源共享
</code></pre><h4 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h4><pre><code>分布式系统：或以计算机网络为基础，或以多处理机为基础，基本特征是处理分布在不同计算机上

分布式操作系统：是一个统一的操作系统，允许若干个计算机可相互协作共同完成一项任务。操作系统可将各种系统任务在分布式系统中任何处理机上运行，自动实现全系统范围内的任务分配、自动调度、均衡各处理机的工作负载

处理能力增强、速度更快、可靠性增强、具有透明性
</code></pre><h4 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h4><pre><code>嵌入式系统
    在各种设备、装置或系统中，完成特定功能的软硬件系统汽车、手机、电视机、MP3播放器
    它们是一个大设备、装置或系统中的一部分，这个大设备、装置或系统可以不是“计算机”
    通常工作在反应式或对处理时间有较严格要求环境中

嵌入式操作系统（Embedded Operating System）
    运行在嵌入式系统环境中，对整个嵌入式系统以及它所操作、控制的各种部件装置等等资源进行统一协调、调度、指挥和控制的系统软件
</code></pre><h4 id="智能卡操作系统"><a href="#智能卡操作系统" class="headerlink" title="智能卡操作系统"></a>智能卡操作系统</h4><pre><code>智能卡：一种包含有一块CPU芯片的卡片
特点
    非常严格的运行能耗和存储空间的限制
    有些智能卡只有单项功能，诸如电子支付
专用的操作系统  

有些智能卡是面向Java的，即在智能卡的ROM中有一个Java虚拟机解释器。Java 程序被下载到卡中并由JVM解释器解释。有些卡可以同时处理多个Java 小程序，这就是多道程序，并且需要对它们进行调度。在两个或多个小程序同时运行时，资源管理和保护就成为突出的问题。这些问题必须由卡上的操作系统处理
</code></pre><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><pre><code>重点阅读教材
    第1章相关内容：1.1、1.2、1.4
    第10章相关内容：10.2.5
    第11章相关内容：11.3.1.

重点概念
    操作系统定义 操作系统的三个作用
    并发 共享 虚拟 随机 SPOOLing技术 Windows、Linux、UNIX的架构
</code></pre><h1 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h1><h2 id="处理器状态"><a href="#处理器状态" class="headerlink" title="处理器状态"></a>处理器状态</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>处理器由运算器、控制器、一系列的寄存器以及高速缓存构成  </p>
<pre><code>两类寄存器：
    用户可见寄存器：高级语言编译器通过优化算法分配并使用之，以减少程序访问内存次数
    控制和状态寄存器：用于控制处理器的操作
                        通常由操作系统代码使用
</code></pre><h4 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h4><p>用于控制处理器的操作<br>在某种特权级别下可以访问、修改  </p>
<pre><code>常见的控制和状态寄存器
    程序计数器（PC：Program Counter），记录将要取出的指令的地址
    指令寄存器（IR：Instruction Register），记录最近取出的指令
    程序状态字（PSW：Program Status Word），记录处理器的运行状态如条件码、模式、控制位等信息
</code></pre><h3 id="操作系统的需求，保护"><a href="#操作系统的需求，保护" class="headerlink" title="操作系统的需求，保护"></a>操作系统的需求，保护</h3><p>从操作系统的特征考虑<br>并发、共享<br>提出要求 → 实现保护与控制  </p>
<pre><code>需要硬件提供基本运行机制：
    处理器具有特权级别，能在不同的特权级运行的不同指令集合
     硬件机制可将OS与用户程序隔离
</code></pre><h3 id="处理器的状态"><a href="#处理器的状态" class="headerlink" title="处理器的状态"></a>处理器的状态</h3><p>现代处理器通常将CPU状态设计划分为两种、三种或四种<br>在程序状态字寄存器PSW中专门设置一位，根据运行程序对资源和指令的使用权限而设置不同的CPU状态  </p>
<h3 id="特权指令和非特权指令"><a href="#特权指令和非特权指令" class="headerlink" title="特权指令和非特权指令"></a>特权指令和非特权指令</h3><pre><code>操作系统需要两种CPU状态
    内核态(Kernel Mode)：运行操作系统程序
    用户态(User Mode)：运行用户程序
</code></pre><hr>
<p>特权(privilege)指令：只能由操作系统使用、用户程序不能使用的指令<br>非特权指令：用户程序可以使用的指令</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>X86支持4个处理器特权级别<br>特权环：R0、R1、R2和R3  </p>
<pre><code>从R0到R3，特权能力由高到低
    R0相当于内核态；R3相当于用户态；R1和R2则介于两者之间
    不同级别能够运行的指令集合不同
</code></pre><p>目前大多数基于x86处理器的操作系统<br>只用了R0和R3两个特权级别</p>
<h3 id="CPU状态之间的转换"><a href="#CPU状态之间的转换" class="headerlink" title="CPU状态之间的转换"></a>CPU状态之间的转换</h3><pre><code>用户态 → 内核态
    唯一途径 → 中断/异常/陷入机制
内核态 → 用户态
    设置程序状态字PSW
</code></pre><hr>
<pre><code>一条特殊的指令：陷入指令（又称访管指令）
    提供给用户程序的接口，用于调用操作系统的功能（服务）
    例如：int，trap，syscall，sysenter/sysexit
</code></pre><h2 id="中断和异常机制"><a href="#中断和异常机制" class="headerlink" title="中断和异常机制"></a>中断和异常机制</h2><pre><code>中断/异常 对于操作系统的重要性
    就好比：汽车的发动机、飞机的引擎
→→ 可以说 操作系统
    是由“中断驱动”或者 “事件驱动”的
</code></pre><hr>
<pre><code>主要作用
    及时处理设备发来的中断请求
    可使OS捕获用户程序提出的服务请求
    防止用户程序执行过程中的破坏性活动
    … … 等等
</code></pre><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>CPU对系统发生的某个事件作出的一种反应<br>CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序  </p>
<pre><code>特点：
•是随机发生的
•是自动处理的
•是可恢复的

事件的发生改变了处理器的控制流
</code></pre><h3 id="为什么引入中断与异常"><a href="#为什么引入中断与异常" class="headerlink" title="为什么引入中断与异常"></a>为什么引入中断与异常</h3><pre><code>中断的引入：为了支持CPU和设备之间的并行操作
    当CPU启动设备进行输入/输出后，设备便可以独立工作，CPU转去处理与此次输入/输出不相关的事情；
    当设备完成输入/输出后，通过向CPU发中断报告此次输入/输出的结果，让CPU决定如何处理以后的事情

异常的引入：表示CPU执行指令时本身出现的问题
    如算术溢出、除零、取数时的奇偶错，访存地址时越界或执行了“陷入指令” 等，
    这时硬件改变了CPU当前的执行流程，转到相应的错误处理程序或异常处理程序或执行系统调用
</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>中断：外部事件，正在运行的程序所不期望的<br>异常：由正在执行的指令引发  </p>
<pre><code>中断(外中断)
    I/O中断
    时钟中断
    硬件故障

异常(内中断)
    系统调用
    页故障/页错误
    保护性异常
    断点指令
    其他程序性异常
    (如算术溢出等)
</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>类别        原因                        异步/同步        返回行为
中断
Interrupt    来自I/O设备、其他硬件部件    异步            总是返回到下一条指令
陷入Trap    有意识安排的                  同步            返回到下一条指令

故障Fault    可恢复的错误                  同步            返回到当前指令

终止Abort    不可恢复的错误                 同步            不会返回
</code></pre><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>中断/异常机制是现代计算机系统的核心机制之一<br>硬件和软件相互配合而使计算机系统得以充分发挥能力</p>
<hr>
<pre><code>硬件该做什么事？ —— 中断/异常响应
    捕获中断源发出的中断/异常请求，以一定方式响应，将处理器控制权交给特定的处理程序
软件要做什么事？ —— 中断/异常处理程序
    识别中断/异常类型并完成相应的处理
</code></pre><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><pre><code>中断响应：
     发现中断、接收中断的过程
     由中断硬件部件完成
</code></pre><h4 id="过程示意"><a href="#过程示意" class="headerlink" title="过程示意"></a>过程示意</h4><p>开始-&gt;取下一条指令-&gt;执行指令-&gt;检查指令-&gt;处理中断</p>
<hr>
<pre><code>在每条指令执行周期的最后时刻扫描中断寄存器，查看是否有中断信号？
若有中断，中断硬件将该中断触发器内容按规定编码送入PSW的相应位，称为中断码，通过查中断向量表引出中断处理程序
若无中断信号，继续执行下一条指令
</code></pre><h4 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h4><pre><code>中断向量：
    一个内存单元，存放中断处理程序入口地址和程序运行时所需的处理机状态字
</code></pre><hr>
<p>执行流程按中断号/异常类型的不同，通过中断向量表<br>转移控制权给中断处理程序<br>中断向量表<br>中断处理程序</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><pre><code>1. 设备发中断信号
2. 硬件保存现场
3. 根据中断码查表
4. 把中断处理程序入口地址等推送到相应的寄存器
5. 执行中断处理程序
</code></pre><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>设计操作系统时，为每一类中断/异常事件编好相应的处理程序，并设置好中断向量表  </p>
<pre><code>系统运行时若响应中断，中断硬件部件将CPU控制权转给中断处理程序：
    保存相关寄存器信息
    分析中断/异常的具体原因
    执行对应的处理功能
    恢复现场，返回被事件打断的程序
</code></pre><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><pre><code>以设备输入输出中断为例： 
    打印机给CPU发中断信号
    CPU处理完当前指令后检测到中断，判断出中断来源并向相关设备发确认信号

    CPU开始为软件处理中断做准备：
        处理器状态被切换到内核态
        在系统栈中保存被中断程序的重要上下文环境，主要是程序计数器PC、程序状态字PSW

    PU根据中断码查中断向量表，获得与该中断相关的处理程序的入口地址，并将PC设置成该地址，新的指令周期开始时，CPU控制转移到中断处理程序

    中断处理程序开始工作
        在系统栈中保存现场信息
        检查I/O设备的状态信息，操纵I/O设备或者在设备和内存之间传送数据等等

    中断处理结束时，CPU检测到中断返回指令，从系统栈中恢复被中断程序的上下文环境 ，CPU状态恢复成原来的状态，PSW和PC恢复成中断前的值，CPU开始一个新的指令周期
</code></pre><hr>
<pre><code>I/O中断处理程序
通常分为两类处理：

    I/O操作正常结束
        若有程序正等待此次I/O的结果，则应将其唤醒
        若要继续I/O操作，需要准备好数据重新启动I/O

    I/O操作出现错误
        需要重新执行失败的I/O操作
        重试次数有上限，达到时系统将判定硬件故障
</code></pre><h2 id="实例：x86处理器"><a href="#实例：x86处理器" class="headerlink" title="实例：x86处理器"></a>实例：x86处理器</h2><pre><code>中断
    由硬件信号引发的，分为可屏蔽和不可屏蔽中断
异常
    由指令执行引发的，比如除零异常
    80x86处理器发布了大约20种不同的异常
    对于某些异常，CPU会在执行异常处理程序之前产生硬件出错码，并压入内核态堆栈
系统调用
    异常的一种，用户态到内核态的唯一入口
</code></pre><h2 id="x86处理器对中断的支持"><a href="#x86处理器对中断的支持" class="headerlink" title="x86处理器对中断的支持"></a>x86处理器对中断的支持</h2><pre><code>中断控制器（PIC或APIC）
    负责将硬件的中断信号转换为中断向量，并引发CPU中断

实模式：中断向量表 (Interrupt Vector)
    存放中断服务程序的入口地址
        入口地址＝段地址左移4位＋偏移地址
        不支持CPU运行状态切换
        中断处理与一般的过程调用相似

保护模式：中断描述符表 (Interrupt Descriptor Table)
    采用门(gate) 描述符数据结构表示中断向量
</code></pre><hr>
<pre><code>中断向量表/中断描述符表
    四种类型门描述符
        任务门(Task Gate)
        中断门(Interrupt Gate)
            给出段选择符 (Segment Selector)、中断/异常程序的段内偏移量 (Offset)
            通过中断门后系统会自动禁止中断
        陷阱门(Trap Gate)
            与中断门类似，但通过陷阱门后系统不会自动禁止中断
        调用门(Call Gate)
</code></pre><hr>
<pre><code>中断/异常的硬件处理过程：
    确定与中断或异常关联的向量i
    通过IDTR寄存器找到IDT表，获得中断描述符（表中的第i项）
    从GDTR寄存器获得GDT的地址；结合中断描述符中的段选择符，在GDT表获取对应的段描述符；从该段描述符中得到中断或异常处理程序所在的段基址
    特权级检查
</code></pre><hr>
<pre><code>检查是否发生了特权级的变化，如果是，则进行堆栈切换(必须使用与新的特权级相关的栈)
硬件压栈，保存上下文环境；如果异常产生了硬件出错码，也将它保存在栈中
如果是中断，清IF位
通过中断描述符中的段内偏移量和段描述符中的基地址，找到中断/异常处理程序的入口地址，执行其第一条指令
</code></pre><h2 id="系统调用机制"><a href="#系统调用机制" class="headerlink" title="系统调用机制"></a>系统调用机制</h2><pre><code>系统调用：用户在编程时可以调用的操作系统功能
</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><pre><code>系统调用是操作系统提供给编程人员的唯一接口
使CPU状态从用户态陷入内核态
</code></pre><h3 id="典型系统调用"><a href="#典型系统调用" class="headerlink" title="典型系统调用"></a>典型系统调用</h3><pre><code>每个操作系统都提供几百种系统调用（进程控制、进程通信、文件使用、目录操作、设备管理、信息维护等）
</code></pre><h3 id="系统调用机制的设计"><a href="#系统调用机制的设计" class="headerlink" title="系统调用机制的设计"></a>系统调用机制的设计</h3><pre><code>中断/异常机制
    支持系统调用服务的实现
选择一条特殊指令：陷入指令(亦称访管指令)
    引发异常，完成用户态到内核态的切换
系统调用号和参数 
    每个系统调用都事先给定一个编号(功能号)
    编译器也会参与
系统调用表
    存放系统调用服务例程的入口地址
</code></pre><h3 id="参数传递过程问题"><a href="#参数传递过程问题" class="headerlink" title="参数传递过程问题"></a>参数传递过程问题</h3><pre><code>怎样实现用户程序的参数传递给内核？

常用的3种实现方法：
    由陷入指令自带参数：陷入指令的长度有限，且还要携带系统调用功
    能号，只能自带有限的参数
    通过通用寄存器传递参数：这些寄存器是操作系统和用户程序都能访
    问的，但寄存器的个数会限制传递参数的数量
    在内存中开辟专用堆栈区来传递参数
</code></pre><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><pre><code>当CPU执行到特殊的陷入指令时：  
    中断/异常机制：硬件保护现场；通过查中断向量表把控制权转给系统调用总入口程序
    系统调用总入口程序：保存现场；将参数保存在内核堆栈里；通过查系统调用表把控制权转给相应的系统调用处理例程或内核函数
    执行系统调用例程
    恢复现场，返回用户程序
</code></pre><h2 id="基于x86处理器的linux的系统调用实现"><a href="#基于x86处理器的linux的系统调用实现" class="headerlink" title="基于x86处理器的linux的系统调用实现"></a>基于x86处理器的linux的系统调用实现</h2><pre><code>陷入指令选择128号
    int $0x80
</code></pre><hr>
<pre><code>门描述符
    系统初始化时：对IDT表中的128号门初始化
    门描述符的2、3两个字节：内核代码段选择符
    0、1、6、7四个字节：偏移量（指向system_call()）
    门类型：15，陷阱门，为什么？执行系统调用的过程中，还接收中断
    DPL：3，与用户级别相同，允许用户进程使用该门描述符
</code></pre><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><pre><code>由于特权级的改变，要切换栈
    用户栈 → 内核栈
    CPU从任务状态段TSS中装入新的栈指针（SS︰ESP），指向内核栈

内核栈
    用户栈的信息（SS︰ESP）、EFLAGS、用户态CS 、EIP 寄存器的内容压栈（返回用）
    将EFLAGS压栈后，复位TF，IF位保持不变
    用128在IDT中找到该门描述符，从中找出段选择符装入代码段寄存器CS
    代码段描述符中的基地址 + 陷阱门描述符中的偏移量 → 定位 system_call()的入口地址
</code></pre><h3 id="调用执行流程"><a href="#调用执行流程" class="headerlink" title="调用执行流程"></a>调用执行流程</h3><p>应用程序-&gt;封装例程-&gt;陷入处理-&gt;内核函数-&gt;</p>
<h3 id="OS底层工作步骤"><a href="#OS底层工作步骤" class="headerlink" title="OS底层工作步骤"></a>OS底层工作步骤</h3><pre><code>1. 硬件压栈：程序计数器等
2. 硬件从中断向量装入新的程序计数器等
3. 汇编语言过程保存寄存器值
4. 汇编语言过程设置新的堆栈
5. C语言中断服务程序运行（例：读并缓冲输入）
6. 进程调度程序决定下一个将运行的进程
7. C语言过程返回至汇编代码
8. 汇编语言过程开始运行新的当前进程
</code></pre><h2 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h2><pre><code>理解计算机系统的保护机制
    掌握处理器状态
    掌握特权指令与非特权指令
掌握中断/异常机制
    掌握中断/异常的基本概念
    理解中断/异常机制的工作原理
掌握系统调用机制
    掌握系统调用设计原理
    掌握系统调用执行过程
</code></pre><hr>
<pre><code>重点阅读教材
    第1章相关内容：1.3、1.6
    第2章 第52页 图2-5及说明该图思路的段落
重点概念
    CPU状态 内核态/用户态 特权指令/非特权指令
    中断 异常 中断响应 中断向量 中断处理程序
    系统调用 陷入指令 系统调用号 系统调用表
</code></pre><h1 id="进程-线程模型"><a href="#进程-线程模型" class="headerlink" title="进程/线程模型"></a>进程/线程模型</h1><h2 id="进程基本概念"><a href="#进程基本概念" class="headerlink" title="进程基本概念"></a>进程基本概念</h2><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><pre><code>多道程序设计
    允许多个程序同时进入内存并运行，其目的是为了提高系统效率
</code></pre><h3 id="并发环境与并发程序"><a href="#并发环境与并发程序" class="headerlink" title="并发环境与并发程序"></a>并发环境与并发程序</h3><pre><code>并发环境：
        一段时间间隔内，单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态，并且次序不是事先确定的

并发程序：在并发环境中执行的程序
</code></pre><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><pre><code>定义：Process
    进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位
又称 任务（Task or Job）
</code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre><code>程序的一次执行过程
是正在运行程序的抽象
将一个CPU变幻成多个虚拟的CPU
系统资源以进程为单位分配，如内存、文件、……
    每个具有独立的地址空间
操作系统将CPU调度给需要的进程
</code></pre><h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><pre><code>PCB：Process Control Block
    又称 进程描述符、进程属性
    操作系统用于管理控制进程的一个专门数据结构
    记录进程的各种属性，描述进程的动态变化过程

PCB是系统感知进程存在的唯一标志
    → 进程与PCB是一一对应的

进程表：所有进程的PCB集合
</code></pre><hr>
<pre><code>进程描述信息
    进程标识符(process ID)，唯一，通常是一个整数
    进程名，通常基于可执行文件名，不唯一
    用户标识符(user ID)
    进程组关系

当前状态
    优先级(priority)
    代码执行入口地址
    程序的磁盘地址
    运行统计信息(执行时间、页面调度)
    进程间同步和通信
    进程的队列指针
    进程的消息队列指针

所拥有的资源和使用情况
    虚拟地址空间的状况
    打开文件列表

CPU现场信息
    寄存器值(通用寄存器、程序计数器PC、程序状态字PSW、栈指针)
    指向该进程页表的指针
</code></pre><hr>
<p>Linux：task_struct<br>Windows：EPROCESS、KPROCESS、PEB  </p>
<h4 id="Linux：task-struct"><a href="#Linux：task-struct" class="headerlink" title="Linux：task_struct"></a>Linux：task_struct</h4><p>非常之多</p>
<h2 id="进程状态及状态转换"><a href="#进程状态及状态转换" class="headerlink" title="进程状态及状态转换"></a>进程状态及状态转换</h2><h3 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h3><pre><code>进程的三种基本状态：
运行态、就绪态、等待态

运行态（Running）
    占有CPU，并在CPU上运行
就绪态（Ready）
    已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
等待态（Waiting/Blocked）阻塞态、封锁态、睡眠态
    因等待某一事件而暂时不能运行
</code></pre><h3 id="三状态模型以及状态转换"><a href="#三状态模型以及状态转换" class="headerlink" title="三状态模型以及状态转换"></a>三状态模型以及状态转换</h3><pre><code>就绪 → 运行
    调度程序选择一个新的进程运行

运行 → 就绪
    运行进程用完了时间片
    一个高优先级进程进入就绪状态，抢占正在运行的进程

运行 → 等待
    当一个进程等待某个事件发生时
        请求OS服务
        对资源的访问尚不能进行
        等待I/O结果
        等待另一进程提供信息

等待 → 就绪
    所等待的事件发生了
</code></pre><h3 id="其他状态"><a href="#其他状态" class="headerlink" title="其他状态"></a>其他状态</h3><pre><code>创建
    已完成创建一进程所必要的工作
        –PID、PCB
    但尚未同意执行该进程
        –因为资源有限

终止
    终止执行后，进程进入该状态
    可完成一些数据统计工作
    资源回收

挂起
    用于调节负载
    进程不占用内存空间，其进程映像交换到磁盘上
</code></pre><h3 id="五状态进程模型"><a href="#五状态进程模型" class="headerlink" title="五状态进程模型"></a>五状态进程模型</h3><p><img src="http://i.imgur.com/Md58ooA.jpg" alt=""></p>
<h3 id="七状态进程模型"><a href="#七状态进程模型" class="headerlink" title="七状态进程模型"></a>七状态进程模型</h3><p>添加了就绪挂起和阻塞挂起<br><img src="http://i.imgur.com/QtK5q30.jpg" alt=""></p>
<h3 id="linux状态示意图"><a href="#linux状态示意图" class="headerlink" title="linux状态示意图"></a>linux状态示意图</h3><p><img src="http://i.imgur.com/zfUhtic.jpg" alt=""></p>
<h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><p>操作系统为每一类进程建立一个或多个队列<br>队列元素为PCB<br>伴随进程状态的改变，其PCB从一个队列进入另一个队列<br><img src="http://i.imgur.com/XZeZzlY.jpg" alt=""></p>
<h3 id="五状态进程的队列模型"><a href="#五状态进程的队列模型" class="headerlink" title="五状态进程的队列模型"></a>五状态进程的队列模型</h3><p><img src="http://i.imgur.com/SdcJiLx.jpg" alt=""></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><pre><code>进程控制操作完成进程各状态之间的转换，由具有特定功能的原语完成
    进程创建原语
    进程撤消原语
    阻塞原语
    唤醒原语
    挂起原语
    激活原语
    改变进程优先级
</code></pre><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><pre><code>给新进程分配一个唯一标识以及进程控制块
为进程分配地址空间
初始化进程控制块
设置默认值 (如: 状态为 New，...)
设置相应的队列指针
    如: 把新进程加到就绪队列链表中
</code></pre><h3 id="进程的撤销"><a href="#进程的撤销" class="headerlink" title="进程的撤销"></a>进程的撤销</h3><pre><code>结束进程
    收回进程所占有的资源
    关闭打开的文件、断开网络连接、回收分配的内存、……
    撤消该进程的PCB
</code></pre><h3 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h3><pre><code>处于运行状态的进程，在其运行过程中期待某一事件发生，如等待键盘输入、等待磁盘数据传输完成、等待其它进程发送消息，当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态
</code></pre><h3 id="Unix的几个进程控制操作"><a href="#Unix的几个进程控制操作" class="headerlink" title="Unix的几个进程控制操作"></a>Unix的几个进程控制操作</h3><pre><code>fork() 通过复制调用进程来建立新的进程，是最基本的进程建立过程

exec() 包括一系列系统调用，它们都是通过用一段新的程序代码覆盖原来的地址空间，实现进程执行代码的转换

wait() 提供初级进程同步操作，能使一个进程等待另外一个进程的结束

exit() 用来终止一个进程的运行
</code></pre><h4 id="Unix的FORK-的实现"><a href="#Unix的FORK-的实现" class="headerlink" title="Unix的FORK()的实现"></a>Unix的FORK()的实现</h4><pre><code>为子进程分配一个空闲的进程描述符
    proc 结构
分配给子进程唯一标识 pid
以一次一页的方式复制父进程地址空间？
从父进程处继承共享资源，如打开的文件和当前工作目录等
将子进程的状态设为就绪，插入到就绪队列
对子进程返回标识符 0
向父进程返回子进程的 pid
</code></pre><p>Linux使用了写时复制技术COW加快创建进程Copy-On-Write</p>
<p>示例方法</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
void main(int argc, char *argv[])
{
    pid_t pid;
    pid = fork(); /* 创建一个子进程 */
    if (pid &lt; 0) { /* 出错 */
        fprintf(stderr, “fork failed”);
        exit(-1); }
    else if (pid == 0) { /* 子进程 */
        execlp(“/bin/ls”, “ls”, NULL); }
    else { /* 父进程 */
        wait(NULL); /* 父进程等待子进程结束 */
        printf(“child complete”);
        exit(0);
}
}
</code></pre><h2 id="深入理解进程概念"><a href="#深入理解进程概念" class="headerlink" title="深入理解进程概念"></a>深入理解进程概念</h2><h3 id="关于进程的讨论"><a href="#关于进程的讨论" class="headerlink" title="关于进程的讨论"></a>关于进程的讨论</h3><p><img src="http://i.imgur.com/cS7YiDl.jpg" alt=""></p>
<h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><pre><code>进程更能准确刻画并发，而程序不能
程序是静态的，进程是动态的
进程有生命周期的，有诞生有消亡，是短暂的；而程序是相对长久的
一个程序可对应多个进程
进程具有创建其他进程的功能
</code></pre><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><p>操作系统给每个进程都分配了一个地址空间</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>int myval;
int main(int argc, char *argv[])
{
myval = atoi(argv[1]);
while (1)
    printf(“myval is %d, loc 0x%lx\n”,
        myval, (long) &amp;myval);
}
</code></pre><p><strong>输出结果</strong><br><img src="http://i.imgur.com/2ejIZu1.jpg" alt=""></p>
<h4 id="进程地址空间图示"><a href="#进程地址空间图示" class="headerlink" title="进程地址空间图示"></a>进程地址空间图示</h4><p><img src="http://i.imgur.com/6iYnFgF.jpg" alt=""></p>
<h3 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h3><pre><code>对进程执行活动全过程的静态描述
    由进程地址空间内容、硬件寄存器内容及与该进程相关的内核数据结构、内核栈组成

用户相关：进程地址空间（包括代码段、数据段、堆和栈、共享库……）
寄存器相关：程序计数器、指令寄存器、程序状态寄存器、栈指针、通用寄存器等的值
内核相关：
    静态部分：PCB及各种资源数据结构
    动态部分：内核栈（不同进程在进入内核后使用不同的内核栈）
</code></pre><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><pre><code>将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换

进程运行时，其硬件状态保存在CPU上的寄存器中
寄存器：程序计数器、程序状态寄存器、栈指针、通用寄存器、其他控制寄存器的值

进程不运行时，这些寄存器的值保存在进程控制块PCB中；当操作系统要运行一个新的进程时，将PCB中的相关值送到对应的寄存器中
</code></pre><h2 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h2><h3 id="为什么在进程中再派生线程？"><a href="#为什么在进程中再派生线程？" class="headerlink" title="为什么在进程中再派生线程？"></a>为什么在进程中再派生线程？</h3><pre><code>三个理由
    应用的需要
    开销的考虑
    性能的考虑
</code></pre><h3 id="典型的应用"><a href="#典型的应用" class="headerlink" title="典型的应用"></a>典型的应用</h3><pre><code>Web服务器
工作方式
    从客户端接收网页请求（http协议）
    从磁盘上检索相关网页，读入内存
    将网页返回给对应的客户端
如何提高服务器工作效率？
    网页缓存（Web page Cache）
</code></pre><h4 id="如果没有线程"><a href="#如果没有线程" class="headerlink" title="如果没有线程"></a>如果没有线程</h4><pre><code>两种解决方案：
    一个服务进程
        顺序编程；性能下降
    有限状态机
        编程模型复杂；采用非阻塞I/O
</code></pre><h4 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h4><h4 id="开销的考虑"><a href="#开销的考虑" class="headerlink" title="开销的考虑"></a>开销的考虑</h4><pre><code>进程相关的操作：
    创建进程
    撤消进程
    进程通信
    进程切换
→ 时间/空间开销大，限制了并发度的提高
</code></pre><hr>
<pre><code>线程的开销小
    创建一个新线程花费时间少（撤销亦如此）
    两个线程切换花费时间少
    线程之间相互通信无须调用内核（同一进程内的线程共享内存和文件）
</code></pre><hr>
<pre><code>多个线程，有的计算，有的I/O
    多个处理器
</code></pre><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h4><p>线程继承了进程的属性<br>线程：进程中的一个运行实体，是CPU的调度单位 有时将线程称为轻量级进程<br>在同一进程增加了多个执行序列（线程）</p>
<h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><pre><code>线程：
    有标示符ID
    有状态及状态转换 → 需要提供一些操作
    不运行时需要保存的上下文
        有上下文环境：程序计数器等寄存器
    有自己的栈和栈指针 

    共享所在进程的地址空间和其他资源

    可以创建、撤消另一个线程
        程序开始是以一个单线程进程方式运行的
</code></pre><h2 id="线程机制的实现"><a href="#线程机制的实现" class="headerlink" title="线程机制的实现"></a>线程机制的实现</h2><pre><code>用户级线程
核心级线程
混合—两者结合方法
</code></pre><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><pre><code>在用户空间建立线程库：提供一组管理线程的过程
运行时系统：完成线程的管理工作（操作、线程表）
内核管理的还是进程，不知道线程的存在
线程切换不需要内核态特权
例子：UNIX
</code></pre><h4 id="POSIX线程库"><a href="#POSIX线程库" class="headerlink" title="POSIX线程库"></a>POSIX线程库</h4><p><img src="http://i.imgur.com/0OmstJz.jpg" alt=""></p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><pre><code>优点：
    线程切换快
    调度算法是应用程序特定的
    用户级线程可运行在任何操作系统上（只需要实现线程库）
缺点：
    内核只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上
    大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中所有线程也被阻塞（如何改变？）
</code></pre><h3 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h3><pre><code>内核管理所有线程管理，并向应用程序提供API接口
内核维护进程和线程的上下文
线程的切换需要内核支持
以线程为基础进行调度
例子：Windows
</code></pre><h3 id="混合模型"><a href="#混合模型" class="headerlink" title="混合模型"></a>混合模型</h3><pre><code>线程创建在用户空间完成
线程调度等在核心态完成
</code></pre><h2 id="重点小结"><a href="#重点小结" class="headerlink" title="重点小结"></a>重点小结</h2><pre><code>并发性 任何进程都可以与其他进程一起向前推进
动态性 进程是正在执行程序的实例
    进程是动态产生，动态消亡的
    进程在其生命周期内，在三种基本状态之间转换
独立性 
    进程是资源分配的一个独立单位 例如：各进程的地址空间相互独立
交互性 
    指进程在执行过程中可能与其他进程产生直接或间接的关系
异步性 
    每个进程都以其相对独立的、不可预知的速度向前推进
进程映像 
    程序 + 数据 + 栈(用户栈、内核栈) + PCB
</code></pre><hr>
<pre><code>线程
    多线程应用场景
    线程基本概念、属性
    线程实现机制

可再入程序（可重入）：
    可被多个进程同时调用的程序，具有下列性质：
    它是纯代码的，即在执行过程中自身不改变；调用它的进程应该提供数据区
</code></pre><hr>
<pre><code>重点阅读教材
第2章相关内容：2.1、2.2(除2.2.8-2.2.10外)
</code></pre><h1 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是处理器调度"><a href="#什么是处理器调度" class="headerlink" title="什么是处理器调度"></a>什么是处理器调度</h3><pre><code>CPU调度
    —— 其任务是控制、协调进程对CPU的竞争
    即按一定的调度算法从就绪队列中选择一个进程，把CPU的使用权交给被选中的进程
    如果没有就绪进程，系统会安排一个系统空闲进程或idle进程
</code></pre><hr>
<pre><code>系统场景
    N个进程就绪、等待上CPU运行
    M个CPU，M ≥ 1
    需要决策：给哪一个进程分配哪一个CPU？
</code></pre><h3 id="要解决的三个问题"><a href="#要解决的三个问题" class="headerlink" title="要解决的三个问题"></a>要解决的三个问题</h3><pre><code>WHAT：按什么原则选择下一个要执行的进程
    — 调度算法

WHEN：何时选择
    — 调度时机

HOW： 如何让被选中的进程上CPU运行
    — 调度过程（进程的上下文切换）
</code></pre><h3 id="调度的时机"><a href="#调度的时机" class="headerlink" title="调度的时机"></a>调度的时机</h3><pre><code>事件发生 → 当前运行的进程暂停运行 → 硬件机制响应后 → 进入操作系统，处理相应的事件 → 结束处理后：
某些进程的状态会发生变化，也可能又创建了一些新的进程
→ 就绪队列有调整 → 需要进程调度根据预设的调度算法从就绪队列选一个进程
</code></pre><hr>
<pre><code>典型的事件举例：
创建、唤醒、退出等进程控制操作
进程等待I/O、I/O中断
时钟中断，如：时间片用完、计时器到时
进程执行过程中出现abort异常
</code></pre><hr>
<h4 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h4><pre><code>进程正常终止 或 由于某种错误而终止
新进程创建 或 一个等待进程变成就绪
当一个进程从运行态进入阻塞态
当一个进程从运行态变为就绪态
</code></pre><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><pre><code>进程调度程序从就绪队列选择了要运行的进程：
    这个进程可以是刚刚被暂停执行的进程，也可能是另一个新的进程
进程切换
    进程切换：是指一个进程让出处理器，由另一个进程占用处理器的过程
</code></pre><hr>
<pre><code>进程切换主要包括两部分工作：
    切换全局页目录以加载一个新的地址空间
    切换内核栈和硬件上下文，其中硬件上下文包括了内核执行新进程需要的全部信息，如CPU相关寄存器

切换过程包括了对原来运行进程各种状态的保存和对新的进程各种状态的恢复
</code></pre><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><p>场景：进程A下CPU，进程B上CPU  </p>
<pre><code>保存进程A的上下文环境（程序计数器、程序状态字、其他寄存器……）
用新状态和其他相关信息更新进程A的PCB
把进程A移至合适的队列（就绪、阻塞……）
将进程B的状态设置为运行态
从进程B的PCB中恢复上下文（程序计数器 、程序状态字、其他寄存器……）
</code></pre><h4 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h4><pre><code>直接开销：内核完成切换所用的CPU时间
    保存和恢复寄存器……
    切换地址空间（相关指令比较昂贵）
间接开销
    高速缓存(Cache)、缓冲区缓存(Buffer Cache)和TLB(Translation Look-aside Buffer)失效
</code></pre><h3 id="调度算法的设计"><a href="#调度算法的设计" class="headerlink" title="调度算法的设计"></a>调度算法的设计</h3><pre><code>什么情况下需要仔细斟酌调度算法？
    批处理系统 → 多道程序设计系统 → 批处理与分时的混合系统 → 个人计算机 → 网络服务器
</code></pre><h4 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h4><pre><code>吞吐量 Throughput — 每单位时间完成的进程数目
周转时间TT(Turnaround Time)
    每个进程从提出请求到运行完成的时间
响应时间RT(Response Time)
    从提出请求到第一次回应的时间

其他
    CPU 利用率(CPU Utilization)
        CPU做有效工作的时间比例
    等待时间(Waiting time)
        每个进程在就绪队列(ready queue)中等待的时间
</code></pre><h2 id="设计调度算法要考虑的几个问题"><a href="#设计调度算法要考虑的几个问题" class="headerlink" title="设计调度算法要考虑的几个问题"></a>设计调度算法要考虑的几个问题</h2><h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><pre><code>静态优先级：
    进程创建时指定，运行过程中不再改变
动态优先级：
    进程创建时指定了一个优先级，运行过程中可以动态变化
如：等待时间较长的进程可提升其优先级
</code></pre><h3 id="进程就绪队列组织"><a href="#进程就绪队列组织" class="headerlink" title="进程就绪队列组织"></a>进程就绪队列组织</h3><p>按优先级排队</p>
<p>另一种排队方式</p>
<h3 id="抢占与非抢占"><a href="#抢占与非抢占" class="headerlink" title="抢占与非抢占"></a>抢占与非抢占</h3><pre><code>指占用CPU的方式：
    可抢占式Preemptive（可剥夺式）
        当有比正在运行的进程优先级更高的进程就绪时，系统可强行剥夺正在运行进程的CPU，提供给具有更高优先级的进程使用
    不可抢占式Non-preemptive（不可剥夺式 ）
        某一进程被调度运行后，除非由于它自身的原因不能运行，否则一直运行下去
</code></pre><h3 id="IO密集型与CPU密集型进程"><a href="#IO密集型与CPU密集型进程" class="headerlink" title="IO密集型与CPU密集型进程"></a>IO密集型与CPU密集型进程</h3><pre><code>按进程执行过程中的行为划分：
    I/O密集型或I/O型(I/O-bound)
        频繁的进行I/O，通常会花费很多时间等待I/O操作的完成
     CPU密集型或CPU型或计算密集型(CPU-bound)
        需要大量的CPU时间进行计算
</code></pre><h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><pre><code>Time slice 或 quantum
一个时间段，分配给调度上CPU的进程，确定了允许该进程运行的时间长度
如何选择时间片呢？
</code></pre><h2 id="批处理系统的调度算法"><a href="#批处理系统的调度算法" class="headerlink" title="批处理系统的调度算法"></a>批处理系统的调度算法</h2><pre><code>先来先服务（FCFS-First Come First Serve）
最短作业优先（SJF-Shortest Job First）
最短剩余时间优先
（SRTN-Shortest Remaining Time Next）
最高相应比优先
（HRRN-Highest Response Ratio Next）
</code></pre><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><pre><code>First Come First Serve
    先进先出 First In First Out (FIFO)
    按照进程就绪的先后顺序使用CPU
    非抢占

优缺点
公平
实现简单
长进程后面的短进程需要等很长时间，不利于用户体验
</code></pre><h3 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h3><pre><code>Shortest Job First
具有最短完成时间的进程优先执行
非抢占式

最短剩余时间优先
    Shortest Remaining Time Next(SRTN)
SJF抢占式版本，即当一个新就绪的进程比当前运行进程具有更短的完成时间时，系统抢占当前进程，选择新就绪的进程执行
</code></pre><hr>
<pre><code>优缺点
    最短的平均周转时间
        在所有进程同时可运行时，采用SJF调度算法可以得到最短的平均周转时间
不公平
源源不断的短任务到来，可能使长的任务长时间得不到运行 → 产生 “饥饿”现象 (starvation)
</code></pre><h3 id="最高相应比优先HRRN"><a href="#最高相应比优先HRRN" class="headerlink" title="最高相应比优先HRRN"></a>最高相应比优先HRRN</h3><pre><code>Highest Response Ratio Next
是一个综合的算法
调度时，首先计算每个进程的响应比R；之后，总是选择 R 最高的进程执行
</code></pre><hr>
<pre><code>响应比R = 周转时间 / 处理时间 =（处理时间 + 等待时间）/ 处理时间 = 1 +（等待时间 / 处理时间）
</code></pre><h2 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a>交互式系统的调度算法</h2><p>轮转调度（RR-Round Robin）<br>最高优先级调度（HPF—Highest Priority First）<br>多级反馈队列（Multiple feedback queue）<br>最短进程优先（Shortest Process Next）</p>
<h3 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h3><pre><code>目标
    为短任务改善平均响应时间
解决问题的思路
    周期性切换
    每个进程分配一个时间片
    时钟中断 → 轮换
</code></pre><hr>
<pre><code>如何选择合适的时间片?
    太长 --大于典型的交互时间
        降级为先来先服务算法
        延长短进程的响应时间
    太短 --小于典型的交互时间
        进程切换浪费CPU时间
</code></pre><hr>
<pre><code>优缺点
    公平
    有利于交互式计算，响应时间快
    由于进程切换，时间片轮转算法要花费较高的开销
假设时间片 10ms，如果进程切换花费0.1ms，CPU开销约占1%
    RR对不同大小的进程是有利的
    但是对于相同大小的进程呢？
</code></pre><p>但是对于相同大小的进程呢？</p>
<h3 id="虚拟轮转法"><a href="#虚拟轮转法" class="headerlink" title="虚拟轮转法"></a>虚拟轮转法</h3><p>有一个辅助队列，选择其中的IO进程，辅助队列为空，再从就绪队列中选</p>
<h3 id="最高优先级调度"><a href="#最高优先级调度" class="headerlink" title="最高优先级调度"></a>最高优先级调度</h3><pre><code>选择优先级最高的进程投入运行
通常：系统进程优先级 高于 用户进程
    前台进程优先级 高于 后台进程
    操作系统更偏好 I/O型进程
优先级可以是静态不变的，也可以动态调整
    优先数可以决定优先级
就绪队列可以按照优先级组织
实现简单；不公平
</code></pre><hr>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><pre><code>又称：优先级反置、翻转、倒挂
现象
    一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行
</code></pre><hr>
<pre><code>设H是高优先级进程，L是低优先级进程， M是中优先级进程（CPU型）
    场景：L进入临界区执行，之后被抢占；
        H也要进入临界区，失败，被阻塞；
        M上CPU执行，L无法执行所以H也无法执行
</code></pre><hr>
<pre><code>影响
    系统错误
    高优先级进程停滞不前，导致系统性能降低

解决方案
    设置优先级上限
    优先级继承
    使用中断禁止
</code></pre><h2 id="多级反馈队列调度算法、各种调度算法小结等"><a href="#多级反馈队列调度算法、各种调度算法小结等" class="headerlink" title="多级反馈队列调度算法、各种调度算法小结等"></a>多级反馈队列调度算法、各种调度算法小结等</h2><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><pre><code>Multilevel Feedback
是UNIX的一个分支BSD （加州大学伯克利分校开发和发布的）5.3版所采用的调度算法
是一个综合调度算法
</code></pre><hr>
<pre><code>设置多个就绪队列，第一级队列优先级最高
给不同就绪队列中的进程分配长度不同的时间片，第一级队列时间片最小；随着队列优先级别的降低，时间片增大
当第一级队列为空时，在第二级队列调度，以此类推
各级队列按照时间片轮转方式 进行调度
当一个新创建进程就绪后，进入第一级队列
进程用完时间片而放弃CPU，进入下一级就绪队列
由于阻塞而放弃CPU的进程进入相应的等待队列，一旦等待的事件发生，该进程回到原来一级就绪队列（？）
</code></pre><hr>
<pre><code>若允许抢占
    当有一个优先级更高的进程就绪时，可以抢占CPU
    被抢占的进程回到原来一级就绪队列末尾（或者？）
</code></pre><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p><img src="img/opSystem/forth/1.jpg" alt=""></p>
<h3 id="多处理器调度算法设计"><a href="#多处理器调度算法设计" class="headerlink" title="多处理器调度算法设计"></a>多处理器调度算法设计</h3><pre><code>不仅要决定选择哪一个进程执行
    还需要决定在哪一个CPU上执行
要考虑进程在多个CPU之间迁移时的开销
    高速缓存失效、TLB失效
    尽可能使进程总是在同一个CPU上执行
        如果每个进程可以调度到所有CPU上，假如进程上次在CPU1上执行，本次被调度到CPU2，则会增加高速缓存失效、TLB失效；如果每个进程尽量调度到指定的CPU上，各种失效就会减少
考虑负载均衡问题
</code></pre><h2 id="典型操作系统的调度算法"><a href="#典型操作系统的调度算法" class="headerlink" title="典型操作系统的调度算法"></a>典型操作系统的调度算法</h2><pre><code>UNIX 动态优先数法
5.3BSD 多级反馈队列法
Linux 抢占式调度
Windows 基于优先级的抢占式多任务调度
Solaris 综合调度算法
</code></pre><h3 id="LINUX调度算法的发展历史"><a href="#LINUX调度算法的发展历史" class="headerlink" title="LINUX调度算法的发展历史"></a>LINUX调度算法的发展历史</h3><pre><code>Linux2.4简单的基于优先级调度

Linux2.6O(1)调度器

Linux2.6 SD调度器补丁

Linux2.6RSDL调度器补丁

Linux2.6CFS调度器：完全公平调度算法
</code></pre><h3 id="Windows线程调度"><a href="#Windows线程调度" class="headerlink" title="Windows线程调度"></a>Windows线程调度</h3><pre><code>调度单位是线程
采用基于动态优先级的、抢占式调度，结合时间配额的调整
</code></pre><hr>
<pre><code>就绪线程按优先级进入相应队列
系统总是选择优先级最高的就绪线程运行
同一优先级的各线程按时间片轮转进行调度
多CPU系统中允许多个线程并行运行
</code></pre><hr>
<pre><code>引发线程调度的条件：
    一个线程的优先级改变了
    一个线程改变了它的亲和(Affinity)处理机集合

    线程正常终止 或 由于某种错误而终止
    新线程创建 或 一个等待线程变成就绪
    当一个线程从运行态进入阻塞态
    当一个线程从运行态变为就绪态
</code></pre><hr>
<pre><code>Windows使用32个线程优先级，分成三类
零页线程：0级
    用于对系统中空闲物理页面清零
实时优先级线程不改变其优先级
可变优先级线程：其优先级可以在一定范围内升高或降    低 基本优先级 和 当前优先级
</code></pre><h3 id="线程的时间配额"><a href="#线程的时间配额" class="headerlink" title="线程的时间配额"></a>线程的时间配额</h3><pre><code>时间配额不是一个时间长度值，而一个称为配额单位(quantum unit)的整数
一个线程用完了自己的时间配额时，如果没有其他相同优先级的线程，Windows将重新给该线程分配一个新的时间配额，让它继续运行
</code></pre><hr>
<pre><code>时间配额的一种特殊作用
    假设用户首先启动了一个运行时间很长的电子表格计算程序，然后切换到一个游戏程序(需要复杂图形计算并显示，CPU型)
    如果前台的游戏进程提高它的优先级，则后台的电子表格计算进程就几乎得不到CPU时间了
    但增加游戏进程的时间配额，则不会停止执行电子表格计算，只是给游戏进程的CPU时间多一些而已
</code></pre><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><pre><code>主动切换
抢占
时间配额用完
</code></pre><h4 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h4><pre><code>当线程被抢占时，它被放回相应优先级的就绪队列的队首
    处于实时优先级的线程在被抢占时，时间配额被重置为一个完整的时间配额
    处于可变优先级的线程在被抢占时，时间配额不变，重新得到CPU后将运行剩余的时间配额
</code></pre><h4 id="时间配额用完"><a href="#时间配额用完" class="headerlink" title="时间配额用完"></a>时间配额用完</h4><pre><code>假设线程A的时间配额用完
    A的优先级没有降低
    如果队列中有其他就绪线程，选择下一个线程执行，A回到原来就绪队列末尾
    如果队列中没有其他就绪线程，系统给线程A分配一个新的时间配额，让它继续运行

    A的优先级降低了，Windows 将选择一个更高优先级的线程
</code></pre><h3 id="线程优先级与时间配额调整"><a href="#线程优先级与时间配额调整" class="headerlink" title="线程优先级与时间配额调整"></a>线程优先级与时间配额调整</h3><pre><code>Windows的调度策略
    如何体现对某类线程具有倾向性？
    如何解决由于调度策略中潜在的不公平性而带来饥饿现象？
    如何改善系统吞吐量、响应时间等整体特征？

解决方案
    提升线程的优先级
    给线程分配一个很大的时间配额
</code></pre><h4 id="线程优先级提升"><a href="#线程优先级提升" class="headerlink" title="线程优先级提升"></a>线程优先级提升</h4><pre><code>下列5种情况，Windows 会提升线程的当前优先级：
    I/O操作完成
    信号量或事件等待结束
    前台进程中的线程完成一个等待操作
    由于窗口活动而唤醒窗口线程
    线程处于就绪态超过了一定的时间还没有运行
        —— “饥饿”现象
针对可变优先级范围内(1至15)的线程优先级
</code></pre><hr>
<p>I/O操作完成后的线程优先级提升</p>
<pre><code>在完成I/O操作后，Windows 将临时提升等待该操作线程的优先级，保证该线程能更快上CPU运行进行数据处理
优先级的提升值由设备驱动程序决定，提升建议值保存在系统文件“Wdm.h”或“Ntddk.h”中
优先级的提升幅度与对I/O请求的响应时间要求是一致的，响应时间要求越高，优先级提升幅度越大
设备驱动程序在完成I/O请求时通过内核函数IoCompleteRequest来指定优先级提升的幅度
为避免不公平，在I/O操作完成唤醒等待线程时会将该线程的时间配额减1
</code></pre><hr>
<p>“饥饿”线程优先级提升 </p>
<pre><code>系统线程“平衡集管理器(balance set manager)” 每秒钟扫描一次就绪队列，发现是否存在等待时间超过300个时钟中断间隔的线程
平衡集管理器将这些线程的优先级提升到15，并分配给它一个长度为正常值4倍的时间配额
当被提升的线程用完它的时间配额后，立即衰减到它原来的基本优先级
</code></pre><h2 id="重点-2"><a href="#重点-2" class="headerlink" title="重点"></a>重点</h2><h3 id="本讲重点"><a href="#本讲重点" class="headerlink" title="本讲重点"></a>本讲重点</h3><pre><code>掌握处理器调度的相关概念
    调度时机、进程切换
    调度标准：吞吐量、周转时间、响应时间
    优先级/优先数、抢占/非抢占、I/O型与CPU型
掌握主要的调度算法
    先来先服务、短作业优先、最高相应比优先
    时间片轮转、 最高优先级
    多级反馈队列
了解Windows、多处理器调度的基本思想
</code></pre><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><pre><code>重点阅读教材
第2章相关内容：2.4
第11章相关内容：11.4.3中的调度部分

重点概念
调度时机 进程切换 抢占/非抢占 时间片
优先级反转 饥饿 优先级与优先数 优先级提升
先来先服务 短作业优先 最高相应比优先
时间片轮转 最高优先级 多级队列反馈
吞吐量 周转时间 响应时间
</code></pre><h1 id="同步机制1"><a href="#同步机制1" class="headerlink" title="同步机制1"></a>同步机制1</h1><h2 id="进程的并发执行"><a href="#进程的并发执行" class="headerlink" title="进程的并发执行"></a>进程的并发执行</h2><p>进程的并发执行<br>进程互斥<br>进程同步<br>信号量及PV操作<br>经典的IPC问题</p>
<h3 id="进程并发执行"><a href="#进程并发执行" class="headerlink" title="进程并发执行"></a>进程并发执行</h3><h4 id="从进程的特征触发"><a href="#从进程的特征触发" class="headerlink" title="从进程的特征触发"></a>从进程的特征触发</h4><pre><code>并发
    进程的执行是间断性的
    进程的相对执行速度不可预测
共享
    进程/线程之间的制约性
不确定性
    进程执行的结果与其执行的相对速度有关，是不确定的
</code></pre><p>####与时间有关的错误  ####<br>两个进程的关键活动出现了交叉  </p>
<h3 id="并发执行过程分析"><a href="#并发执行过程分析" class="headerlink" title="并发执行过程分析"></a>并发执行过程分析</h3><pre><code>当前状态 (3,4,...,m) 2 2 (1,2)
可能的执行（假设g,c,p为get,copy,put的一次循环）
g,c,p (4,5,...,m) 3 3 (1,2,3) 正确
g,p,c (4,5,...,m) 3 3 (1,2,2) 错误
c,g,p (4,5,...,m) 3 2 (1,2,2) 错误
c,p,g (4,5,...,m) 3 2 (1,2,2) 错误
p,c,g (4,5,...,m) 3 2 (1,2,2) 错误
p,g,c (4,5,...,m) 3 3 (1,2,2) 错误
</code></pre><h3 id="进程前趋图"><a href="#进程前趋图" class="headerlink" title="进程前趋图"></a>进程前趋图</h3><p><img src="http://i.imgur.com/vl6oxdi.jpg" alt=""></p>
<h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序</p>
<h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><pre><code>由于各进程要求使用共享资源（变量、文件等），而这些资源需要排他性使用
各进程之间竞争使用这些资源
    —— 这一关系称为进程互斥

临界资源：critical resource
    系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源或共享变量

临界区(互斥区)：critical section(region)
    各个进程中对某个临界资源（共享变量）实施操作的程序片段
</code></pre><h3 id="临界区的使用原则"><a href="#临界区的使用原则" class="headerlink" title="临界区的使用原则"></a>临界区的使用原则</h3><pre><code>没有进程在临界区时，想进入临界区的进程可进入
不允许两个进程同时处于其临界区中
临界区外运行的进程不得阻塞其他进程进入临界区
不得使进程无限期等待进入临界区
</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><pre><code>软件方案
    Dekker解法、Peterson解法
硬件方案
    屏蔽中断、TSL(XCHG)指令
</code></pre><h2 id="软件解决方案"><a href="#软件解决方案" class="headerlink" title="软件解决方案"></a>软件解决方案</h2><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><pre><code>P:
    … …
    while (free) ;
    free = true;
    临界区
    free = false;
    … …
Q: 
    … … 
    while (free) ;
     free = true; 
    临界区 
    free = false;
     … …
</code></pre><hr>
<pre><code>free: 临界区空闲标志
true: 有进程在临界区 
false:无进程在临界区
初值：free为false
</code></pre><h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><pre><code>P:
    … …
    while (not turn) ;
    临界区
    turn = false;
    … …
Q:
    … …
    while (turn) ;
    临界区
    turn = true;
    … …
</code></pre><hr>
<pre><code>turn: 谁进临界区的标志 
true: P进程进临界区 
false: Q进程进临界区
初值任意
</code></pre><h3 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h3><pre><code>P:
    … …
    pturn = true;
    while (qturn) ;
    临界区
    pturn = false;
    … …

Q:
    … …
    qturn = true;
    while (pturn) ;
    临界区
    qturn = false;
    … …
</code></pre><hr>
<pre><code>pturn, qturn: 初值为false
P进入临界区的条件: pturn∧ not qturn
Q进入临界区的条件: not pturn∧ qturn
</code></pre><p>死锁问题</p>
<h3 id="解法4：DEKKER算法"><a href="#解法4：DEKKER算法" class="headerlink" title="解法4：DEKKER算法"></a>解法4：DEKKER算法</h3><pre><code>P:
    … …
    pturn = true;
    while (qturn) {
        if (turn == 2) {
            pturn = false;
            while (turn == 2);
            pturn = true;
            } }
    临界区
    turn = 2;
    pturn = false;
    … …

Q:
… …
qturn = true;
while (pturn) {
    if (turn == 1) {
        qturn = false;
        while (turn == 1);
        qturn = true;
    } }
临界区
turn = 1;
qturn = false;
… …
</code></pre><h3 id="解法5：PETTERSON算法"><a href="#解法5：PETTERSON算法" class="headerlink" title="解法5：PETTERSON算法"></a>解法5：PETTERSON算法</h3><pre><code>Peterson算法解决了互斥访问的问题，而且克服了强制轮流法的缺点，可以完全正常地工作（1981）
</code></pre><hr>
<pre><code>进程i：
    … …
    enter_region ( i );
    临界区
    leave_region ( i );
</code></pre><h2 id="进程互斥的硬件解决方法"><a href="#进程互斥的硬件解决方法" class="headerlink" title="进程互斥的硬件解决方法"></a>进程互斥的硬件解决方法</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><pre><code>“开关中断”指令
执行“关中断”指令
    临界区操作
执行“开中断”指令
</code></pre><hr>
<pre><code>简单，高效
代价高，限制CPU并发能力（临界区大小）
不适用于多处理器
适用于操作系统本身，不适于用户进程
</code></pre><h3 id="“测试并加锁”指令"><a href="#“测试并加锁”指令" class="headerlink" title="“测试并加锁”指令"></a>“测试并加锁”指令</h3><p>TSL指令：TEST AND SET LOCK    </p>
<pre><code>复制锁到寄存器并将锁置1
判断寄存器内容是否是零？
若不是零，跳转到enter_region
返回调用者，进入了临界区

在锁中置0
返回调用者
</code></pre><h3 id="交换指令"><a href="#交换指令" class="headerlink" title="交换指令"></a>交换指令</h3><pre><code>给寄存器中置1 
交换寄存器与锁变量的内容 
判断寄存器内容是否是零？ 
若不是零，跳转到enter_region 
返回调用者，进入了临界区

在锁中置0
返回调用者
</code></pre><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><pre><code>软件方法
    编程技巧
硬件方法
忙等待(busy waiting)
    进程在得到临界区访问权之前，持续测试而不做其他事情
    自旋锁 Spin lock (多处理器 √)
优先级反转（倒置）
</code></pre><h2 id="进程的同步"><a href="#进程的同步" class="headerlink" title="进程的同步"></a>进程的同步</h2><pre><code>进程同步：synchronization
    指系统中多个进程中发生的事件存在某种时序关系，需要相互合作，共同完成一项任务
</code></pre><hr>
<pre><code>具体地说，一个进程运行到某一点时，要求另一伙伴进程为它提供消息，在未获得消息之前，该进程进入阻塞态，获得消息后被唤醒进入就绪态
</code></pre><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><pre><code>问题描述：
    一个或多个生产者生产某种类型的数据放置在缓冲区中
    有消费者从缓冲区中取数据，每次取一项
    只能有一个生产者或消费者对缓冲区进行操作
</code></pre><h4 id="要解决的问题："><a href="#要解决的问题：" class="headerlink" title="要解决的问题："></a>要解决的问题：</h4><pre><code>当缓冲区已满时，生产者不会继续向其中添加数据；
当缓冲区为空时，消费者不会从中移走数据
生产者和消费者不能同时操作
</code></pre><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><pre><code>避免忙等待
睡眠 与 唤醒 操作(原语)
</code></pre><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#define N 100
int count=0;
void producer(void)
{ int item;
    while(TRUE) {
        item=produce_item();
        if(count==N) sleep();
        insert_item(item);
        count=count+1;
        if(count==1)
        wakeup(consumer);
    }
}
</code></pre><hr>
<pre><code>void consumer(void)
{
    int item;
    while(TRUE) {
        if(count==0) sleep();
        item=remove_item();
        count=count-1;
        if(count==N-1)
        wakeup(producer);
        consume_item(item);
    }
}
</code></pre><p>没有完全解决问题</p>
<h3 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h3><p><img src="http://i.imgur.com/ifkpI4v.jpg" alt=""></p>
<p><img src="http://i.imgur.com/kiLLuu6.jpg" alt=""></p>
<h2 id="信号量及P、V操作"><a href="#信号量及P、V操作" class="headerlink" title="信号量及P、V操作"></a>信号量及P、V操作</h2><pre><code>一个特殊变量
用于进程间传递信息的一个整数值
定义如下：
struc semaphore
{
    int count;
    queueType queue;
}
信号量说明：semaphore s;
对信号量可以实施的操作：初始化、P和V（P、V分别是荷兰语的test(proberen)和increment(verhogen)）
</code></pre><h3 id="P，V操作定义"><a href="#P，V操作定义" class="headerlink" title="P，V操作定义"></a>P，V操作定义</h3><pre><code>P(s)
{
    s.count --;
    if (s.count &lt; 0)
{
    该进程状态置为阻塞状态；
    将该进程插入相应的等待队列s.queue末尾；
    重新调度；
}
}
</code></pre><p>down, semWait</p>
<hr>
<pre><code>V(s)
{
    s.count ++;
    if (s.count &lt; = 0)
{
    唤醒相应等待队列s.queue中等待的一个进程；
    改变其状态为就绪态，并将其插入就绪队列；
}
}
</code></pre><p>up, semSignal</p>
<h4 id="有关说明"><a href="#有关说明" class="headerlink" title="有关说明"></a>有关说明</h4><pre><code>P、V操作为原语操作(primitive or atomic action)

在信号量上定义了三个操作
    初始化(非负数)、P操作、V操作

最初提出的是二元信号量（解决互斥）
    之后，推广到一般信号量（多值）或计数信号量（解决同步）
</code></pre><h3 id="PV操作解决进行间互斥问题"><a href="#PV操作解决进行间互斥问题" class="headerlink" title="PV操作解决进行间互斥问题"></a>PV操作解决进行间互斥问题</h3><pre><code>分析并发进程的关键活动，划定临界区
设置信号量 mutex，初值为1
在临界区前实施 P(mutex)
在临界区之后实施 V(mutex)
</code></pre><p><img src="http://i.imgur.com/XM6g4tn.jpg" alt=""></p>
<h2 id="生产者消费者问题-1"><a href="#生产者消费者问题-1" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h3 id="用信号量的解法"><a href="#用信号量的解法" class="headerlink" title="用信号量的解法"></a>用信号量的解法</h3><pre><code>void producer(void) 
{ int item; 
    while(TRUE) 
    { item=produce_item();
         P(&amp;empty); 
        P(&amp;mutex); 
        insert_item(item);
         V(&amp;mutex);
         V(&amp;full); 
    } }
</code></pre><hr>
<pre><code>void consumer(void)
{ int item;
    while(TRUE) {
        P(&amp;full);
        P(&amp;mutex);
        item=remove_item();
        V(&amp;mutex);
        V(&amp;empty);
        consume_item(item);
}
}
</code></pre><hr>
<pre><code>#define N 100 /* 缓冲区个数 */
typedef int semaphore; /* 信号量是一种特殊的整型数据 */
semaphore mutex =1; /* 互斥信号量：控制对临界区的访问 */
semaphore empty =N; /* 空缓冲区个数 */
semaphore full = 0; /* 满缓冲区个数 */
</code></pre><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><pre><code>思考：
若颠倒两个P操作的顺序？
思考：
若颠倒两个V操作的顺序？
</code></pre><h2 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h2><h3 id="信号量解法"><a href="#信号量解法" class="headerlink" title="信号量解法"></a>信号量解法</h3><pre><code>问题描述：
    多个进程共享一个数据区，这些进程分为两组：
        读者进程：只读数据区中的数据
        写者进程：只往数据区写数据

要求满足条件：
    允许多个读者同时执行读操作
    不允许多个写者同时操作
    不允许读者、写者同时操作
</code></pre><h3 id="第一类问题，读者优先"><a href="#第一类问题，读者优先" class="headerlink" title="第一类问题，读者优先"></a>第一类问题，读者优先</h3><pre><code>如果读者执行：
    无其他读者、写者，该读者可以读
    若已有写者等，但有其他读者正在读，则该读者也可以读
    若有写者正在写，该读者必须等

如果写者执行：
    无其他读者、写者，该写者可以写
    若有读者正在读，该写者等待
    若有其他写者正在写，该写者等待
</code></pre><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><pre><code>void reader(void)
{
    while (TRUE) {
    ……
    P (w);//第一个读者做
    读操作
    V(w);//最后一个读者做
    ……
}
}
</code></pre><hr>
<pre><code>void writer(void)
{
    while (TRUE) {
    ……
    P(w);
    写操作
    V(w);
    ……
}
}
</code></pre><p>解决不了多个同时读</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><pre><code>void reader(void)
{
while (TRUE) {
    P(mutex);
    rc = rc + 1;
    if (rc == 1) P (w);//Rc也需要保护
    V(mutex);

    读操作

    P(mutex);
    rc = rc - 1;
    if (rc == 0) V(w);
    V(mutex);
    其他操作
}
</code></pre><hr>
<pre><code>void writer(void)
{
while (TRUE) {
……
P(w);

写操作

V(w);
}
}
</code></pre><h3 id="LINUX提供的读写锁"><a href="#LINUX提供的读写锁" class="headerlink" title="LINUX提供的读写锁"></a>LINUX提供的读写锁</h3><pre><code>应用场景
    如果每个执行实体对临界区的访问或者是读或者是写共享变量，但是它们都不会既读又写时，读写锁是最好的选择

实例：Linux的IPX路由代码中使用了读-写锁，用ipx_routes_lock的读-写锁保护IPX路由表的并发访问
</code></pre><hr>
<pre><code>要通过查找路由表实现包转发的程序需要请求读锁；

需要添加和删除路由表中入口的程序必须获取写锁（由于通过读路由表的情况比更新路由表的情况多得多，使用读-写锁提高了性能）
</code></pre><h2 id="重点-3"><a href="#重点-3" class="headerlink" title="重点"></a>重点</h2><pre><code>基本概念
    竞争条件、临界区
    进程同步、进程互斥
    自旋锁（忙等待）
信号量、PV操作
经典问题模型及解决方案
    生产者-消费者问题、读者-写者问题
</code></pre><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><pre><code>重点阅读教材
第2章相关内容：2.3.1~2.3.5，2.5.2

重点概念
竞争条件 与时间有关的错误 忙等待
临界资源 临界区 进程互斥 进程同步
信号量 P、V操作 锁 自旋锁
生产者消费者问题 读者写者问题
</code></pre><h1 id="同步互斥机制2"><a href="#同步互斥机制2" class="headerlink" title="同步互斥机制2"></a>同步互斥机制2</h1><h2 id="管程的基本概念"><a href="#管程的基本概念" class="headerlink" title="管程的基本概念"></a>管程的基本概念</h2><pre><code>管程monitor
进程间通信
    Inter-Process Communication
典型操作系统的IPC机制
</code></pre><h3 id="为什么会出现管程"><a href="#为什么会出现管程" class="headerlink" title="为什么会出现管程"></a>为什么会出现管程</h3><pre><code>问题：
    信号量机制的不足：程序编写困难、易出错  
解决：
    Brinch Hansen(1973) 
    Hoare（1974）
方案：
    在程序设计语言中引入管程成分 
    一种高级同步机制
</code></pre><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre><code>是一个特殊的模块
有一个名字
由关于共享资源的数据结构及在其上操作的一组过程组成

进程与管程
进程只能通过调用管程中的过程来间接地访问管程中的数据结构
</code></pre><h3 id="有什么保证"><a href="#有什么保证" class="headerlink" title="有什么保证"></a>有什么保证</h3><pre><code>互斥
    管程是互斥进入的
        ——为了保证管程中数据结构的数据完整性
管程的互斥性是由编译器负责保证的

同步
    管程中设置条件变量及等待/唤醒操作以解决同步问题
    可以让一个进程或线程在条件变量上等待（此时，应先释放管程的使用权），也可以通过发送信号将等待在条件变量上的进程或线程唤醒
</code></pre><h3 id="会遇到什么问题"><a href="#会遇到什么问题" class="headerlink" title="会遇到什么问题"></a>会遇到什么问题</h3><pre><code>设问：
    是否会出现这样一种场景，有多个进程同时在管程中出现？
场景场景：
    当一个进入管程的进程执行等待操作时，它应当释放管程的互斥权

    当后面进入管程的进程执行唤醒操作时（例如P唤醒Q），管程中便存在两个同时处于活动状态的进程

如何解决？
    三种处理方法：
        P等待Q执行
        Q等待P继续执行
        规定唤醒操作为管程中最后一个可执行的操作
</code></pre><h2 id="Hoare管程"><a href="#Hoare管程" class="headerlink" title="Hoare管程"></a>Hoare管程</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>因为管程是互斥进入的，所以当一个进程试图进入一个已被占用的管程时，应当在管程的入口处等待
    为此，管程的入口处设置一个进程等待队列，称作入口等待队列
如果进程P唤醒进程Q，则P等待Q执行；如果进程Q执行中又唤醒进程R，则Q等待R执行；……，如此，在管程内部可能会出现多个等待进程
    在管程内需要设置一个进程等待队列，称为紧急等待队列，紧急等待队列的优先级高于入口等待队列的优先级
</code></pre><h3 id="条件变量的实现"><a href="#条件变量的实现" class="headerlink" title="条件变量的实现"></a>条件变量的实现</h3><pre><code>条件变量——在管程内部说明和使用的一种特殊类型的变量
var c:condition;
对于条件变量，可以执行wait和signal操作
</code></pre><hr>
<pre><code>wait(c)：
    如果紧急等待队列非空，则唤醒第一个等待者；否则释放管程的互斥权，执行此操作的进程进入c链末尾
signal(c)：
    如果c链为空，则相当于空操作，执行此操作的进程继续执行；否则唤醒第一个等待者，执行此操作的进程进入紧急等待队列的末尾
</code></pre><h2 id="管程的实现"><a href="#管程的实现" class="headerlink" title="管程的实现"></a>管程的实现</h2><pre><code>管程实现的两个主要途径：
    * 直接构造 → 效率高
    * 间接构造
        → 用某种已经实现的同步机制去构造
</code></pre><h3 id="管程解决生产者消费者问题"><a href="#管程解决生产者消费者问题" class="headerlink" title="管程解决生产者消费者问题"></a>管程解决生产者消费者问题</h3><h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><pre><code>procedure producer;
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;
procedure consumer;
begin
    while true do
    begin
        item=ProducerConsumer.remove;
        consume_item(item);
    end
end;
</code></pre><h4 id="管程的实现-1"><a href="#管程的实现-1" class="headerlink" title="管程的实现"></a>管程的实现</h4><pre><code>monitor ProducerConsumer
    condition full, empty;
    integer count;
    procedure insert (item: integer);
    begin
        if count == N then wait(full);
        insert_item(item); count++;
        if count ==1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count ==0 then wait(empty);
        remove = remove_item; count--;
        if count==N-1 then signal(full);
    end;
    count:=0;
end monitor;
</code></pre><h3 id="java有类似管程的机制"><a href="#java有类似管程的机制" class="headerlink" title="java有类似管程的机制"></a>java有类似管程的机制</h3><h2 id="MESA管程"><a href="#MESA管程" class="headerlink" title="MESA管程"></a>MESA管程</h2><pre><code>Lampson和Redell，Mesa语言（1980）
Hoare管程的一个缺点
    两次额外的进程切换
解决：
    signal → notify
    notify：当一个正在管程中的进程执行notify(x)时，它使得x条件队列得到通知，发信号的进程继续执行
</code></pre><h3 id="使用NOTIFY要注意的问题"><a href="#使用NOTIFY要注意的问题" class="headerlink" title="使用NOTIFY要注意的问题"></a>使用NOTIFY要注意的问题</h3><pre><code>notify的结果：位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行

由于不能保证在它之前没有其他进程进入管程，因而这个进程必须重新检查条件
→ 用while循环取代if语句

导致对条件变量至少多一次额外的检测（但不再有额外的进程切换），并且对等待进程在notify之后何时运行没有任何限制
</code></pre><h3 id="解决生产者消费者问题"><a href="#解决生产者消费者问题" class="headerlink" title="解决生产者消费者问题"></a>解决生产者消费者问题</h3><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><pre><code>对notify的一个很有用的改进
    给每个条件原语关联一个监视计时器，不论是否被通知，一个等待时间超时的进程将被设为就绪态
    当该进程被调度执行时，会再次检查相关条件，如果条件满足则继续执行

超时可以防止如下情况的发生：
    当某些进程在产生相关条件的信号之前失败时，等待该条件的进程就会被无限制地推迟执行而处于饥饿状态
</code></pre><h3 id="引入BROADCAST"><a href="#引入BROADCAST" class="headerlink" title="引入BROADCAST"></a>引入BROADCAST</h3><pre><code>broadcast：使所有在该条件上等待的进程都被释放并进入就绪队列

    当一个进程不知道有多少进程将被激活时，这种方式是非常方便的
        例子：生产者/消费者问题中，假设insert和remove函数都适用于可变长度的字符块，此时，如果一个生产者往缓冲区中添加了一批字符，它不需要知道每个正在等待的消费者准备消耗多少字符，而仅仅执行一个broadcast，所有正在等待的进程都得到通知并再次尝试运行

当一个进程难以准确判定将激活哪个进程时，也可使用广播
</code></pre><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><pre><code>Mesa管程优于Hoare管程之处在于Mesa管程错误比较少
在Mesa管程中，由于每个过程 在收到信号后都重新检查管程变量，并且由于使用了while结构，一个进程不正确的broadcast广播或发信号notify，不会导致收到信号的程序出错
    收到信号的程序将检查相关的变量，如果期望的条件没有满足，它会重新继续等待
</code></pre><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><pre><code>管程：抽象数据类型
    有一个明确定义的操作集合，通过它且只有通过它才能操纵该数据类型的实例
实现管程结构必须保证下面几点：
    （1）只能通过管程的某个过程才能访问资源；
    （2）管程是互斥的，某个时刻只能有一个进程或线程调用管程中的过程
条件变量：为提供进程与其他进程通信或同步而引入
     wait/signal 或 wait/notify 或 wait/broadcast
</code></pre><h2 id="PTHREAD中的同步机制"><a href="#PTHREAD中的同步机制" class="headerlink" title="PTHREAD中的同步机制"></a>PTHREAD中的同步机制</h2><p><img src="http://i.imgur.com/6CmUVag.jpg" alt=""></p>
<h3 id="生产者消费者问题-2"><a href="#生产者消费者问题-2" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p><img src="http://i.imgur.com/QRMKEIh.jpg" alt=""><br>实现的是mesa管程的语义</p>
<h3 id="cond-wait"><a href="#cond-wait" class="headerlink" title="cond_wait"></a>cond_wait</h3><pre><code>pthread_cond_wait的执行分解为三个主要动作：
    1、解锁
    2、等待
        当收到一个解除等待的信号（pthread_cond_signal或者pthread_cond_broad_cast）之后，pthread_cond_wait马上需要做的动作是：
    3、上锁
</code></pre><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="为什么需要通信机制？"><a href="#为什么需要通信机制？" class="headerlink" title="为什么需要通信机制？"></a>为什么需要通信机制？</h3><pre><code>信号量及管程的不足
不适用多处理器情况

进程通信机制
    消息传递send &amp; receive原语

适用于：分布式系统、基于共享内存的多处理机系统、单处理机系统
可以解决进程间的同步问题、通信问题
</code></pre><h3 id="基本通信方式"><a href="#基本通信方式" class="headerlink" title="基本通信方式"></a>基本通信方式</h3><pre><code>消息传递
共享内存
管道
套接字
远程过程调用
</code></pre><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><img src="http://i.imgur.com/EZuWkXa.jpg" alt=""></p>
<h4 id="PV操作的实现send"><a href="#PV操作的实现send" class="headerlink" title="PV操作的实现send"></a>PV操作的实现send</h4><p><img src="http://i.imgur.com/uNs6069.jpg" alt=""></p>
<p>###共享内存 ###<br><img src="http://i.imgur.com/gHeUaSg.jpg" alt=""></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p><img src="http://i.imgur.com/06aIUmm.jpg" alt=""></p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><h3 id="远程过程调用"><a href="#远程过程调用" class="headerlink" title="远程过程调用"></a>远程过程调用</h3><h2 id="典型操作系统中的IPC机制"><a href="#典型操作系统中的IPC机制" class="headerlink" title="典型操作系统中的IPC机制"></a>典型操作系统中的IPC机制</h2><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><pre><code>UNIX
    管道、消息队列、共享内存、信号量、信号、套接字

Linux
    管道、消息队列、共享内存、信号量、信号、套接字

    内核同步机制：原子操作、自旋锁、读写锁、信号量、屏障、BKL

Windows
    同步对象：互斥对象、事件对象、信号量对象

    临界区对象

    互锁变量

    套接字、文件映射、管道、命名管道、邮件槽、剪贴板、动态数据交换、对象连接与嵌入、动态链接库、远程过程调用
</code></pre><h3 id="Linux的进程通信机制"><a href="#Linux的进程通信机制" class="headerlink" title="Linux的进程通信机制"></a>Linux的进程通信机制</h3><p><img src="http://i.imgur.com/fwqMmfW.jpg" alt=""></p>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><pre><code>不可分割，在执行完之前不会被其他任务或事件中断
常用于实现资源的引用计数
atomic_t
</code></pre><hr>
<pre><code>typedef struct { volatile int counter; } 

atomic_t;
原子操作API包括：
atomic_read(atomic_t * v);
atomic_set(atomic_t * v, int i);
void atomic_add(int i, atomic_t *v);
int atomic_sub_and_test(int i, atomic_t *v);
void atomic_inc(atomic_t *v);
int atomic_add_return(int i, atomic_t *v);
</code></pre><h4 id="屏障：栅栏"><a href="#屏障：栅栏" class="headerlink" title="屏障：栅栏"></a>屏障：栅栏</h4><pre><code>一种同步机制(又称栅栏、关卡)
 用于对一组线程进行协调
应用场景
一组线程协同完成一项任务，需要所有线程都到达一个汇合点后再一起向前推进
</code></pre><h2 id="重点-4"><a href="#重点-4" class="headerlink" title="重点"></a>重点</h2><pre><code>管程
    如何保证互斥
    如何保证同步——条件变量及wait/signal
    Hoare管程
    MESA管程
进程间通信
    消息传递、共享内存、管道
Pthread中的同步机制
Linux的IPC机制
</code></pre><h3 id="重点阅读和概念"><a href="#重点阅读和概念" class="headerlink" title="重点阅读和概念"></a>重点阅读和概念</h3><pre><code>重点阅读教材
第2章相关内容：2.3.6~2.3.9
</code></pre><hr>
<pre><code>管程 Hoare管程 Mesa管程
条件变量 wait/signal
Pthread中的互斥锁与条件变量
共享内存 消息传递 管道
Linux：原子操作 屏障 读写锁
</code></pre><h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><h2 id="基本概念：地址重定位"><a href="#基本概念：地址重定位" class="headerlink" title="基本概念：地址重定位"></a>基本概念：地址重定位</h2><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><pre><code>程序装载到内存才可以运行
    通常，程序以可执行文件格式保存在磁盘上

多道程序设计模型
    允许多个程序同时进入内存

每个进程有自己的地址空间
    一个进程执行时不能访问另一个进程的地址空间
    进程不能执行不适合的操作
</code></pre><h3 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h3><pre><code>多个进程与物理内存交互的问题  
包括合理分配内存等等
</code></pre><h3 id="进程地址空间-1"><a href="#进程地址空间-1" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><pre><code>内核地址空间  
用户地址空间：栈，堆，数据段，代码段，其他内容：共享库，内存映射文件
</code></pre><h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><pre><code>进程中的地址不是最终的物理地址
在进程运行前无法计算出物理地址
    因为：不能确定进程被加载到内存什么地方
</code></pre><hr>
<pre><code>需要***地址重定位***的支持
也是地址转换、地址变换、地址翻译、地址映射
</code></pre><h3 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a>地址重定位</h3><h4 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h4><pre><code>逻辑地址（相对地址，虚拟地址）
    用户程序经过编译、汇编后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余地址都相对于首地址而编址
    不能用逻辑地址在内存中读取信息
</code></pre><h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><pre><code>物理地址（绝对地址，实地址）
内存中存储单元的地址 可直接寻址
</code></pre><h4 id="地址重定位-1"><a href="#地址重定位-1" class="headerlink" title="地址重定位"></a>地址重定位</h4><pre><code>为了保证CPU执行指令时可正确访问内存单元，需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址，这一过程称为地址重定位
</code></pre><h3 id="静态重定位与动态重定位"><a href="#静态重定位与动态重定位" class="headerlink" title="静态重定位与动态重定位"></a>静态重定位与动态重定位</h3><pre><code>静态重定位： 当用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换

 一般可以由软件完成
</code></pre><hr>
<pre><code>动态重定位：
     在进程执行过程中进行地址变换
         → → 即逐条指令执行时完成地址转换 
需要硬件部件支持
</code></pre><h4 id="动态重定位实现"><a href="#动态重定位实现" class="headerlink" title="动态重定位实现"></a>动态重定位实现</h4><p><img src="http://i.imgur.com/AjKr58E.jpg" alt=""></p>
<h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><pre><code>等长划分与不等长划分：
    每一块称为分配单元

数据结构
    位图
    每个分配单元对应于位图中的一位，0表示空闲，1表示占用（或者相反）
空闲区表、已分配区表
    表中每一项记录了空闲区（或已分配区）的起始地址、长度、标志
空闲块链表
</code></pre><h3 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h3><pre><code>首次适配 first fit
    在空闲区表中找到第一个满足进程要求的空闲区
下次适配 next fit
    从上次找到的空闲区处接着查找
最佳适配 best fit
    查找整个空闲区表，找到能够满足进程要求的最小空闲区
最差适配 worst fit
    总是分配满足进程要求的最大空闲区

找到空闲区之后：
    将该空闲区分为两部分，一部分供进程使用，另一部分形成新的空闲区
</code></pre><h3 id="回收问题"><a href="#回收问题" class="headerlink" title="回收问题"></a>回收问题</h3><pre><code>内存回收算法
    当某一块归还后，前后空闲空间合并，修改内存空闲区表
    四种情况
        上相邻、下相邻、上下都相邻、上下都不相邻
</code></pre><h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><pre><code>一种经典的内存分配方案
主要思想：将内存按2的幂进行划分，组成若干空闲块链表；查找该链表找到能满足进程需求的最佳匹配块
算法：
    首先将整个可用空间看作一块： 2^U
    假设进程申请的空间大小为 s，如果满足
        2^U-1 &lt; s &lt;= 2^U，则分配整个块
    否则，将块划分为两个大小相等的伙伴，大小为2U-1
    一直划分下去直到产生大于或等于 s 的最小块
</code></pre><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="http://i.imgur.com/o03xMIo.jpg" alt=""></p>
<h2 id="基本内存管理方案"><a href="#基本内存管理方案" class="headerlink" title="基本内存管理方案"></a>基本内存管理方案</h2><pre><code>整个进程进入内存中一片连续区域
</code></pre><h3 id="单一连续区"><a href="#单一连续区" class="headerlink" title="单一连续区"></a>单一连续区</h3><pre><code>特点：一段时间内只有一个进程在内存
简单，内存利用率低
</code></pre><h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><pre><code>把内存空间分割成若干区域，称为分区
每个分区的大小可以相同也可以不同
分区大小固定不变
每个分区装一个且只能装一个进程
</code></pre><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>容易产生较长的排队队列<br>基本不用</p>
<h3 id="可变分区"><a href="#可变分区" class="headerlink" title="可变分区"></a>可变分区</h3><pre><code>根据进程的需要，把内存空闲空间分割出一个分区，分配给该进程
剩余部分成为新的空闲区
</code></pre><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>容易产生碎片化，可能导致内存利用率下降</p>
<h4 id="碎片问题解决"><a href="#碎片问题解决" class="headerlink" title="碎片问题解决"></a>碎片问题解决</h4><pre><code>碎片 → 很小的、不易利用的空闲区
        → 导致内存利用率下降
解决方案 → 紧缩技术（memory compaction）
    在内存移动程序，将所有小的空闲区合并为较大的空闲区
    又称：压缩技术，紧致技术，搬家技术
紧缩时要考虑的问题
    系统开销 ？ 移动时机 ？
</code></pre><h3 id="页式"><a href="#页式" class="headerlink" title="页式"></a>页式</h3><pre><code>设计思想
    用户进程地址空间被划分为大小相等的部分，称为页（page）或页面，从0开始编号
    内存空间按同样大小划分为大小相等的区域，称为页框（page frame），从0开始编号；也称为物理页面，页帧，内存块
    内存分配（规则）
        以页为单位进行分配，并按进程需要的页数来分配；逻辑上相邻的页，物理上不一定相邻
典型页面尺寸：4K 或 4M
</code></pre><h4 id="管理方案"><a href="#管理方案" class="headerlink" title="管理方案"></a>管理方案</h4><pre><code>划分是由系统自动完成的，对用户是透明的
逻辑地址
    页号 页内地址
</code></pre><p><img src="http://i.imgur.com/OKGbAYs.jpg" alt=""></p>
<h4 id="内存分配过程"><a href="#内存分配过程" class="headerlink" title="内存分配过程"></a>内存分配过程</h4><p><img src="http://i.imgur.com/Eb0yzM5.jpg" alt=""></p>
<p><img src="http://i.imgur.com/kA8DNSC.jpg" alt=""></p>
<h4 id="相关数据结构及地址转换"><a href="#相关数据结构及地址转换" class="headerlink" title="相关数据结构及地址转换"></a>相关数据结构及地址转换</h4><pre><code>页表
    页表项：记录了逻辑页号与页框号的对应关系
    每个进程一个页表，存放在内存
    页表起始地址保存在何处？

空闲内存管理

地址转换（硬件支持）
    CPU取到逻辑地址，自动划分为页号和页内地址；用页号查页表，得到页框号，再与页内偏移拼接成为物理地址
</code></pre><p>产生内碎片</p>
<h3 id="段式"><a href="#段式" class="headerlink" title="段式"></a>段式</h3><pre><code>设计思想
    用户进程地址空间：按程序自身的逻辑关系划分为若干个程序段，每个程序段都有一个段名

    内存空间被动态划分为若干长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定

    内存分配（规则）：以段为单位进行分配，每段在内存中占据连续空间，但各段之间可以不相邻

    逻辑地址 段号 段内地址：不能自动划分，必须显式给出
</code></pre><p>使用段表进行映射</p>
<h4 id="相关数据结构及地址转换-1"><a href="#相关数据结构及地址转换-1" class="headerlink" title="相关数据结构及地址转换"></a>相关数据结构及地址转换</h4><pre><code>段表
    每项记录了段号、段首地址和段长度之间的关系
    每个进程一个段表，存放在内存
    段表起始地址保存在何处？

物理内存管理

地址转换（硬件）
    CPU取到逻辑地址，用段号查段表，得到该段在内存的起始地址，与段内偏移地址计算出物理地址
</code></pre><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><pre><code>产生背景
    综合页式、段式方案的优点，克服二者的缺点
设计思想
用户进程划分：
    先按段划分，每一段再按页面划分
逻辑地址：
    段号    段内地址
        页号    页内地址
内存划分：同页式存储管理方案
内存分配：以页为单位进行分配
</code></pre><hr>
<pre><code>数据结构及有关操作
    段表：记录了每一段的页表始址和页表长度
    页表：记录了逻辑页号与页框号的对应关系
        每一段有一张页表，一个进程有多个页表
    空闲区管理：同页式管理
    内存分配、回收：同页式管理
地址转换
    段号    段内地址
        页号    页内地址
</code></pre><h2 id="交换技术（Swapping）"><a href="#交换技术（Swapping）" class="headerlink" title="交换技术（Swapping）"></a>交换技术（Swapping）</h2><h3 id="内存不足时如何管理"><a href="#内存不足时如何管理" class="headerlink" title="内存不足时如何管理"></a>内存不足时如何管理</h3><p>如何解决在较小的内存空间运行较大的进程呢？</p>
<h3 id="内存“扩充”技术"><a href="#内存“扩充”技术" class="headerlink" title="内存“扩充”技术"></a>内存“扩充”技术</h3><pre><code>内存紧缩技术（例如：可变分区）
覆盖技术 overlaying
交换技术 swapping
虚拟存储技术 virtual memory
</code></pre><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><p>主要用于早期的操作系统</p>
<pre><code>解决的问题 → 程序大小超过物理内存总和
程序执行过程中，程序的不同部分在内存中相互替代
    → 按照其自身的逻辑结构，将那些不会同时执行的程序段共享同一块内存区域
    → 要求程序各模块之间有明确的调用结构

程序员声明覆盖结构，操作系统完成自动覆盖
</code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="http://i.imgur.com/MI0JAbj.jpg" alt=""></p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><pre><code>设计思想
    内存空间紧张时，系统将内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域（进程在内存与磁盘之间的动态调度）

讨论：实现时遇到的问题
    进程的哪些内容要交换到磁盘？会遇到什么困难？
    在磁盘的什么位置保存被换出的进程？
    交换时机？
    如何选择被换出的进程？
    如何处理进程空间增长？
</code></pre><h4 id="关于讨论的问题"><a href="#关于讨论的问题" class="headerlink" title="关于讨论的问题"></a>关于讨论的问题</h4><pre><code>运行时创建或修改的内容：栈和堆

交换区：
    一般系统会指定一块特殊的磁盘区域作为交换空间（swap space），包含连续的磁道，操作系统可以使用底层的磁盘读写操作对其高效访问

何时需发生交换？
    只要不用就换出（很少再用）；内存空间不够或有不够的危险时换出
    与调度器结合使用

考虑进程的各种属性；不应换出处于等待I/O状态的进程
</code></pre><hr>
<p>预留出一些空间用于增长<br><img src="http://i.imgur.com/0nN34dY.jpg" alt=""></p>
<h1 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h1><pre><code>虚拟存储技术
页表及页表项的设计
地址转换过程及TLB引入
软件相关策略
页面置换算法
其他相关技术
</code></pre><h2 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><pre><code>所谓虚拟存储技术是指：当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存的工作

虚拟地址空间 即为 分配给进程的虚拟内存

虚拟地址 是 在虚拟内存中指令或数据的位置，该位置可以被访问，仿佛它是内存的一部分
</code></pre><h4 id="虚拟内存？在哪里？"><a href="#虚拟内存？在哪里？" class="headerlink" title="虚拟内存？在哪里？"></a>虚拟内存？在哪里？</h4><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><p><img src="http://i.imgur.com/4Hqqs1l.jpg" alt=""></p>
<h3 id="虚存与存储体系的关系"><a href="#虚存与存储体系的关系" class="headerlink" title="虚存与存储体系的关系"></a>虚存与存储体系的关系</h3><p><img src="http://i.imgur.com/8FUbFg0.jpg" alt=""></p>
<pre><code>把内存与磁盘有机地结合起来使用，从而得到一个容量很大的“内存”，即虚存

虚存是对内存的抽象，构建在存储体系之上，由操作系统协调各存储器的使用

虚存提供了一个比物理内存空间大得多的地址空间
</code></pre><h3 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a>存储保护</h3><p><img src="http://i.imgur.com/GOJkOch.jpg" alt=""></p>
<h3 id="虚拟页式"><a href="#虚拟页式" class="headerlink" title="虚拟页式"></a>虚拟页式</h3><pre><code>虚拟存储技术 + 页式存储管理方案
    → 虚拟页式存储管理系统
</code></pre><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><pre><code>进程开始运行之前，不是装入全部页面，而是装入一个或零个页面
之后，根据进程运行的需要，动态装入其他页面
当内存空间已满，而又需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面

以CPU时间和磁盘空间换取昂贵内存空间，这是操作系统中的资源转换技术
具体有两种方式
    1、请求调页（demand paging）
    2、预先调页（prepaging）
</code></pre><h2 id="页表及页表项的设计"><a href="#页表及页表项的设计" class="headerlink" title="页表及页表项的设计"></a>页表及页表项的设计</h2><p><img src="http://i.imgur.com/bwTuSX2.jpg" alt=""></p>
<h3 id="页表表项设计"><a href="#页表表项设计" class="headerlink" title="页表表项设计"></a>页表表项设计</h3><pre><code>页表由页表项组成
页框号、有效位、访问位、修改位、保护位
    页框号（内存块号、物理页面号、页帧号）
    有效位（驻留位、中断位）：表示该页是在内存还是在磁盘
    访问位：引用位
    修改位：此页在内存中是否被修改过
    保护位：读/可读写

    通常，页表项是硬件设计的
</code></pre><h3 id="关于页表"><a href="#关于页表" class="headerlink" title="关于页表"></a>关于页表</h3><pre><code>32位虚拟地址空间的页表规模？
    页面大小为4K；页表项大小为4字节
        则：一个进程地址空间有 ？页2^20
        其页表需要占 ？页（页表页）1024

64位虚拟地址空间
    页面大小为4K；页表项大小为8字节
    页表规模： 32,000 TB

页表页在内存中若不连续存放，则需要引入页表页的地址索引表 → 页目录（Page Directory）
多级页表
</code></pre><h3 id="二级页表结构及地址映射"><a href="#二级页表结构及地址映射" class="headerlink" title="二级页表结构及地址映射"></a>二级页表结构及地址映射</h3><p><img src="http://i.imgur.com/4Qe5Ut6.jpg" alt=""></p>
<h3 id="core-i7页表结构"><a href="#core-i7页表结构" class="headerlink" title="core i7页表结构"></a>core i7页表结构</h3><p><img src="http://i.imgur.com/Vdvkwx9.jpg" alt=""></p>
<h3 id="i386页目录项和页表项"><a href="#i386页目录项和页表项" class="headerlink" title="i386页目录项和页表项"></a>i386页目录项和页表项</h3><p><img src="http://i.imgur.com/gNoHuJY.jpg" alt=""></p>
<h3 id="引入反转（倒转）页表"><a href="#引入反转（倒转）页表" class="headerlink" title="引入反转（倒转）页表"></a>引入反转（倒转）页表</h3><pre><code>地址转换
    从虚拟地址空间出发：虚拟地址 → 查页表 → 得到页框号 → 形成物理地址
    每个进程一张页表

解决思路
从物理地址空间出发，系统建立一张页表
页表项记录进程i的某虚拟地址(虚页号)与页框号的映射关系
</code></pre><h3 id="反转页表设计"><a href="#反转页表设计" class="headerlink" title="反转页表设计"></a>反转页表设计</h3><p><img src="http://i.imgur.com/Rg72VgG.jpg" alt=""></p>
<h2 id="地址转换过程及TLB引入"><a href="#地址转换过程及TLB引入" class="headerlink" title="地址转换过程及TLB引入"></a>地址转换过程及TLB引入</h2><h3 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h3><p><img src="http://i.imgur.com/AW2wlam.jpg" alt=""></p>
<h3 id="MMU：内存管理单元"><a href="#MMU：内存管理单元" class="headerlink" title="MMU：内存管理单元"></a>MMU：内存管理单元</h3><p>将虚拟地址转换为物理地址<br><img src="http://i.imgur.com/GtUXSRh.jpg" alt=""></p>
<h4 id="地址转换（映射）"><a href="#地址转换（映射）" class="headerlink" title="地址转换（映射）"></a>地址转换（映射）</h4><p><img src="http://i.imgur.com/GBifhov.jpg" alt=""></p>
<h3 id="快表（TLB）的引入"><a href="#快表（TLB）的引入" class="headerlink" title="快表（TLB）的引入"></a>快表（TLB）的引入</h3><pre><code>问题
    页表 → 两次或两次以上的内存访问
    CPU的指令处理速度与内存指令的访问速度差异大，CPU的速度得不到充分利用

如何加快地址映射速度，以改善系统性能？

程序访问的局部性原理 → 引入快表(TLB)
</code></pre><h3 id="快表是什么"><a href="#快表是什么" class="headerlink" title="快表是什么"></a>快表是什么</h3><pre><code>Translation Look-aside Buffers  

在CPU中引入的高速缓存（Cache），可以匹配CPU的处理速率和内存的访问速度

一种随机存取型存储器，除连线寻址机制外，还有接线逻辑，能按特定的匹配标志在一个存储周期内对所有的字同时进行比较

相联存储器（associative memory）
    特点：按内容并行查找
保存正在运行进程的页表的子集(部分页表项)
</code></pre><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><pre><code>快表的大小、位置
    容量有限，可以分级
    位置在CPU的片上
快表的置换问题？
</code></pre><h3 id="加入TLB之后地址转换过程示意"><a href="#加入TLB之后地址转换过程示意" class="headerlink" title="加入TLB之后地址转换过程示意"></a>加入TLB之后地址转换过程示意</h3><p><img src="http://i.imgur.com/R4BJHEK.jpg" alt=""></p>
<h2 id="页错误Page-Fault"><a href="#页错误Page-Fault" class="headerlink" title="页错误Page Fault"></a>页错误Page Fault</h2><pre><code>又称 页面错误、页故障、页面失效
地址转换过程中硬件产生的异常

具体原因
    所访问的虚拟页面没有调入物理内存
        → 缺页异常
    页面访问违反权限（读/写、用户/内核）
    错误的访问地址
</code></pre><h3 id="缺页异常处理"><a href="#缺页异常处理" class="headerlink" title="缺页异常处理"></a>缺页异常处理</h3><pre><code>是一种Page Fault

在地址映射过程中，硬件检查页表时发现所要访问的页面不在内存，则产生该异常——缺页异常

操作系统执行缺页异常处理程序：获得磁盘地址，启动磁盘，将该页调入内存
    如果内存中有空闲页框，则分配一个页框，将新调入页装入，并修改页表中相应页表项的有效位及相应的页框号
    如果内存中有空闲页框，则分配一个页框，将新调入页装入，并修改页表中相应页表项的有效位及相应的页框号

预取一些页面
</code></pre><h2 id="软件相关策略"><a href="#软件相关策略" class="headerlink" title="软件相关策略"></a>软件相关策略</h2><h3 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h3><pre><code>驻留集大小
    给每个进程分配多少页框？

固定分配策略
    进程创建时确定
    可以根据进程类型（交互、批处理、应用类）或者基于程序员或系统管理员的需要来确定
可变分配策略
    根据缺页率评估进程局部性表现
    缺页率高→增加页框数
    缺页率低→减少页框数
    系统开销
</code></pre><h3 id="置换问题"><a href="#置换问题" class="headerlink" title="置换问题"></a>置换问题</h3><pre><code>置换范围
    计划置换页面的集合是局限在产生缺页中断的进程，还是所有进程的页框？

置换策略
    在计划置换的页框集合中，选择换出哪一个页框？
</code></pre><h4 id="置换范围"><a href="#置换范围" class="headerlink" title="置换范围"></a>置换范围</h4><pre><code>局部置换策略
仅在产生本次缺页的进程的驻留集中选择
全局置换策略
将内存中所有未锁定的页框都作为置换的候选
</code></pre><p><img src="http://i.imgur.com/nMnv3Lr.jpg" alt=""></p>
<h4 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h4><pre><code>决定置换当前内存中的哪一个页框

所有策略的目标
    → 置换最近最不可能访问的页

根据局部性原理，最近的访问历史和最近将要访问的模式间存在相关性，因此，大多数策略都基于过去的行为来预测将来的行为

注意：置换策略设计得越精致、越复杂，实现的软硬件开销就越大

约束：不能置换被锁定的页框
</code></pre><h4 id="页框锁定"><a href="#页框锁定" class="headerlink" title="页框锁定"></a>页框锁定</h4><pre><code>为什么要锁定页面？

采用虚存技术后
    开销 → 使进程运行时间变得不确定

给每一页框增加一个锁定位
通过设置相应的锁定位，不让操作系统将进程使用的页面换出内存，避免产生由交换过程带来的不确定的延迟
例如：操作系统核心代码、关键数据结构、I/O缓冲区，特别是正在I/O的内存页面

Windows中的VirtualLock和VirtualUnLock函数
</code></pre><h3 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h3><pre><code>清除：从进程的驻留集中收回页框.

虚拟页式系统工作的最佳状态：发生缺页异常时，系统中有大量的空闲页框

结论：在系统中保存一定数目的空闲页框供给比使用所有内存并在需要时搜索一个页框有更好的性能
</code></pre><hr>
<pre><code>设计一个分页守护进程（paging daemon），多数时间睡眠着，可定期唤醒以检查内存的状态

如果空闲页框过少，分页守护进程通过预定的页面置换算法选择页面换出内存

如果页面装入内存后被修改过，则将它们写回磁盘 分页守护进程可保证所有的空闲页框是“干净”的
</code></pre><hr>
<pre><code>当进程需要使用一个已置换出的页框时，如果该页框还没有被新的内容覆盖，将它从空闲页框集合中移出即可恢复该页面
</code></pre><hr>
<pre><code>页缓冲技术：

    不丢弃置换出的页，将它们放入两个表之一：如果未被修改，则放到空闲页链表中，如果修改了，则放到修改页链表中

    被修改的页定期写回磁盘(不是一次只写一个，大大减少I/O操作的数量，从而减少了磁盘访问时间)

    被置换的页仍然保留在内存中，一旦进程又要访问该页，可以迅速将它加入该进程的驻留集合(代价很小)
</code></pre><h2 id="置换算法"><a href="#置换算法" class="headerlink" title="置换算法"></a>置换算法</h2><pre><code>又称页面淘汰（替换）算法
    设计思想
    算法实现
    算法应用

最佳算法→先进先出→第二次机会→时钟算法→最近未使用→最近最少使用→最不经常使用→老化算法→工作集→工作集时钟
</code></pre><h3 id="最佳页面置换算法"><a href="#最佳页面置换算法" class="headerlink" title="最佳页面置换算法"></a>最佳页面置换算法</h3><pre><code>设计思想：
    置换以后不再需要的或最远的将来才会用到的页面
实现？
作用？
作为一种标准来衡量其他算法的性能
</code></pre><h3 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h3><pre><code>选择在内存中驻留时间最长的页并置换它
    对照：超市撤换商品
实现：页面链表法
</code></pre><h3 id="第二次机会算法"><a href="#第二次机会算法" class="headerlink" title="第二次机会算法"></a>第二次机会算法</h3><p>突然想到java的垃圾收集器的实现。。。。<br>    SCR-Second Chance<br>    按照先进先出算法选择某一页面，检查其访问位R，如果为0，则置换该页；如果为1，则给第二次机会，并将访问位置0<br><img src="http://i.imgur.com/GcKk41q.jpg" alt=""></p>
<h3 id="时钟算法"><a href="#时钟算法" class="headerlink" title="时钟算法"></a>时钟算法</h3><p><img src="http://i.imgur.com/seqF0Kr.jpg" alt=""></p>
<h3 id="最近未使用算法"><a href="#最近未使用算法" class="headerlink" title="最近未使用算法"></a>最近未使用算法</h3><pre><code>Not Recently Used
选择在最近一段时间内未使用过的一页并置换

实现：设置页表表项的两位
    访问位（R）， 修改位（M）
    如果硬件没有这些位，则可用软件模拟（做标记）

启动一个进程时，R、M位置0
R位被定期清零（复位）
</code></pre><hr>
<pre><code>发生缺页中断时，操作系统检查R，M：
    第1类：无访问，无修改
    第2类：无访问，有修改
    第3类：有访问，无修改
    第4类：有访问，有修改

算法思想：
    随机从编号最小的非空类中选择一页置换
</code></pre><h4 id="时钟算法实现"><a href="#时钟算法实现" class="headerlink" title="时钟算法实现"></a>时钟算法实现</h4><pre><code>从指针的当前位置开始，扫描页框缓冲区，选择遇到的第一个页框（r=0；m=0）用于置换(本扫描过程中，对使用位不做任何修改)

如果第1步失败，则重新扫描，选择第一个（r=0；m=1）的页框(本次扫描过程中，对每个跳过的页框，将其使用位设置成0)

如果第2步失败，指针将回到它的最初位置，并且集合中所有页框的使用位均为0。重复第1步，并且，如果有必要，重复第2步。这样将可以找到供置换的页框
</code></pre><h3 id="最近最少使用算法"><a href="#最近最少使用算法" class="headerlink" title="最近最少使用算法"></a>最近最少使用算法</h3><pre><code>Least Recently Used
选择最后一次访问时间距离当前时间最长的一页并置换
即置换未使用时间最长的一页

性能接近OPT
实现：时间戳 或 维护一个访问页的栈
    → 开销大
</code></pre><h4 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h4><p><img src="http://i.imgur.com/o8Z7jBy.jpg" alt=""></p>
<h3 id="最不经常使用算法"><a href="#最不经常使用算法" class="headerlink" title="最不经常使用算法"></a>最不经常使用算法</h3><pre><code>企图软件模拟LRU
Not Frequently Used
选择访问次数最少的页面置换

LRU的一种软件解决方案

实现：
    软件计数器，一页一个，初值为0
    每次时钟中断时，计数器加R
    发生缺页中断时，选择计数器值最小的一页置换
</code></pre><h3 id="老化算法"><a href="#老化算法" class="headerlink" title="老化算法"></a>老化算法</h3><pre><code>改进（模拟LRU）：计数器在加R前先右移一位
    R位加到计数器的最左端
</code></pre><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><img src="http://i.imgur.com/TF590Yi.jpg" alt=""></p>
<pre><code>思考：与LRU的区别
</code></pre><h3 id="页面置换算法的应用"><a href="#页面置换算法的应用" class="headerlink" title="页面置换算法的应用"></a>页面置换算法的应用</h3><pre><code>例子：
系统给某进程分配3个页框(固定分配策略)，初始为空
进程执行时，页面访问顺序为：
    2 3 2 1 5 2 4 5 3 2 5 2

要求：
计算应用FIFO、LRU、OPT算法时的缺页次数
</code></pre><hr>
<p><img src="http://i.imgur.com/NjeyTDR.jpg" alt=""></p>
<p><img src="http://i.imgur.com/hXiBAwP.jpg" alt=""></p>
<h3 id="BELADY现象"><a href="#BELADY现象" class="headerlink" title="BELADY现象"></a>BELADY现象</h3><pre><code>例子：系统给某进程分配 m个页框，初始为空
    页面访问顺序为
    1 2 3 4 1 2 5 1 2 3 4 5
采用FIFO算法，计算当 m=3 和 m=4 时的缺页中断次数

m=3时，缺页中断9次；m=4时，缺页中断10次

注：FIFO页面置换算法会产生异常现象（Belady现象），即：当分配给进程的物理页面数增加时，缺页次数反而增加
</code></pre><h2 id="工作集算法，新的缺页算法"><a href="#工作集算法，新的缺页算法" class="headerlink" title="工作集算法，新的缺页算法"></a>工作集算法，新的缺页算法</h2><h3 id="影响缺页次数的因素"><a href="#影响缺页次数的因素" class="headerlink" title="影响缺页次数的因素"></a>影响缺页次数的因素</h3><pre><code>页面置换算法
页面本身的大小 √
程序的编制方法 √
分配给进程的页框数量 √

颠簸（Thrashing，抖动）
虚存中，页面在内存与磁盘之间频繁调度，使得调度页面所需的时间比进程实际运行的时间还多，这样导致系统效率急剧下降，这种现象称为颠簸或抖动
</code></pre><h3 id="页面尺寸问题"><a href="#页面尺寸问题" class="headerlink" title="页面尺寸问题"></a>页面尺寸问题</h3><pre><code>确定页面大小对于分页的硬件设计非常重要
而对于操作系统是个可选的参数

要考虑的因素：
    内部碎片
    页表长度
    辅存的物理特性

Intel 80x86/Pentium：4096 或 4M

多种页面尺寸：为有效使用TLB带来灵活性，但给操作系统带来复杂性

最优页面大小P=sqrt(𝟐𝒔𝒆)
</code></pre><h3 id="程序编制方法对缺页次数的影响"><a href="#程序编制方法对缺页次数的影响" class="headerlink" title="程序编制方法对缺页次数的影响"></a>程序编制方法对缺页次数的影响</h3><p>分配了一个页框；页面大小为128个整数；<br>矩阵A128X128按行存放</p>
<pre><code>程序编制方法1：
for j:=1 to 128
    for i:=1 to 128
        A[i,j]:=0;
</code></pre><p>缺页率高达128^128次</p>
<hr>
<pre><code>程序编制方法2：
for i:=1 to 128
    for j:=1 to 128
        A[i,j]:=0;
</code></pre><h3 id="页框树与缺页率的关系"><a href="#页框树与缺页率的关系" class="headerlink" title="页框树与缺页率的关系"></a>页框树与缺页率的关系</h3><p><img src="http://i.imgur.com/u0UATB2.jpg" alt=""></p>
<h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><pre><code>基本思想：
    根据程序的局部性原理，一般情况下，进程在一段时间内总是集中访问一些页面，这些页面称为活跃页面，如果分配给一个进程的物理页面数太少了，使该进程所需的活跃页面不能全部装入内存，则进程在运行过程中将频繁发生中断

如果能为进程提供与活跃页面数相等的物理页面数，则可减少缺页中断次数

由Denning提出(1968)
</code></pre><hr>
<pre><code>工作集：一个进程当前正在使用的页框集合
工作集W（t，Δ）
    = 该进程在过去的Δ个虚拟时间单位中访问到的页面的集合

内容取决于三个因素：窗口越大，工作集就越大
    访页序列特性
    时刻t
    工作集窗口长度(Δ)
</code></pre><hr>
<p><img src="http://i.imgur.com/wZApwUZ.jpg" alt=""></p>
<h3 id="工作集算法"><a href="#工作集算法" class="headerlink" title="工作集算法"></a>工作集算法</h3><pre><code>基本思路：
    找出一个不在工作集中的页面并置换它

思路：
    每个页表项中有一个字段：记录该页面最后一次被访问的时间
    设置一个时间值T
    判断：
    根据一个页面的访问时间是否落在“当前时间-T”之前或之中决定其在工作集之外还是之内
</code></pre><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><pre><code>实现：
扫描所有页表项，执行操作
    1. 如果一个页面的R位是1，则将该页面的最后一次访问时间设为当前时间，将R位清零
    2. 如果一个页面的R位是0，则检查该页面的访问时间是否在“当前时间-T”之前
        (1) 如果是，则该页面为被置换的页面；
        (2) 如果不是，记录当前所有被扫描过页面的最后访问时间里面的最小值。扫描下一个页面并重复1、2
</code></pre><h2 id="页面置换算法总结"><a href="#页面置换算法总结" class="headerlink" title="页面置换算法总结"></a>页面置换算法总结</h2><p><img src="http://i.imgur.com/UfGf1qL.jpg" alt=""></p>
<h2 id="其他相关技术"><a href="#其他相关技术" class="headerlink" title="其他相关技术"></a>其他相关技术</h2><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><pre><code>基本思想
    进程通过一个系统调用(mmap)将一个文件(或部分)映射到其虚拟地址空间的一部分，访问这个文件就象访问内存中的一个大数组，而不是对文件进行读写

在多数实现中，在映射共享的页面时不会实际读入页面的内容，而是在访问页面时，页面才会被每次一页的读入，磁盘文件则被当作后备存储

当进程退出或显式地解除文件映射时，所有被修改页面会写回文件
</code></pre><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p><img src="http://i.imgur.com/P69ab36.jpg" alt=""></p>
<h3 id="支持写时复制技术"><a href="#支持写时复制技术" class="headerlink" title="支持写时复制技术"></a>支持写时复制技术</h3><p><img src="http://i.imgur.com/kZqpNzz.jpg" alt=""></p>
<h2 id="重点-5"><a href="#重点-5" class="headerlink" title="重点"></a>重点</h2><pre><code>掌握虚拟存储技术的相关概念
掌握虚拟页式存储管理方案的实现
    多级页表、反转页表、页表项、地址转换、MMU、快表(TLB)、页错误(Page Fault)、缺页异常处理

掌握相关软件策略
    驻留集、置换范围、清除策略
    置换算法：OPT、FIFO、第二次机会、时钟算法、LRU、老化、工作集

了解虚存相关的软件技术
    内存映射文件、写时复制
</code></pre><h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h3><pre><code>第3章相关内容：3.3、3.4、3.5.1、3.5.7、3.5.8、3.6.1、3.6.2

虚拟存储技术：虚拟内存（虚存） 虚拟地址空间 虚拟地址 存储体系 存储保护 内存管理单元MMU
快表TLB 页错误 缺页异常处理
页表 页表项 多级页表 反转页表
驻留集 置换范围 清除策略 页缓冲技术
页面置换算法：最佳、先进先出、第二次机会、时钟、最近最少使用、老化、工作集 模型
内存映射文件 写时复制技术
</code></pre><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><pre><code>文件与文件系统
文件的存储介质
磁盘空间管理
文件控制块及文件目录
文件的物理结构
文件系统的实现
文件系统实例——UNIX
</code></pre><h2 id="文件与文件系统"><a href="#文件与文件系统" class="headerlink" title="文件与文件系统"></a>文件与文件系统</h2><h3 id="文件是什么"><a href="#文件是什么" class="headerlink" title="文件是什么"></a>文件是什么</h3><pre><code>文件 是 对磁盘的 抽象

所谓文件 是指 一组带标识（标识即为文件名）的、在逻辑上有完整意义的信息项的序列

信息项：构成文件内容的基本单位（单个字节，或多个字节），各信息项之间具有顺序关系

文件内容的意义：由文件建立者和使用者解释
</code></pre><h3 id="如何设计一个文件系统"><a href="#如何设计一个文件系统" class="headerlink" title="如何设计一个文件系统"></a>如何设计一个文件系统</h3><h4 id="用户角度"><a href="#用户角度" class="headerlink" title="用户角度"></a>用户角度</h4><pre><code>文件系统如何呈现在用户面前：

    一个文件的组织
    如何命名？
    如何保护文件？
    可以实施的操作？
    等等
</code></pre><h4 id="操作系统的角度"><a href="#操作系统的角度" class="headerlink" title="操作系统的角度"></a>操作系统的角度</h4><pre><code>怎样组织、管理文件？

    文件的描述、分类
    文件目录的实现
    存储空间的管理
    文件的物理地址
    磁盘实际运作方式(与设备管理的接口)
    文件系统性能
    等等
</code></pre><h3 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h3><p>操作系统中统一管理信息资源的一种软件，管理文件的存储、检索、更新，提供安全可靠的共享和保护手段，并且方便用户使用</p>
<hr>
<h4 id="主要需要完成的任务"><a href="#主要需要完成的任务" class="headerlink" title="主要需要完成的任务"></a>主要需要完成的任务</h4><pre><code>统一管理磁盘空间，实施磁盘空间的分配与回收
实现文件的按名存取 名字空间 映射 磁盘空间
实现文件信息的共享，并提供文件的保护、保密手段
向用户提供一个方便使用、易于维护的接口，并向用户提供有关统计信息
提高文件系统的性能
提供与I/O系统的统一接口
</code></pre><h3 id="文件的分类"><a href="#文件的分类" class="headerlink" title="文件的分类"></a>文件的分类</h3><p>有利于提供一个统一的接口</p>
<hr>
<pre><code>按文件性质和用途分类（UNIX）
    普通文件；
    目录文件；
    特殊文件(设备文件)；
    管道文件；
    套接字
</code></pre><hr>
<pre><code>普通文件(regular)
    包含了用户的信息，一般为ASCII或二进制文件
目录文件(directory)
    管理文件系统的系统文件
特殊文件(special file)
    字符设备文件：和输入输出有关，用于模仿串行I/O设备，例如终端，打印机，网卡等
    块设备文件：磁盘
</code></pre><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><pre><code>从用户角度看文件，由用户的访问方式确定
还可以组织成堆、顺序、索引、索引顺序、散列等结构
</code></pre><p><img src="http://i.imgur.com/cbpVl9o.jpg" alt=""></p>
<h4 id="典型的文件逻辑结构与文件存取"><a href="#典型的文件逻辑结构与文件存取" class="headerlink" title="典型的文件逻辑结构与文件存取"></a>典型的文件逻辑结构与文件存取</h4><pre><code>流式文件：构成文件的基本单位是字符
    文件是有逻辑意义、无结构的一串字符的集合
记录式文件：文件由若干个记录组成，可以按记录进行读、写、查找等操作
    每条记录有其内部结构

顺序存取(访问)
随机存取(访问) 提供读写位置(当前位置) 
    例如：UNIX的seek操作
</code></pre><h2 id="文件的存储介质"><a href="#文件的存储介质" class="headerlink" title="文件的存储介质"></a>文件的存储介质</h2><h3 id="存储介质与物理块"><a href="#存储介质与物理块" class="headerlink" title="存储介质与物理块"></a>存储介质与物理块</h3><pre><code>典型的存储介质
    磁盘(包括固态盘SSD)、磁带、光盘、U盘、……
物理块（块block、簇cluster）
    信息存储、传输、分配的独立单位
    存储设备划分为大小相等的物理块，统一编号
</code></pre><h3 id="典型的磁盘结构"><a href="#典型的磁盘结构" class="headerlink" title="典型的磁盘结构"></a>典型的磁盘结构</h3><p><img src="http://i.imgur.com/4Gmd9k9.jpg" alt=""></p>
<h3 id="磁盘访问"><a href="#磁盘访问" class="headerlink" title="磁盘访问"></a>磁盘访问</h3><pre><code>一次访盘请求：
    读/写，磁盘地址（设备号，柱面号，磁头号，扇区号），内存地址（源/目）

完成过程由三个动作组成：
    寻道（时间）：磁头移动定位到指定磁道
    旋转延迟（时间）：等待指定扇区从磁头下旋转经过
    数据传输（时间）：数据在磁盘与内存之间的实际传输
</code></pre><h2 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h2><h3 id="有关数据结构"><a href="#有关数据结构" class="headerlink" title="有关数据结构"></a>有关数据结构</h3><pre><code>位图法
    用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应一位，分配物理块为0，否则为1
    申请物理块时，可以在位示图中查找为1的位，返回对应物理块号
    归还时，将对应位转置1

空闲块表
    将所有空闲块记录在一个表中，即空闲块表
    主要两项内容：起始块号，块数

空闲块链表
    把所有空闲块链成一个链
    扩展：成组链接法 √
</code></pre><h3 id="磁盘地址与块号的转换"><a href="#磁盘地址与块号的转换" class="headerlink" title="磁盘地址与块号的转换"></a>磁盘地址与块号的转换</h3><pre><code>已知块号，则磁盘地址：
    柱面号＝[块号/（磁头数×扇区数）]
    磁头号＝[（块号mod （磁头数×扇区数））/扇区数]
    扇区号＝（块号mod （磁头数×扇区数））mod 扇区数
已知磁盘地址：
    块号＝柱面号×（磁头数×扇区数）＋磁头号×扇区数＋扇区号

位图计算公式：
    已知字号i、位号j ：块号＝i×字长＋j
    已知块号：字号＝[ 块号/字长] 位号＝块号 mod 字长
</code></pre><h3 id="成组链接发设计思想"><a href="#成组链接发设计思想" class="headerlink" title="成组链接发设计思想"></a>成组链接发设计思想</h3><p><img src="http://i.imgur.com/og7vCy9.jpg" alt=""></p>
<h3 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h3><pre><code>分配一个空闲块
    查L单元（空闲块数）：
        ● 当空闲块数 &gt; 1 i ＝ L＋空闲块数；
            从 i 单元得到一个空闲块号；
            把该块分配给申请者；
            空闲块数减1；
        ● 当空闲块数＝1 取出L＋1单元内容（一组的第一块块号或0）；
            其值＝0 无空闲块，申请者等待
            其值不等于零，把该块内容复制到专用块；
            该块分配给申请者；

        把专用块内容读到内存L开始的区域
</code></pre><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><pre><code>归还一块：
    查L单元的空闲块数；
        ●当空闲块数&lt;100 空闲块数加1；
            j:＝ L＋空闲块数；
            归还块号填入j单元。
        ●当空闲块数＝100，则把内存中登记的信息写入归还块中；
            把归还块号填入L＋1单元；
            将L单元置成1。
</code></pre><h2 id="文件控制块及文件目录"><a href="#文件控制块及文件目录" class="headerlink" title="文件控制块及文件目录"></a>文件控制块及文件目录</h2><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><pre><code>文件控制块（File Control Block）
    为管理文件而设置的数据结构，保存管理文件所需的所有有关信息
    （文件属性或元数据）
</code></pre><hr>
<pre><code>常用属性
    文件名，文件号，文件大小，文件地址，创建时间，最后修改时间，最后访问时间，保护，口令，创建者，当前拥有者，文件类型，共享计数，各种标志(只读、隐藏、系统、归档、ASCII/二进制、顺序/随机访问、临时文件、锁)
</code></pre><h3 id="基本文件操作"><a href="#基本文件操作" class="headerlink" title="基本文件操作"></a>基本文件操作</h3><pre><code>Create
Delete
Open
Close
Read
WriteAppend
Seek
Get Attributes
Set Attributes
Rename
</code></pre><h4 id="用基本文件操作构建其他操作"><a href="#用基本文件操作构建其他操作" class="headerlink" title="用基本文件操作构建其他操作"></a>用基本文件操作构建其他操作</h4><p><img src="http://i.imgur.com/OxfPaj9.jpg" alt=""></p>
<hr>
<p><img src="http://i.imgur.com/fU0A0n1.jpg" alt=""></p>
<h3 id="文件目录，目录项与目录文件"><a href="#文件目录，目录项与目录文件" class="headerlink" title="文件目录，目录项与目录文件"></a>文件目录，目录项与目录文件</h3><pre><code>文件目录
    统一管理每个文件的元数据，以支持文件名到文件物理地址的转换
    将所有文件的管理信息组织在一起，即构成文件目录

目录文件
    将文件目录以文件的形式存放在磁盘上

目录项
    构成文件目录的基本单元
    目录项可以是FCB，目录是文件控制块的有序集合
</code></pre><h3 id="文件目录结构的演化"><a href="#文件目录结构的演化" class="headerlink" title="文件目录结构的演化"></a>文件目录结构的演化</h3><p><img src="http://i.imgur.com/Z8oBZSM.jpg" alt=""></p>
<h3 id="与目录相关的概念"><a href="#与目录相关的概念" class="headerlink" title="与目录相关的概念"></a>与目录相关的概念</h3><pre><code>路径名（文件名）
    –绝对路径名：从根目录开始
    –相对路径名：从当前目录开始

当前目录/工作目录

目录操作
    创建目录、删除目录
    读目录、写目录、改名、复制
</code></pre><h3 id="目录文件之间的关联"><a href="#目录文件之间的关联" class="headerlink" title="目录文件之间的关联"></a>目录文件之间的关联</h3><p><img src="http://i.imgur.com/rraj0Tg.jpg" alt=""></p>
<h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><pre><code>文件在存储介质上的存放方式

主要解决两个问题：
    假设一个文件被划分成N块，这N块在磁盘上是怎么存放的？
    其地址(块号或簇号)在FCB中是怎样记录的？
</code></pre><h3 id="连续顺序结构"><a href="#连续顺序结构" class="headerlink" title="连续顺序结构"></a>连续顺序结构</h3><p><img src="http://i.imgur.com/Gx80llz.jpg" alt=""></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><pre><code>优点
    简单
    支持顺序存取和随机存取
    所需的磁盘寻道次数和寻道时间最少
    可以同时读入多个块，检索一个块也很容易
缺点
    文件不能动态增长
        预留空间：浪费 或 重新分配和移动
    不利于文件插入和删除
    外部碎片：紧缩技术
</code></pre><h3 id="链接结构"><a href="#链接结构" class="headerlink" title="链接结构"></a>链接结构</h3><p><img src="http://i.imgur.com/uEkZTqR.jpg" alt=""></p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><pre><code>优点
    提高了磁盘空间利用率，不存在外部碎片问题
    有利于文件插入和删除
    有利于文件动态扩充
缺点
    存取速度慢，不适于随机存取
    可靠性问题，如指针出错
    更多的寻道次数和寻道时间
    链接指针占用一定的空间
</code></pre><h3 id="链接结构的一个变形-文件分配表FAT"><a href="#链接结构的一个变形-文件分配表FAT" class="headerlink" title="链接结构的一个变形:文件分配表FAT"></a>链接结构的一个变形:文件分配表FAT</h3><p><img src="http://i.imgur.com/HpAfESH.jpg" alt=""></p>
<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><pre><code>一个文件的信息存放在若干不连续物理块中

系统为每个文件建立一个专用数据结构—索引表，并将这些物理块的块号存放在该索引表中

索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块

在FCB中如何记录文件地址？
索引表存放在何处？FCB中派生出一个字段来存放索引表
</code></pre><h4 id="结构示意"><a href="#结构示意" class="headerlink" title="结构示意"></a>结构示意</h4><p><img src="http://i.imgur.com/t7FqtDl.jpg" alt=""></p>
<h4 id="索引结构的优缺点"><a href="#索引结构的优缺点" class="headerlink" title="索引结构的优缺点"></a>索引结构的优缺点</h4><pre><code>优点
    保持了链接结构的优点，又解决了其缺点
        既能顺序存取，又能随机存取
        满足了文件动态增长、插入删除的要求
        能充分利用磁盘空间
缺点
    较多的寻道次数和寻道时间
    索引表本身带来了系统开销
    如：内存、磁盘空间，存取时间
</code></pre><h4 id="组织方式"><a href="#组织方式" class="headerlink" title="组织方式"></a>组织方式</h4><pre><code>问题：索引表很大，需要多个物理块存放时怎么办？

链接方式
    一个盘块存一个索引表，多个索引表链接起来
多级索引方式
    将文件的索引表地址放在另一个索引表中
综合模式
    直接索引方式 与 间接索引方式 结合
</code></pre><h4 id="多级索引与综合模式"><a href="#多级索引与综合模式" class="headerlink" title="多级索引与综合模式"></a>多级索引与综合模式</h4><p><img src="http://i.imgur.com/Pod6xY5.jpg" alt=""></p>
<h3 id="UNIX的三级索引结构"><a href="#UNIX的三级索引结构" class="headerlink" title="UNIX的三级索引结构"></a>UNIX的三级索引结构</h3><pre><code>UNIX文件系统采用的是多级索引结构(综合模式)

    每个文件的索引表有15个索引项，每项2个字节

    前12项直接存放文件的物理块号（直接寻址）

    如果文件大于12块，则利用第13项指向一个物理块，在该块中存放文件物理块的块号（一级索引表）
        假设扇区大小为512字节，物理块等于扇区块大小，一级索引表可以存放256个物理块号

    对于更大的文件还可利用第14和第15项作为二级和三级索引表

试问：采用这种结构，一个文件最大可达到 ？个物理块
</code></pre><p><img src="http://i.imgur.com/hPpR6D8.jpg" alt=""></p>
<h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><pre><code>实现文件系统需要考虑
    磁盘上 与 内存中 的 内容布局

磁盘上
    如何启动操作系统？
    磁盘是怎样管理的？怎样获取磁盘的有关信息？
    目录文件在磁盘上怎么存放？普通文件在磁盘上怎么存放？

内存中
    当进程使用文件时，操作系统是如何支持的？
    文件系统的内存数据结构
</code></pre><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><pre><code>磁盘分区(partition)：把一个物理磁盘的存储空间划分为几个相互独立的部分，称为分区

文件卷(volume)：磁盘上的逻辑分区，由一个或多个物理块(簇)组成
    一个文件卷可以是整个磁盘 或 部分磁盘 或 跨盘（RAID）
    同一个文件卷中使用同一份管理数据进行文件分配和磁盘空闲空间管理，不同的文件卷中的管理数据是相互独立的
    一个文件卷上：包括文件系统信息、一组文件（用户文件、目录文件）、未分配空间
    块（Block）或 簇（Cluster） ： 一个或多个（2的幂）连续的扇区，可寻址数据块

格式化(format)：在一个文件卷上建立文件系统，即建立并初始化用于文件分配和磁盘空闲空间管理的管理数据
</code></pre><h3 id="磁盘上的内容"><a href="#磁盘上的内容" class="headerlink" title="磁盘上的内容"></a>磁盘上的内容</h3><p><img src="http://i.imgur.com/cBBl8TE.jpg" alt=""></p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p><img src="http://i.imgur.com/elBrrzN.jpg" alt=""></p>
<h3 id="内存中所需要的数据结构-以UNIX为例"><a href="#内存中所需要的数据结构-以UNIX为例" class="headerlink" title="内存中所需要的数据结构-以UNIX为例"></a>内存中所需要的数据结构-以UNIX为例</h3><p><img src="http://i.imgur.com/FtzqVa1.jpg" alt=""></p>
<h2 id="文件系统实例——UNIX"><a href="#文件系统实例——UNIX" class="headerlink" title="文件系统实例——UNIX"></a>文件系统实例——UNIX</h2><h3 id="文件目录检索"><a href="#文件目录检索" class="headerlink" title="文件目录检索"></a>文件目录检索</h3><p><img src="http://i.imgur.com/zborPzO.jpg" alt=""></p>
<h3 id="目录文件实现时的改进"><a href="#目录文件实现时的改进" class="headerlink" title="目录文件实现时的改进"></a>目录文件实现时的改进</h3><pre><code>提问：如何加快目录检索？

一种解决方案：
    目录项分解法：即把FCB分成两部分
        符号目录顶
            文件名，文件号
        基本目录项
            除文件名外的所有字段
</code></pre><h3 id="改进方案示意"><a href="#改进方案示意" class="headerlink" title="改进方案示意"></a>改进方案示意</h3><p><img src="http://i.imgur.com/JxZK6r8.jpg" alt=""></p>
<h3 id="改进后的好处"><a href="#改进后的好处" class="headerlink" title="改进后的好处"></a>改进后的好处</h3><pre><code>例子：
    假设 一个FCB 占 48 个字节，物理块大小 512 字节
    符号目录项占 8 字节（文件名6字节，文件号2字节）
    基本目录项占 48 – 6 = 42字节

一个目录文件有128个目录项
    分解前：占13块
    分解后：符号文件占 2 块
            基本文件占11块
查找一个文件的平均访盘次数：
    分解前：7次
    分解后：2.5次

目录文件改进后减少了访盘次数，提高了文件检索速度
</code></pre><h3 id="UNIX文件系统"><a href="#UNIX文件系统" class="headerlink" title="UNIX文件系统"></a>UNIX文件系统</h3><p><img src="http://i.imgur.com/d42pFgT.jpg" alt=""></p>
<p><img src="http://i.imgur.com/EvVlCQR.jpg" alt=""></p>
<p><img src="http://i.imgur.com/cT9MlgX.jpg" alt=""></p>
<h2 id="重点-6"><a href="#重点-6" class="headerlink" title="重点"></a>重点</h2><pre><code>掌握文件系统涉及的相关概念
    文件、文件分类、文件的逻辑结构和物理结构
掌握文件目录的实现
    文件控制块、目录项、目录文件
掌握文件系统的实现
    磁盘布局、内存数据结构
了解磁盘空间的管理
    存储介质、扇区、物理块、簇
</code></pre><h3 id="本周要求"><a href="#本周要求" class="headerlink" title="本周要求"></a>本周要求</h3><pre><code>重点阅读教材
第4章相关内容：4.1、4.2、4.3、4.5.3

重点概念
文件 文件系统 UNIX文件分类 文件逻辑结构
存储介质(磁盘) 物理块(块、簇) 文件物理结构
文件控制块FCB(文件属性) 文件目录 目录项 目录文件
磁盘上文件系统的布局 内存中数据结构
磁盘空间管理(位图、空闲块表、成组链接法)
目录项分解法
</code></pre><h1 id="文件系统2"><a href="#文件系统2" class="headerlink" title="文件系统2"></a>文件系统2</h1><p>文件系统实例—FAT<br>文件操作的实现<br>文件系统的管理<br>文件系统的安全性<br>文件系统的性能问题<br>文件系统的两个练习</p>
<h2 id="文件系统实例—FAT"><a href="#文件系统实例—FAT" class="headerlink" title="文件系统实例—FAT"></a>文件系统实例—FAT</h2><h3 id="Windows-FAT16文件系统"><a href="#Windows-FAT16文件系统" class="headerlink" title="Windows-FAT16文件系统"></a>Windows-FAT16文件系统</h3><p><img src="http://i.imgur.com/oJpAh57.jpg" alt=""></p>
<h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><p><img src="http://i.imgur.com/zeI9sce.jpg" alt=""></p>
<h3 id="DBR"><a href="#DBR" class="headerlink" title="DBR"></a>DBR</h3><p><img src="http://i.imgur.com/HXAthY5.jpg" alt=""></p>
<h3 id="BIOS参数块"><a href="#BIOS参数块" class="headerlink" title="BIOS参数块"></a>BIOS参数块</h3><p><img src="http://i.imgur.com/dyAyDXB.jpg" alt=""></p>
<h3 id="扩展BIOS参数块"><a href="#扩展BIOS参数块" class="headerlink" title="扩展BIOS参数块"></a>扩展BIOS参数块</h3><p><img src="http://i.imgur.com/8HmEBKU.jpg" alt=""></p>
<h3 id="文件分配表"><a href="#文件分配表" class="headerlink" title="文件分配表"></a>文件分配表</h3><p><img src="http://i.imgur.com/6BcN6Yq.jpg" alt=""></p>
<h3 id="FAT16目录项等同FCB"><a href="#FAT16目录项等同FCB" class="headerlink" title="FAT16目录项等同FCB"></a>FAT16目录项等同FCB</h3><p><img src="http://i.imgur.com/zFvbSW0.jpg" alt=""></p>
<h3 id="FAT32文件系统"><a href="#FAT32文件系统" class="headerlink" title="FAT32文件系统"></a>FAT32文件系统</h3><p><img src="http://i.imgur.com/cFD0BTq.jpg" alt=""></p>
<h3 id="FAT32目录项等同FCB"><a href="#FAT32目录项等同FCB" class="headerlink" title="FAT32目录项等同FCB"></a>FAT32目录项等同FCB</h3><p><img src="http://i.imgur.com/WdrBNlK.jpg" alt=""></p>
<h4 id="长文件名实现方式"><a href="#长文件名实现方式" class="headerlink" title="长文件名实现方式"></a>长文件名实现方式</h4><p><img src="http://i.imgur.com/W84CYYD.jpg" alt=""></p>
<h4 id="FAT32长文件名目录项格式"><a href="#FAT32长文件名目录项格式" class="headerlink" title="FAT32长文件名目录项格式"></a>FAT32长文件名目录项格式</h4><p><img src="http://i.imgur.com/dFXYIHM.jpg" alt=""></p>
<hr>
<p><img src="http://i.imgur.com/6Q1OUHB.jpg" alt=""></p>
<h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><p><img src="http://i.imgur.com/AE7e0jn.jpg" alt=""></p>
<h2 id="文件操作的实现"><a href="#文件操作的实现" class="headerlink" title="文件操作的实现"></a>文件操作的实现</h2><pre><code>创建文件：
    建立系统与文件的联系，实质是建立文件的FCB
    在目录中为新文件建立一个目录项，根据提供的参数及需要填写相关内容
    分配必要的存储空间

打开文件： 根据文件名在文件目录中检索，并将该文件的目录项读入内存，建立相应的数据结构，为后续的文件操作做好准备 
    文件描述符/文件句柄
</code></pre><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><img src="http://i.imgur.com/tISM41l.jpg" alt=""></p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><pre><code>为文件读写做准备
    给出文件路径名，获得文件句柄(file handle)或文件描述符(file descriptor)，需将该文件的目录项读到内存
    fd=open（文件路径名，打开方式）
        1.根据文件路径名查目录，找到目录项 (或I节点号) ；
        2.根据文件号查系统打开文件表，看文件是否已被打开；
            是 → 共享计数加1
            否则 → 将目录项 (或I节点)等信息填入系统打开文件表空表项，共享计数置为1；
        3.根据打开方式、共享说明和用户身份检查访问合法性；
        4.在用户打开文件表中获取一空表项，填写打开方式等，并指向系统打开文件表对应表项
返回信息：fd：文件描述符，是一个非负整数，用于以后读写文件
</code></pre><h3 id="指针定位"><a href="#指针定位" class="headerlink" title="指针定位"></a>指针定位</h3><pre><code>seek（fd, 新指针的位置）
    系统为每个进程打开的每个文件维护一个读写指针，即相对于文件开头的偏移地址（读写指针指向每次文件读写的开始位置，在每次读写完成后，读写指针按照读写的数据量自动后移相应数值）

由fd查用户打开文件表，找到对应的表项；
将用户打开文件表中文件读写指针位置设为新指针的位置，供后继读写命令存取该指针处文件内容
</code></pre><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><pre><code>read（文件描述符，读指针，要读的长度，内存目的地址）
    根据打开文件时得到的文件描述符，找到相应的文件控制块（目录项）
        确定读操作的合法性
        读操作合法→②，否则→出错处理
        问题：文件尚未打开？
    将文件的逻辑块号转换为物理块号
        根据参数中的读指针、长度与文件控制块中的信息，确定块号、块数、块内位移
    申请缓冲区
    启动磁盘I/O操作，把磁盘块中的信息读入缓冲区，再传送到指定的内存区（多次读盘）
    反复执行③、④直至读出所需数量的数据或读至文件尾
</code></pre><h3 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h3><pre><code>怎样实现系统调用rename（给文件重命名）？
</code></pre><h2 id="文件系统的管理"><a href="#文件系统的管理" class="headerlink" title="文件系统的管理"></a>文件系统的管理</h2><h3 id="文件系统的可靠性"><a href="#文件系统的可靠性" class="headerlink" title="文件系统的可靠性"></a>文件系统的可靠性</h3><pre><code>可靠性：
    抵御和预防各种物理性破坏和人为性破坏的能力
坏块问题
备份
    通过转储操作，形成文件或文件系统的多个副本
</code></pre><h3 id="系统文件备份"><a href="#系统文件备份" class="headerlink" title="系统文件备份"></a>系统文件备份</h3><pre><code>全量转储：
    定期将所有文件拷贝到后援存储器
增量转储：
    只转储修改过的文件，即两次备份之间的修改，减少系统开销

物理转储：
    从磁盘第0块开始，将所有磁盘块按序输出到磁带
逻辑转储：
    从一个或几个指定目录开始，递归地转储自给定日期后所有更改的文件和目录
</code></pre><h3 id="文件系统一致性"><a href="#文件系统一致性" class="headerlink" title="文件系统一致性"></a>文件系统一致性</h3><pre><code>问题的产生：
    磁盘块 → 内存 → 写回磁盘块
    若在写回之前，系统崩溃，则文件系统出现不一致

解决方案：
    设计一个实用程序，当系统再次启动时，运行该程序，检查磁盘块和目录系统
</code></pre><h3 id="磁盘块的一致性检查"><a href="#磁盘块的一致性检查" class="headerlink" title="磁盘块的一致性检查"></a>磁盘块的一致性检查</h3><p><img src="http://i.imgur.com/1ZODV8H.jpg" alt=""></p>
<h3 id="写入策略"><a href="#写入策略" class="headerlink" title="写入策略"></a>写入策略</h3><p><img src="http://i.imgur.com/aeoMgze.jpg" alt=""></p>
<h2 id="文件系统的安全性"><a href="#文件系统的安全性" class="headerlink" title="文件系统的安全性"></a>文件系统的安全性</h2><h3 id="文件保护机制"><a href="#文件保护机制" class="headerlink" title="文件保护机制"></a>文件保护机制</h3><pre><code>用于提供安全性、特定的操作系统机制
    对拥有权限的用户，应该让其进行相应操作，否则，应禁止
    防止其他用户冒充对文件进行操作
实现：
    用户身份验证：用户是谁？用户拥有什么？用户知道什么？
    访问控制
</code></pre><h3 id="文件的访问控制"><a href="#文件的访问控制" class="headerlink" title="文件的访问控制"></a>文件的访问控制</h3><p><img src="http://i.imgur.com/V4GAMsS.jpg" alt=""></p>
<h3 id="UNIX的文件访问控制"><a href="#UNIX的文件访问控制" class="headerlink" title="UNIX的文件访问控制"></a>UNIX的文件访问控制</h3><p> <img src="http://i.imgur.com/sy1vNWg.jpg" alt=""></p>
<h2 id="文件系统的性能"><a href="#文件系统的性能" class="headerlink" title="文件系统的性能"></a>文件系统的性能</h2><h3 id="文件系统的性能问题"><a href="#文件系统的性能问题" class="headerlink" title="文件系统的性能问题"></a>文件系统的性能问题</h3><pre><code>磁盘服务
    → 速度成为系统性能的主要瓶颈之一

设计文件系统应尽可能减少磁盘访问次数

提高文件系统性能的方法：
    目录项(FCB)分解、当前目录、磁盘碎片整理
    块高速缓存、磁盘调度、提前读取、合理分配磁盘空间、信息的优化分布、RAID技术… ….
</code></pre><h3 id="块高速缓存"><a href="#块高速缓存" class="headerlink" title="块高速缓存"></a>块高速缓存</h3><pre><code>又称为文件缓存、磁盘高速缓存、缓冲区高速缓存
    是指：在内存中为磁盘块设置的一个缓冲区，保存了磁盘中某些块的副本

检查所有的读请求，看所需块是否在块高速缓存中
如果在，则可直接进行读操作；否则，先将数据块读入块高速缓存，再拷贝到所需的地方
由于访问的局部性原理，当一数据块被读入块高速缓存以满足一个I/O请求时，很可能将来还会再次访问到这一数据块
</code></pre><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><pre><code>使用散列值，组织成散列表
</code></pre><p><img src="http://i.imgur.com/pUhPOp8.jpg" alt=""></p>
<h3 id="提前读取"><a href="#提前读取" class="headerlink" title="提前读取"></a>提前读取</h3><pre><code>思路：每次访问磁盘，多读入一些磁盘块
依据：程序执行的空间局部性原理
开销：较小(只有数据传输时间)
具有针对性
</code></pre><h3 id="Windows文件的访问方式"><a href="#Windows文件的访问方式" class="headerlink" title="Windows文件的访问方式"></a>Windows文件的访问方式</h3><pre><code>不使用文件缓存
     普通方式
     通过Windows提供的FlushFileBuffer函数实现
使用文件缓存
    预读取。每次读取的块大小、缓冲区大小、置换方式
    写回。写回时机选择、一致性问题
异步模式
     不再等待磁盘操作的完成
    使处理器和I/O并发工作
</code></pre><hr>
<pre><code>用户对磁盘的访问通过访问文件缓存来实现

由Windows的Cache Manager实现对缓存的控制
    读取数据的时候预取
    在Cache满时，根据LRU原则清除缓存的内容
    定期更新磁盘内容使其与Cache一致（1秒）

Write-back机制
    在用户要对磁盘写数据时，只更改Cache中的内容，由Cache Manager决定何时将更新反映到磁盘
</code></pre><hr>
<p><img src="http://i.imgur.com/HiwHH5I.jpg" alt=""></p>
<h3 id="合理分配磁盘空间"><a href="#合理分配磁盘空间" class="headerlink" title="合理分配磁盘空间"></a>合理分配磁盘空间</h3><p><img src="http://i.imgur.com/r2Um1j1.jpg" alt=""></p>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p><img src="http://i.imgur.com/0bSWgxc.jpg" alt=""></p>
<h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><p><img src="http://i.imgur.com/0XhFMmd.jpg" alt=""></p>
<h4 id="先来先服务-1"><a href="#先来先服务-1" class="headerlink" title="先来先服务"></a>先来先服务</h4><p><img src="http://i.imgur.com/ne8R5P7.jpg" alt=""></p>
<h4 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h4><p><img src="http://i.imgur.com/cvaaipU.jpg" alt=""></p>
<h4 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h4><p><img src="http://i.imgur.com/0cTg2Hz.jpg" alt=""></p>
<h4 id="单向扫描调度算法C-SCAN"><a href="#单向扫描调度算法C-SCAN" class="headerlink" title="单向扫描调度算法C-SCAN"></a>单向扫描调度算法C-SCAN</h4><pre><code>总是从0号柱面开始向里扫描

按柱面(磁道)位置选择访问者

移动臂到达最后一个柱面后，立即带动读写磁头快速返回到0号柱面

返回时不为任何的等待访问者服务

返回后可再次进行扫描

减少了新请求的最大延迟
</code></pre><h4 id="N-step-SCAN策略"><a href="#N-step-SCAN策略" class="headerlink" title="N-step-SCAN策略"></a>N-step-SCAN策略</h4><pre><code>把磁盘请求队列分成长度为N的子队列，每一次用SCAN处理一个子队列
在处理某一个队列时，新请求添加到其他子队列中
如果最后剩下的请求数小于N，则它们全都将在下一次扫描时处理
N值比较大时，其性能接近SCAN；当N＝1时，即FIFO

克服“磁头臂的粘性”
</code></pre><h4 id="FSCAN策略"><a href="#FSCAN策略" class="headerlink" title="FSCAN策略"></a>FSCAN策略</h4><pre><code>使用两个子队列
扫描开始时，所有请求都在一个队列中，而另一个队列为空
扫描过程中，所有新到的请求都放入另一个队列中
对新请求的服务延迟到处理完所有老请求之后

克服“磁头臂的粘性”
</code></pre><h4 id="旋转调度算法"><a href="#旋转调度算法" class="headerlink" title="旋转调度算法"></a>旋转调度算法</h4><pre><code>旋转调度算法
    旋转调度：根据延迟时间来决定执行次序的调度

三种情况：
    若干等待访问者请求访问同一磁头上的不同扇区
    若干等待访问者请求访问不同磁头上的不同编号的扇区
    若干等待访问者请求访问不同磁头上具有相同的扇区

解决方案：
    对于前两种情况：总是让首先到达读写磁头位置下的扇区先进行传送操作
    对于第三种情况：这些扇区同时到达读写磁头位置下，可任意选择一个读写磁头进行传送操作
</code></pre><p><img src="http://i.imgur.com/PmmyzaM.jpg" alt=""></p>
<h3 id="信息的优化分布"><a href="#信息的优化分布" class="headerlink" title="信息的优化分布"></a>信息的优化分布</h3><p><img src="http://i.imgur.com/GInbPIl.jpg" alt=""></p>
<h4 id="记录的成组与分解"><a href="#记录的成组与分解" class="headerlink" title="记录的成组与分解"></a>记录的成组与分解</h4><p><img src="http://i.imgur.com/dEFMsFV.jpg" alt=""></p>
<h3 id="RAID技术"><a href="#RAID技术" class="headerlink" title="RAID技术"></a>RAID技术</h3><p><img src="http://i.imgur.com/cVKm03X.jpg" alt=""></p>
<h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p><img src="http://i.imgur.com/GMauPrZ.jpg" alt=""></p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><img src="http://i.imgur.com/5WYcjiP.jpg" alt=""></p>
<hr>
<p><img src="http://i.imgur.com/Qi79YU9.jpg" alt=""></p>
<hr>
<p><img src="http://i.imgur.com/nDBF9Ba.jpg" alt=""></p>
<h2 id="文件系统的两个练习"><a href="#文件系统的两个练习" class="headerlink" title="文件系统的两个练习"></a>文件系统的两个练习</h2><p><img src="http://i.imgur.com/HX2pl0F.jpg" alt=""></p>
<hr>
<p><img src="http://i.imgur.com/nBH0yIj.jpg" alt=""></p>
<h2 id="重点-7"><a href="#重点-7" class="headerlink" title="重点"></a>重点</h2><pre><code>掌握文件操作的实现流程
掌握文件系统可靠性、一致性、写入策略、安全性的基本概念
掌握提高文件系统性能的各种方法
理解FAT文件系统的实现

重点阅读教材
第4章相关内容：4.4、4.5

重点概念
文件操作及实现 文件系统的可靠性 文件系统的一致性
文件写入策略 文件的保护机制
文件系统的性能：目录项分解法、当前目录、磁盘高速缓存、提前预取、磁盘调度、RAID技术、合理分配磁盘空间、记录的成组与分解、信息的优化分布
</code></pre>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/21/基础课程系列/计算机组成原理/" rel="next" title="计算机组成">
                <i class="fa fa-chevron-left"></i> 计算机组成
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/22/SSM系列/spring揭秘读书笔记/" rel="prev" title="spring揭秘">
                spring揭秘 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="lily" />
          <p class="site-author-name" itemprop="name">lily</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统概述"><span class="nav-number">1.</span> <span class="nav-text">操作系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统做了什么？"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统做了什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从上述步骤中得到了什么"><span class="nav-number">1.1.1.</span> <span class="nav-text">从上述步骤中得到了什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#换个角度看用户程序的执行"><span class="nav-number">1.1.2.</span> <span class="nav-text">换个角度看用户程序的执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的定义与作用"><span class="nav-number">1.2.</span> <span class="nav-text">操作系统的定义与作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——"><span class="nav-number">1.2.1.</span> <span class="nav-text">操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#几个关键词"><span class="nav-number">1.2.2.</span> <span class="nav-text">几个关键词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三个作用"><span class="nav-number">1.2.3.</span> <span class="nav-text">三个作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#资源的管理者"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">资源的管理者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#各种系统服务的提供者"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">各种系统服务的提供者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对硬件机器的扩展"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">对硬件机器的扩展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的主要特征"><span class="nav-number">1.3.</span> <span class="nav-text">操作系统的主要特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发"><span class="nav-number">1.3.1.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享"><span class="nav-number">1.3.2.</span> <span class="nav-text">共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟"><span class="nav-number">1.3.3.</span> <span class="nav-text">虚拟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机"><span class="nav-number">1.3.4.</span> <span class="nav-text">随机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#典型操作系统的架构"><span class="nav-number">1.4.</span> <span class="nav-text">典型操作系统的架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows架构"><span class="nav-number">1.4.1.</span> <span class="nav-text">Windows架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX架构"><span class="nav-number">1.4.2.</span> <span class="nav-text">UNIX架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux内核组间"><span class="nav-number">1.4.3.</span> <span class="nav-text">linux内核组间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的分类"><span class="nav-number">1.5.</span> <span class="nav-text">操作系统的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的发展历程"><span class="nav-number">1.5.1.</span> <span class="nav-text">操作系统的发展历程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">目标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传统操作系统的分类"><span class="nav-number">1.5.2.</span> <span class="nav-text">传统操作系统的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#批处理操作系统"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">批处理操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分时系统"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">分时系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过操作系统"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">通过操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实时操作系统"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">实时操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#个人计算机操作系统"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">个人计算机操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络操作系统"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">网络操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式操作系统"><span class="nav-number">1.5.2.7.</span> <span class="nav-text">分布式操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#嵌入式操作系统"><span class="nav-number">1.5.2.8.</span> <span class="nav-text">嵌入式操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#智能卡操作系统"><span class="nav-number">1.5.2.9.</span> <span class="nav-text">智能卡操作系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点"><span class="nav-number">1.6.</span> <span class="nav-text">重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统原理"><span class="nav-number">2.</span> <span class="nav-text">操作系统原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#处理器状态"><span class="nav-number">2.1.</span> <span class="nav-text">处理器状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU"><span class="nav-number">2.1.1.</span> <span class="nav-text">CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#控制和状态寄存器"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">控制和状态寄存器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的需求，保护"><span class="nav-number">2.1.2.</span> <span class="nav-text">操作系统的需求，保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理器的状态"><span class="nav-number">2.1.3.</span> <span class="nav-text">处理器的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特权指令和非特权指令"><span class="nav-number">2.1.4.</span> <span class="nav-text">特权指令和非特权指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例"><span class="nav-number">2.1.5.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU状态之间的转换"><span class="nav-number">2.1.6.</span> <span class="nav-text">CPU状态之间的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中断和异常机制"><span class="nav-number">2.2.</span> <span class="nav-text">中断和异常机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">2.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么引入中断与异常"><span class="nav-number">2.2.2.</span> <span class="nav-text">为什么引入中断与异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件"><span class="nav-number">2.2.3.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">2.2.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作原理"><span class="nav-number">2.3.</span> <span class="nav-text">工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中断响应"><span class="nav-number">2.3.1.</span> <span class="nav-text">中断响应</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#过程示意"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">过程示意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断向量表"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">中断向量表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过程"><span class="nav-number">2.3.2.</span> <span class="nav-text">过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断处理程序"><span class="nav-number">2.3.3.</span> <span class="nav-text">中断处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-1"><span class="nav-number">2.3.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例：x86处理器"><span class="nav-number">2.4.</span> <span class="nav-text">实例：x86处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x86处理器对中断的支持"><span class="nav-number">2.5.</span> <span class="nav-text">x86处理器对中断的支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统调用机制"><span class="nav-number">2.6.</span> <span class="nav-text">系统调用机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用"><span class="nav-number">2.6.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型系统调用"><span class="nav-number">2.6.2.</span> <span class="nav-text">典型系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统调用机制的设计"><span class="nav-number">2.6.3.</span> <span class="nav-text">系统调用机制的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数传递过程问题"><span class="nav-number">2.6.4.</span> <span class="nav-text">参数传递过程问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行过程"><span class="nav-number">2.6.5.</span> <span class="nav-text">执行过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于x86处理器的linux的系统调用实现"><span class="nav-number">2.7.</span> <span class="nav-text">基于x86处理器的linux的系统调用实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过程-1"><span class="nav-number">2.7.1.</span> <span class="nav-text">过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用执行流程"><span class="nav-number">2.7.2.</span> <span class="nav-text">调用执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OS底层工作步骤"><span class="nav-number">2.7.3.</span> <span class="nav-text">OS底层工作步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-1"><span class="nav-number">2.8.</span> <span class="nav-text">重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程-线程模型"><span class="nav-number">3.</span> <span class="nav-text">进程/线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程基本概念"><span class="nav-number">3.1.</span> <span class="nav-text">进程基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多道程序设计"><span class="nav-number">3.1.1.</span> <span class="nav-text">多道程序设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发环境与并发程序"><span class="nav-number">3.1.2.</span> <span class="nav-text">并发环境与并发程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的定义"><span class="nav-number">3.1.3.</span> <span class="nav-text">进程的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程控制块PCB"><span class="nav-number">3.1.4.</span> <span class="nav-text">进程控制块PCB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux：task-struct"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">Linux：task_struct</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程状态及状态转换"><span class="nav-number">3.2.</span> <span class="nav-text">进程状态及状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的三种基本状态"><span class="nav-number">3.2.1.</span> <span class="nav-text">进程的三种基本状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三状态模型以及状态转换"><span class="nav-number">3.2.2.</span> <span class="nav-text">三状态模型以及状态转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他状态"><span class="nav-number">3.2.3.</span> <span class="nav-text">其他状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五状态进程模型"><span class="nav-number">3.2.4.</span> <span class="nav-text">五状态进程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七状态进程模型"><span class="nav-number">3.2.5.</span> <span class="nav-text">七状态进程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux状态示意图"><span class="nav-number">3.2.6.</span> <span class="nav-text">linux状态示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程队列"><span class="nav-number">3.2.7.</span> <span class="nav-text">进程队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五状态进程的队列模型"><span class="nav-number">3.2.8.</span> <span class="nav-text">五状态进程的队列模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程控制"><span class="nav-number">3.3.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的创建"><span class="nav-number">3.3.1.</span> <span class="nav-text">进程的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的撤销"><span class="nav-number">3.3.2.</span> <span class="nav-text">进程的撤销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程阻塞"><span class="nav-number">3.3.3.</span> <span class="nav-text">进程阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unix的几个进程控制操作"><span class="nav-number">3.3.4.</span> <span class="nav-text">Unix的几个进程控制操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Unix的FORK-的实现"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">Unix的FORK()的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解进程概念"><span class="nav-number">3.4.</span> <span class="nav-text">深入理解进程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于进程的讨论"><span class="nav-number">3.4.1.</span> <span class="nav-text">关于进程的讨论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程与程序的区别"><span class="nav-number">3.4.2.</span> <span class="nav-text">进程与程序的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程地址空间"><span class="nav-number">3.4.3.</span> <span class="nav-text">进程地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-1"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程地址空间图示"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">进程地址空间图示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程映像"><span class="nav-number">3.4.4.</span> <span class="nav-text">进程映像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文切换"><span class="nav-number">3.4.5.</span> <span class="nav-text">上下文切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的引入"><span class="nav-number">3.5.</span> <span class="nav-text">线程的引入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么在进程中再派生线程？"><span class="nav-number">3.5.1.</span> <span class="nav-text">为什么在进程中再派生线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型的应用"><span class="nav-number">3.5.2.</span> <span class="nav-text">典型的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如果没有线程"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">如果没有线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#web服务器"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">web服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开销的考虑"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">开销的考虑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">3.5.3.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的基本概念"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">线程的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的属性"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">线程的属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程机制的实现"><span class="nav-number">3.6.</span> <span class="nav-text">线程机制的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用户级线程"><span class="nav-number">3.6.1.</span> <span class="nav-text">用户级线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#POSIX线程库"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">POSIX线程库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-2"><span class="nav-number">3.6.1.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心级线程"><span class="nav-number">3.6.2.</span> <span class="nav-text">核心级线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#混合模型"><span class="nav-number">3.6.3.</span> <span class="nav-text">混合模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点小结"><span class="nav-number">3.7.</span> <span class="nav-text">重点小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#处理器调度"><span class="nav-number">4.</span> <span class="nav-text">处理器调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念-1"><span class="nav-number">4.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是处理器调度"><span class="nav-number">4.1.1.</span> <span class="nav-text">什么是处理器调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#要解决的三个问题"><span class="nav-number">4.1.2.</span> <span class="nav-text">要解决的三个问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度的时机"><span class="nav-number">4.1.3.</span> <span class="nav-text">调度的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时机"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程切换"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">进程切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具体步骤"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">具体步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开销"><span class="nav-number">4.1.3.4.</span> <span class="nav-text">开销</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度算法的设计"><span class="nav-number">4.1.4.</span> <span class="nav-text">调度算法的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#衡量指标"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">衡量指标</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计调度算法要考虑的几个问题"><span class="nav-number">4.2.</span> <span class="nav-text">设计调度算法要考虑的几个问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程优先级"><span class="nav-number">4.2.1.</span> <span class="nav-text">进程优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程就绪队列组织"><span class="nav-number">4.2.2.</span> <span class="nav-text">进程就绪队列组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抢占与非抢占"><span class="nav-number">4.2.3.</span> <span class="nav-text">抢占与非抢占</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO密集型与CPU密集型进程"><span class="nav-number">4.2.4.</span> <span class="nav-text">IO密集型与CPU密集型进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间片"><span class="nav-number">4.2.5.</span> <span class="nav-text">时间片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#批处理系统的调度算法"><span class="nav-number">4.3.</span> <span class="nav-text">批处理系统的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#先来先服务"><span class="nav-number">4.3.1.</span> <span class="nav-text">先来先服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#短作业优先"><span class="nav-number">4.3.2.</span> <span class="nav-text">短作业优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最高相应比优先HRRN"><span class="nav-number">4.3.3.</span> <span class="nav-text">最高相应比优先HRRN</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交互式系统的调度算法"><span class="nav-number">4.4.</span> <span class="nav-text">交互式系统的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#轮转调度"><span class="nav-number">4.4.1.</span> <span class="nav-text">轮转调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟轮转法"><span class="nav-number">4.4.2.</span> <span class="nav-text">虚拟轮转法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最高优先级调度"><span class="nav-number">4.4.3.</span> <span class="nav-text">最高优先级调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级反转"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">优先级反转</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多级反馈队列调度算法、各种调度算法小结等"><span class="nav-number">4.5.</span> <span class="nav-text">多级反馈队列调度算法、各种调度算法小结等</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多级反馈队列调度算法"><span class="nav-number">4.5.1.</span> <span class="nav-text">多级反馈队列调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-3"><span class="nav-number">4.5.2.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多处理器调度算法设计"><span class="nav-number">4.5.3.</span> <span class="nav-text">多处理器调度算法设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#典型操作系统的调度算法"><span class="nav-number">4.6.</span> <span class="nav-text">典型操作系统的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LINUX调度算法的发展历史"><span class="nav-number">4.6.1.</span> <span class="nav-text">LINUX调度算法的发展历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows线程调度"><span class="nav-number">4.6.2.</span> <span class="nav-text">Windows线程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的时间配额"><span class="nav-number">4.6.3.</span> <span class="nav-text">线程的时间配额</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度策略"><span class="nav-number">4.6.4.</span> <span class="nav-text">调度策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#抢占"><span class="nav-number">4.6.4.1.</span> <span class="nav-text">抢占</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间配额用完"><span class="nav-number">4.6.4.2.</span> <span class="nav-text">时间配额用完</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程优先级与时间配额调整"><span class="nav-number">4.6.5.</span> <span class="nav-text">线程优先级与时间配额调整</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程优先级提升"><span class="nav-number">4.6.5.1.</span> <span class="nav-text">线程优先级提升</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-2"><span class="nav-number">4.7.</span> <span class="nav-text">重点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本讲重点"><span class="nav-number">4.7.1.</span> <span class="nav-text">本讲重点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#要求"><span class="nav-number">4.7.2.</span> <span class="nav-text">要求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步机制1"><span class="nav-number">5.</span> <span class="nav-text">同步机制1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的并发执行"><span class="nav-number">5.1.</span> <span class="nav-text">进程的并发执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程并发执行"><span class="nav-number">5.1.1.</span> <span class="nav-text">进程并发执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从进程的特征触发"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">从进程的特征触发</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发执行过程分析"><span class="nav-number">5.1.2.</span> <span class="nav-text">并发执行过程分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程前趋图"><span class="nav-number">5.1.3.</span> <span class="nav-text">进程前趋图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程互斥"><span class="nav-number">5.2.</span> <span class="nav-text">进程互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#竞争条件"><span class="nav-number">5.2.1.</span> <span class="nav-text">竞争条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-2"><span class="nav-number">5.2.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#临界区的使用原则"><span class="nav-number">5.2.3.</span> <span class="nav-text">临界区的使用原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决方案"><span class="nav-number">5.2.4.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件解决方案"><span class="nav-number">5.3.</span> <span class="nav-text">软件解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法1"><span class="nav-number">5.3.1.</span> <span class="nav-text">解法1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法2"><span class="nav-number">5.3.2.</span> <span class="nav-text">解法2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法3"><span class="nav-number">5.3.3.</span> <span class="nav-text">解法3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法4：DEKKER算法"><span class="nav-number">5.3.4.</span> <span class="nav-text">解法4：DEKKER算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法5：PETTERSON算法"><span class="nav-number">5.3.5.</span> <span class="nav-text">解法5：PETTERSON算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程互斥的硬件解决方法"><span class="nav-number">5.4.</span> <span class="nav-text">进程互斥的硬件解决方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中断屏蔽方法"><span class="nav-number">5.4.1.</span> <span class="nav-text">中断屏蔽方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“测试并加锁”指令"><span class="nav-number">5.4.2.</span> <span class="nav-text">“测试并加锁”指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换指令"><span class="nav-number">5.4.3.</span> <span class="nav-text">交换指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结-4"><span class="nav-number">5.5.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的同步"><span class="nav-number">5.6.</span> <span class="nav-text">进程的同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者消费者问题"><span class="nav-number">5.6.1.</span> <span class="nav-text">生产者消费者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题描述"><span class="nav-number">5.6.1.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#要解决的问题："><span class="nav-number">5.6.1.2.</span> <span class="nav-text">要解决的问题：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决"><span class="nav-number">5.6.1.3.</span> <span class="nav-text">解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码实现"><span class="nav-number">5.6.1.4.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他例子"><span class="nav-number">5.6.2.</span> <span class="nav-text">其他例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量及P、V操作"><span class="nav-number">5.7.</span> <span class="nav-text">信号量及P、V操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#P，V操作定义"><span class="nav-number">5.7.1.</span> <span class="nav-text">P，V操作定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有关说明"><span class="nav-number">5.7.1.1.</span> <span class="nav-text">有关说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PV操作解决进行间互斥问题"><span class="nav-number">5.7.2.</span> <span class="nav-text">PV操作解决进行间互斥问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者消费者问题-1"><span class="nav-number">5.8.</span> <span class="nav-text">生产者消费者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用信号量的解法"><span class="nav-number">5.8.1.</span> <span class="nav-text">用信号量的解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#讨论"><span class="nav-number">5.8.2.</span> <span class="nav-text">讨论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读者写者问题"><span class="nav-number">5.9.</span> <span class="nav-text">读者写者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量解法"><span class="nav-number">5.9.1.</span> <span class="nav-text">信号量解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一类问题，读者优先"><span class="nav-number">5.9.2.</span> <span class="nav-text">第一类问题，读者优先</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法"><span class="nav-number">5.9.2.1.</span> <span class="nav-text">解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化"><span class="nav-number">5.9.2.2.</span> <span class="nav-text">优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LINUX提供的读写锁"><span class="nav-number">5.9.3.</span> <span class="nav-text">LINUX提供的读写锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-3"><span class="nav-number">5.10.</span> <span class="nav-text">重点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#要求-1"><span class="nav-number">5.10.1.</span> <span class="nav-text">要求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步互斥机制2"><span class="nav-number">6.</span> <span class="nav-text">同步互斥机制2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#管程的基本概念"><span class="nav-number">6.1.</span> <span class="nav-text">管程的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么会出现管程"><span class="nav-number">6.1.1.</span> <span class="nav-text">为什么会出现管程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">6.1.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有什么保证"><span class="nav-number">6.1.3.</span> <span class="nav-text">有什么保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#会遇到什么问题"><span class="nav-number">6.1.4.</span> <span class="nav-text">会遇到什么问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hoare管程"><span class="nav-number">6.2.</span> <span class="nav-text">Hoare管程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#说明"><span class="nav-number">6.2.1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件变量的实现"><span class="nav-number">6.2.2.</span> <span class="nav-text">条件变量的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管程的实现"><span class="nav-number">6.3.</span> <span class="nav-text">管程的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#管程解决生产者消费者问题"><span class="nav-number">6.3.1.</span> <span class="nav-text">管程解决生产者消费者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者消费者"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">生产者消费者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管程的实现-1"><span class="nav-number">6.3.1.2.</span> <span class="nav-text">管程的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java有类似管程的机制"><span class="nav-number">6.3.2.</span> <span class="nav-text">java有类似管程的机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MESA管程"><span class="nav-number">6.4.</span> <span class="nav-text">MESA管程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用NOTIFY要注意的问题"><span class="nav-number">6.4.1.</span> <span class="nav-text">使用NOTIFY要注意的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决生产者消费者问题"><span class="nav-number">6.4.2.</span> <span class="nav-text">解决生产者消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改进"><span class="nav-number">6.4.3.</span> <span class="nav-text">改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引入BROADCAST"><span class="nav-number">6.4.4.</span> <span class="nav-text">引入BROADCAST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较"><span class="nav-number">6.4.5.</span> <span class="nav-text">比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-5"><span class="nav-number">6.4.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PTHREAD中的同步机制"><span class="nav-number">6.5.</span> <span class="nav-text">PTHREAD中的同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者消费者问题-2"><span class="nav-number">6.5.1.</span> <span class="nav-text">生产者消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cond-wait"><span class="nav-number">6.5.2.</span> <span class="nav-text">cond_wait</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信"><span class="nav-number">6.6.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么需要通信机制？"><span class="nav-number">6.6.1.</span> <span class="nav-text">为什么需要通信机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本通信方式"><span class="nav-number">6.6.2.</span> <span class="nav-text">基本通信方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息传递"><span class="nav-number">6.6.3.</span> <span class="nav-text">消息传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PV操作的实现send"><span class="nav-number">6.6.3.1.</span> <span class="nav-text">PV操作的实现send</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道"><span class="nav-number">6.6.4.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#套接字"><span class="nav-number">6.6.5.</span> <span class="nav-text">套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程过程调用"><span class="nav-number">6.6.6.</span> <span class="nav-text">远程过程调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#典型操作系统中的IPC机制"><span class="nav-number">6.7.</span> <span class="nav-text">典型操作系统中的IPC机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-2"><span class="nav-number">6.7.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux的进程通信机制"><span class="nav-number">6.7.2.</span> <span class="nav-text">Linux的进程通信机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原子操作"><span class="nav-number">6.7.2.1.</span> <span class="nav-text">原子操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#屏障：栅栏"><span class="nav-number">6.7.2.2.</span> <span class="nav-text">屏障：栅栏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-4"><span class="nav-number">6.8.</span> <span class="nav-text">重点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重点阅读和概念"><span class="nav-number">6.8.1.</span> <span class="nav-text">重点阅读和概念</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#存储管理"><span class="nav-number">7.</span> <span class="nav-text">存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念：地址重定位"><span class="nav-number">7.1.</span> <span class="nav-text">基本概念：地址重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本内容"><span class="nav-number">7.1.1.</span> <span class="nav-text">基本内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#需要解决的问题"><span class="nav-number">7.1.2.</span> <span class="nav-text">需要解决的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程地址空间-1"><span class="nav-number">7.1.3.</span> <span class="nav-text">进程地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#讨论-1"><span class="nav-number">7.1.4.</span> <span class="nav-text">讨论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址重定位"><span class="nav-number">7.1.5.</span> <span class="nav-text">地址重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑地址"><span class="nav-number">7.1.5.1.</span> <span class="nav-text">逻辑地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物理地址"><span class="nav-number">7.1.5.2.</span> <span class="nav-text">物理地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地址重定位-1"><span class="nav-number">7.1.5.3.</span> <span class="nav-text">地址重定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态重定位与动态重定位"><span class="nav-number">7.1.6.</span> <span class="nav-text">静态重定位与动态重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态重定位实现"><span class="nav-number">7.1.6.1.</span> <span class="nav-text">动态重定位实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理内存管理"><span class="nav-number">7.2.</span> <span class="nav-text">物理内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#空闲内存管理"><span class="nav-number">7.2.1.</span> <span class="nav-text">空闲内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配算法"><span class="nav-number">7.2.2.</span> <span class="nav-text">内存分配算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回收问题"><span class="nav-number">7.2.3.</span> <span class="nav-text">回收问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#伙伴系统"><span class="nav-number">7.3.</span> <span class="nav-text">伙伴系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">7.3.1.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本内存管理方案"><span class="nav-number">7.4.</span> <span class="nav-text">基本内存管理方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一连续区"><span class="nav-number">7.4.1.</span> <span class="nav-text">单一连续区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#固定分区"><span class="nav-number">7.4.2.</span> <span class="nav-text">固定分区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例"><span class="nav-number">7.4.2.1.</span> <span class="nav-text">案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变分区"><span class="nav-number">7.4.3.</span> <span class="nav-text">可变分区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题"><span class="nav-number">7.4.3.1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#碎片问题解决"><span class="nav-number">7.4.3.2.</span> <span class="nav-text">碎片问题解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页式"><span class="nav-number">7.4.4.</span> <span class="nav-text">页式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#管理方案"><span class="nav-number">7.4.4.1.</span> <span class="nav-text">管理方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存分配过程"><span class="nav-number">7.4.4.2.</span> <span class="nav-text">内存分配过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关数据结构及地址转换"><span class="nav-number">7.4.4.3.</span> <span class="nav-text">相关数据结构及地址转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段式"><span class="nav-number">7.4.5.</span> <span class="nav-text">段式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相关数据结构及地址转换-1"><span class="nav-number">7.4.5.1.</span> <span class="nav-text">相关数据结构及地址转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段页式"><span class="nav-number">7.4.6.</span> <span class="nav-text">段页式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交换技术（Swapping）"><span class="nav-number">7.5.</span> <span class="nav-text">交换技术（Swapping）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存不足时如何管理"><span class="nav-number">7.5.1.</span> <span class="nav-text">内存不足时如何管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存“扩充”技术"><span class="nav-number">7.5.2.</span> <span class="nav-text">内存“扩充”技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖技术"><span class="nav-number">7.5.3.</span> <span class="nav-text">覆盖技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例"><span class="nav-number">7.5.3.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换技术"><span class="nav-number">7.5.4.</span> <span class="nav-text">交换技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关于讨论的问题"><span class="nav-number">7.5.4.1.</span> <span class="nav-text">关于讨论的问题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#存储模型"><span class="nav-number">8.</span> <span class="nav-text">存储模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟存储技术"><span class="nav-number">8.1.</span> <span class="nav-text">虚拟存储技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-3"><span class="nav-number">8.1.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟内存？在哪里？"><span class="nav-number">8.1.1.1.</span> <span class="nav-text">虚拟内存？在哪里？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储器的层次结构"><span class="nav-number">8.1.2.</span> <span class="nav-text">存储器的层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚存与存储体系的关系"><span class="nav-number">8.1.3.</span> <span class="nav-text">虚存与存储体系的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储保护"><span class="nav-number">8.1.4.</span> <span class="nav-text">存储保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟页式"><span class="nav-number">8.1.5.</span> <span class="nav-text">虚拟页式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本思想"><span class="nav-number">8.1.5.1.</span> <span class="nav-text">基本思想</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页表及页表项的设计"><span class="nav-number">8.2.</span> <span class="nav-text">页表及页表项的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#页表表项设计"><span class="nav-number">8.2.1.</span> <span class="nav-text">页表表项设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于页表"><span class="nav-number">8.2.2.</span> <span class="nav-text">关于页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二级页表结构及地址映射"><span class="nav-number">8.2.3.</span> <span class="nav-text">二级页表结构及地址映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#core-i7页表结构"><span class="nav-number">8.2.4.</span> <span class="nav-text">core i7页表结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i386页目录项和页表项"><span class="nav-number">8.2.5.</span> <span class="nav-text">i386页目录项和页表项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引入反转（倒转）页表"><span class="nav-number">8.2.6.</span> <span class="nav-text">引入反转（倒转）页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反转页表设计"><span class="nav-number">8.2.7.</span> <span class="nav-text">反转页表设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地址转换过程及TLB引入"><span class="nav-number">8.3.</span> <span class="nav-text">地址转换过程及TLB引入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#地址转换过程"><span class="nav-number">8.3.1.</span> <span class="nav-text">地址转换过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MMU：内存管理单元"><span class="nav-number">8.3.2.</span> <span class="nav-text">MMU：内存管理单元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#地址转换（映射）"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">地址转换（映射）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快表（TLB）的引入"><span class="nav-number">8.3.3.</span> <span class="nav-text">快表（TLB）的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快表是什么"><span class="nav-number">8.3.4.</span> <span class="nav-text">快表是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题-1"><span class="nav-number">8.3.4.1.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加入TLB之后地址转换过程示意"><span class="nav-number">8.3.5.</span> <span class="nav-text">加入TLB之后地址转换过程示意</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页错误Page-Fault"><span class="nav-number">8.4.</span> <span class="nav-text">页错误Page Fault</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缺页异常处理"><span class="nav-number">8.4.1.</span> <span class="nav-text">缺页异常处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件相关策略"><span class="nav-number">8.5.</span> <span class="nav-text">软件相关策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#驻留集"><span class="nav-number">8.5.1.</span> <span class="nav-text">驻留集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#置换问题"><span class="nav-number">8.5.2.</span> <span class="nav-text">置换问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#置换范围"><span class="nav-number">8.5.2.1.</span> <span class="nav-text">置换范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#置换策略"><span class="nav-number">8.5.2.2.</span> <span class="nav-text">置换策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页框锁定"><span class="nav-number">8.5.2.3.</span> <span class="nav-text">页框锁定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清除策略"><span class="nav-number">8.5.3.</span> <span class="nav-text">清除策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#置换算法"><span class="nav-number">8.6.</span> <span class="nav-text">置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最佳页面置换算法"><span class="nav-number">8.6.1.</span> <span class="nav-text">最佳页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#先进先出算法"><span class="nav-number">8.6.2.</span> <span class="nav-text">先进先出算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二次机会算法"><span class="nav-number">8.6.3.</span> <span class="nav-text">第二次机会算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时钟算法"><span class="nav-number">8.6.4.</span> <span class="nav-text">时钟算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最近未使用算法"><span class="nav-number">8.6.5.</span> <span class="nav-text">最近未使用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时钟算法实现"><span class="nav-number">8.6.5.1.</span> <span class="nav-text">时钟算法实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最近最少使用算法"><span class="nav-number">8.6.6.</span> <span class="nav-text">最近最少使用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#硬件实现"><span class="nav-number">8.6.6.1.</span> <span class="nav-text">硬件实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最不经常使用算法"><span class="nav-number">8.6.7.</span> <span class="nav-text">最不经常使用算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#老化算法"><span class="nav-number">8.6.8.</span> <span class="nav-text">老化算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#例子-1"><span class="nav-number">8.6.8.1.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页面置换算法的应用"><span class="nav-number">8.6.9.</span> <span class="nav-text">页面置换算法的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BELADY现象"><span class="nav-number">8.6.10.</span> <span class="nav-text">BELADY现象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作集算法，新的缺页算法"><span class="nav-number">8.7.</span> <span class="nav-text">工作集算法，新的缺页算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#影响缺页次数的因素"><span class="nav-number">8.7.1.</span> <span class="nav-text">影响缺页次数的因素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页面尺寸问题"><span class="nav-number">8.7.2.</span> <span class="nav-text">页面尺寸问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序编制方法对缺页次数的影响"><span class="nav-number">8.7.3.</span> <span class="nav-text">程序编制方法对缺页次数的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页框树与缺页率的关系"><span class="nav-number">8.7.4.</span> <span class="nav-text">页框树与缺页率的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作集模型"><span class="nav-number">8.7.5.</span> <span class="nav-text">工作集模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作集算法"><span class="nav-number">8.7.6.</span> <span class="nav-text">工作集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现"><span class="nav-number">8.7.6.1.</span> <span class="nav-text">实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页面置换算法总结"><span class="nav-number">8.8.</span> <span class="nav-text">页面置换算法总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他相关技术"><span class="nav-number">8.9.</span> <span class="nav-text">其他相关技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存映射文件"><span class="nav-number">8.9.1.</span> <span class="nav-text">内存映射文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#例子-2"><span class="nav-number">8.9.1.1.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#支持写时复制技术"><span class="nav-number">8.9.2.</span> <span class="nav-text">支持写时复制技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-5"><span class="nav-number">8.10.</span> <span class="nav-text">重点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#要求-2"><span class="nav-number">8.10.1.</span> <span class="nav-text">要求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件系统"><span class="nav-number">9.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件与文件系统"><span class="nav-number">9.1.</span> <span class="nav-text">文件与文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件是什么"><span class="nav-number">9.1.1.</span> <span class="nav-text">文件是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何设计一个文件系统"><span class="nav-number">9.1.2.</span> <span class="nav-text">如何设计一个文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用户角度"><span class="nav-number">9.1.2.1.</span> <span class="nav-text">用户角度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统的角度"><span class="nav-number">9.1.2.2.</span> <span class="nav-text">操作系统的角度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统-1"><span class="nav-number">9.1.3.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主要需要完成的任务"><span class="nav-number">9.1.3.1.</span> <span class="nav-text">主要需要完成的任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件的分类"><span class="nav-number">9.1.4.</span> <span class="nav-text">文件的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件的逻辑结构"><span class="nav-number">9.1.5.</span> <span class="nav-text">文件的逻辑结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#典型的文件逻辑结构与文件存取"><span class="nav-number">9.1.5.1.</span> <span class="nav-text">典型的文件逻辑结构与文件存取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的存储介质"><span class="nav-number">9.2.</span> <span class="nav-text">文件的存储介质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#存储介质与物理块"><span class="nav-number">9.2.1.</span> <span class="nav-text">存储介质与物理块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型的磁盘结构"><span class="nav-number">9.2.2.</span> <span class="nav-text">典型的磁盘结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘访问"><span class="nav-number">9.2.3.</span> <span class="nav-text">磁盘访问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘空间管理"><span class="nav-number">9.3.</span> <span class="nav-text">磁盘空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有关数据结构"><span class="nav-number">9.3.1.</span> <span class="nav-text">有关数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘地址与块号的转换"><span class="nav-number">9.3.2.</span> <span class="nav-text">磁盘地址与块号的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成组链接发设计思想"><span class="nav-number">9.3.3.</span> <span class="nav-text">成组链接发设计思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配算法"><span class="nav-number">9.3.4.</span> <span class="nav-text">分配算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回收算法"><span class="nav-number">9.3.5.</span> <span class="nav-text">回收算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件控制块及文件目录"><span class="nav-number">9.4.</span> <span class="nav-text">文件控制块及文件目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件属性"><span class="nav-number">9.4.1.</span> <span class="nav-text">文件属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本文件操作"><span class="nav-number">9.4.2.</span> <span class="nav-text">基本文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用基本文件操作构建其他操作"><span class="nav-number">9.4.2.1.</span> <span class="nav-text">用基本文件操作构建其他操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件目录，目录项与目录文件"><span class="nav-number">9.4.3.</span> <span class="nav-text">文件目录，目录项与目录文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件目录结构的演化"><span class="nav-number">9.4.4.</span> <span class="nav-text">文件目录结构的演化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与目录相关的概念"><span class="nav-number">9.4.5.</span> <span class="nav-text">与目录相关的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录文件之间的关联"><span class="nav-number">9.4.6.</span> <span class="nav-text">目录文件之间的关联</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的物理结构"><span class="nav-number">9.5.</span> <span class="nav-text">文件的物理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#连续顺序结构"><span class="nav-number">9.5.1.</span> <span class="nav-text">连续顺序结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优缺点"><span class="nav-number">9.5.1.1.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接结构"><span class="nav-number">9.5.2.</span> <span class="nav-text">链接结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优缺点-1"><span class="nav-number">9.5.2.1.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接结构的一个变形-文件分配表FAT"><span class="nav-number">9.5.3.</span> <span class="nav-text">链接结构的一个变形:文件分配表FAT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引结构"><span class="nav-number">9.5.4.</span> <span class="nav-text">索引结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#结构示意"><span class="nav-number">9.5.4.1.</span> <span class="nav-text">结构示意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引结构的优缺点"><span class="nav-number">9.5.4.2.</span> <span class="nav-text">索引结构的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组织方式"><span class="nav-number">9.5.4.3.</span> <span class="nav-text">组织方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多级索引与综合模式"><span class="nav-number">9.5.4.4.</span> <span class="nav-text">多级索引与综合模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX的三级索引结构"><span class="nav-number">9.5.5.</span> <span class="nav-text">UNIX的三级索引结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统的实现"><span class="nav-number">9.6.</span> <span class="nav-text">文件系统的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">9.6.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关术语"><span class="nav-number">9.6.2.</span> <span class="nav-text">相关术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘上的内容"><span class="nav-number">9.6.3.</span> <span class="nav-text">磁盘上的内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布局"><span class="nav-number">9.6.4.</span> <span class="nav-text">布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存中所需要的数据结构-以UNIX为例"><span class="nav-number">9.6.5.</span> <span class="nav-text">内存中所需要的数据结构-以UNIX为例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统实例——UNIX"><span class="nav-number">9.7.</span> <span class="nav-text">文件系统实例——UNIX</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件目录检索"><span class="nav-number">9.7.1.</span> <span class="nav-text">文件目录检索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录文件实现时的改进"><span class="nav-number">9.7.2.</span> <span class="nav-text">目录文件实现时的改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改进方案示意"><span class="nav-number">9.7.3.</span> <span class="nav-text">改进方案示意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改进后的好处"><span class="nav-number">9.7.4.</span> <span class="nav-text">改进后的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX文件系统"><span class="nav-number">9.7.5.</span> <span class="nav-text">UNIX文件系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-6"><span class="nav-number">9.8.</span> <span class="nav-text">重点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本周要求"><span class="nav-number">9.8.1.</span> <span class="nav-text">本周要求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件系统2"><span class="nav-number">10.</span> <span class="nav-text">文件系统2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统实例—FAT"><span class="nav-number">10.1.</span> <span class="nav-text">文件系统实例—FAT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows-FAT16文件系统"><span class="nav-number">10.1.1.</span> <span class="nav-text">Windows-FAT16文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MBR"><span class="nav-number">10.1.2.</span> <span class="nav-text">MBR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DBR"><span class="nav-number">10.1.3.</span> <span class="nav-text">DBR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIOS参数块"><span class="nav-number">10.1.4.</span> <span class="nav-text">BIOS参数块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展BIOS参数块"><span class="nav-number">10.1.5.</span> <span class="nav-text">扩展BIOS参数块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件分配表"><span class="nav-number">10.1.6.</span> <span class="nav-text">文件分配表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FAT16目录项等同FCB"><span class="nav-number">10.1.7.</span> <span class="nav-text">FAT16目录项等同FCB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FAT32文件系统"><span class="nav-number">10.1.8.</span> <span class="nav-text">FAT32文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FAT32目录项等同FCB"><span class="nav-number">10.1.9.</span> <span class="nav-text">FAT32目录项等同FCB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#长文件名实现方式"><span class="nav-number">10.1.9.1.</span> <span class="nav-text">长文件名实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FAT32长文件名目录项格式"><span class="nav-number">10.1.9.2.</span> <span class="nav-text">FAT32长文件名目录项格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子-3"><span class="nav-number">10.1.9.3.</span> <span class="nav-text">例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件操作的实现"><span class="nav-number">10.2.</span> <span class="nav-text">文件操作的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建文件"><span class="nav-number">10.2.1.</span> <span class="nav-text">创建文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打开文件"><span class="nav-number">10.2.2.</span> <span class="nav-text">打开文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针定位"><span class="nav-number">10.2.3.</span> <span class="nav-text">指针定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读文件"><span class="nav-number">10.2.4.</span> <span class="nav-text">读文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#讨论-2"><span class="nav-number">10.2.5.</span> <span class="nav-text">讨论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统的管理"><span class="nav-number">10.3.</span> <span class="nav-text">文件系统的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统的可靠性"><span class="nav-number">10.3.1.</span> <span class="nav-text">文件系统的可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统文件备份"><span class="nav-number">10.3.2.</span> <span class="nav-text">系统文件备份</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统一致性"><span class="nav-number">10.3.3.</span> <span class="nav-text">文件系统一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘块的一致性检查"><span class="nav-number">10.3.4.</span> <span class="nav-text">磁盘块的一致性检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写入策略"><span class="nav-number">10.3.5.</span> <span class="nav-text">写入策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统的安全性"><span class="nav-number">10.4.</span> <span class="nav-text">文件系统的安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件保护机制"><span class="nav-number">10.4.1.</span> <span class="nav-text">文件保护机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件的访问控制"><span class="nav-number">10.4.2.</span> <span class="nav-text">文件的访问控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX的文件访问控制"><span class="nav-number">10.4.3.</span> <span class="nav-text">UNIX的文件访问控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统的性能"><span class="nav-number">10.5.</span> <span class="nav-text">文件系统的性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统的性能问题"><span class="nav-number">10.5.1.</span> <span class="nav-text">文件系统的性能问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#块高速缓存"><span class="nav-number">10.5.2.</span> <span class="nav-text">块高速缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-1"><span class="nav-number">10.5.2.1.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提前读取"><span class="nav-number">10.5.3.</span> <span class="nav-text">提前读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows文件的访问方式"><span class="nav-number">10.5.4.</span> <span class="nav-text">Windows文件的访问方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合理分配磁盘空间"><span class="nav-number">10.5.5.</span> <span class="nav-text">合理分配磁盘空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘调度"><span class="nav-number">10.5.6.</span> <span class="nav-text">磁盘调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘调度算法"><span class="nav-number">10.5.6.1.</span> <span class="nav-text">磁盘调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先来先服务-1"><span class="nav-number">10.5.6.2.</span> <span class="nav-text">先来先服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最短寻道时间优先"><span class="nav-number">10.5.6.3.</span> <span class="nav-text">最短寻道时间优先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扫描算法"><span class="nav-number">10.5.6.4.</span> <span class="nav-text">扫描算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单向扫描调度算法C-SCAN"><span class="nav-number">10.5.6.5.</span> <span class="nav-text">单向扫描调度算法C-SCAN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#N-step-SCAN策略"><span class="nav-number">10.5.6.6.</span> <span class="nav-text">N-step-SCAN策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FSCAN策略"><span class="nav-number">10.5.6.7.</span> <span class="nav-text">FSCAN策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#旋转调度算法"><span class="nav-number">10.5.6.8.</span> <span class="nav-text">旋转调度算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信息的优化分布"><span class="nav-number">10.5.7.</span> <span class="nav-text">信息的优化分布</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#记录的成组与分解"><span class="nav-number">10.5.7.1.</span> <span class="nav-text">记录的成组与分解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RAID技术"><span class="nav-number">10.5.8.</span> <span class="nav-text">RAID技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本思想-1"><span class="nav-number">10.5.8.1.</span> <span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举例"><span class="nav-number">10.5.8.2.</span> <span class="nav-text">举例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统的两个练习"><span class="nav-number">10.6.</span> <span class="nav-text">文件系统的两个练习</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-7"><span class="nav-number">10.7.</span> <span class="nav-text">重点</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lily</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  

  

  

  

  


</body>
</html>

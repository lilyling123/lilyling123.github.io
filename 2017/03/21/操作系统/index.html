<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="操作系统概述操作系统做了什么？#include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { 
puts(&amp;quot;hello world&amp;quot;); return 0; 
}


用户告诉操作系统执行helloworld程序(如何告知？)  
操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2017/03/21/操作系统/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="操作系统概述操作系统做了什么？#include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { 
puts(&amp;quot;hello world&amp;quot;); return 0; 
}


用户告诉操作系统执行helloworld程序(如何告知？)  
操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部">
<meta property="og:image" content="http://i.imgur.com/Md58ooA.jpg">
<meta property="og:image" content="http://i.imgur.com/QtK5q30.jpg">
<meta property="og:image" content="http://i.imgur.com/zfUhtic.jpg">
<meta property="og:image" content="http://i.imgur.com/XZeZzlY.jpg">
<meta property="og:image" content="http://i.imgur.com/SdcJiLx.jpg">
<meta property="og:image" content="http://i.imgur.com/cS7YiDl.jpg">
<meta property="og:image" content="http://i.imgur.com/2ejIZu1.jpg">
<meta property="og:image" content="http://i.imgur.com/6iYnFgF.jpg">
<meta property="og:image" content="http://i.imgur.com/0OmstJz.jpg">
<meta property="og:image" content="http://yoursite.com/img/opSystem/forth/1.jpg">
<meta property="og:updated_time" content="2017-03-30T08:57:33.766Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="操作系统概述操作系统做了什么？#include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { 
puts(&amp;quot;hello world&amp;quot;); return 0; 
}


用户告诉操作系统执行helloworld程序(如何告知？)  
操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部">
<meta name="twitter:image" content="http://i.imgur.com/Md58ooA.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/03/21/操作系统/"/>





  <title>  | Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/21/操作系统/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-21T15:06:07+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h2 id="操作系统做了什么？"><a href="#操作系统做了什么？" class="headerlink" title="操作系统做了什么？"></a>操作系统做了什么？</h2><pre><code>#include &lt;stdio.h&gt; int main(int argc, char *argv[]) { 
puts(&quot;hello world&quot;); return 0; 
}
</code></pre><hr>
<ol>
<li>用户告诉操作系统执行helloworld程序(如何告知？)  </li>
<li>操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址（文件格式？）   </li>
<li>操作系统：创建一个新的进程，并将helloworld可执行文件映射到该进程结构，表示由该进程执行helloworld程序  </li>
<li>操作系统：为helloworld程序设置CPU上下文环境，并跳到程序开始处（假设调度程序选中hello程序）  </li>
<li>执行helloworld程序的第一条指令，发生缺页异常  </li>
<li>操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序   </li>
<li>helloworld程序执行puts函数（系统调用），在显示器上写一字符串   </li>
<li>操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程  </li>
<li>操作系统：控制设备的进程告诉设备的窗口系统它要显示字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区  </li>
<li>视频硬件将像素转换成显示器可接收的一组控制/数据信号  </li>
<li>显示器解释信号，激发液晶屏  </li>
<li>OK！！！我们在屏幕上看到了“hello world”</li>
</ol>
<h3 id="从上述步骤中得到了什么"><a href="#从上述步骤中得到了什么" class="headerlink" title="从上述步骤中得到了什么"></a>从上述步骤中得到了什么</h3><p>os进程与用户程序的切换  </p>
<h3 id="换个角度看用户程序的执行"><a href="#换个角度看用户程序的执行" class="headerlink" title="换个角度看用户程序的执行"></a>换个角度看用户程序的执行</h3><h2 id="操作系统的定义与作用"><a href="#操作系统的定义与作用" class="headerlink" title="操作系统的定义与作用"></a>操作系统的定义与作用</h2><h3 id="操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——"><a href="#操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——" class="headerlink" title="操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——"></a>操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——</h3><ul>
<li>它们能以尽量有效、合理的方式组织和管理计算机的软硬件资源  </li>
<li>合理地组织计算机的工作 流程，控制程序的执行并向用户提供各种服务功能  </li>
<li><p>使得用户能够灵活、方便地使用计算机，使整个计算机系统高效率运行  </p>
<h3 id="几个关键词"><a href="#几个关键词" class="headerlink" title="几个关键词"></a>几个关键词</h3><p>  有效：系统效率，资源利用率</p>
<pre><code>CPU利用率充足与否？I/O设备是否忙碌？
</code></pre><p>  合理：</p>
<pre><code>各种软硬件资源的管理是否公平合理
如果不公平、不合理，则可能会产生问题？
</code></pre><p>  方便使用：</p>
<pre><code>两种角度：用户界面 与 编程接口
</code></pre><h3 id="三个作用"><a href="#三个作用" class="headerlink" title="三个作用"></a>三个作用</h3><h4 id="资源的管理者"><a href="#资源的管理者" class="headerlink" title="资源的管理者"></a>资源的管理者</h4><p>自底向上 硬件资源：软件资源：<br><strong>怎样管理资源</strong>  </p>
<p>  跟踪记录资源的使用状况，如：哪些资源空闲，分配给谁使用，允许使用多长时间等<br>  确定资源分配策略——算法：静态分配策略，动态分配策略<br>  实施资源的分配和回收<br>  提高资源利用率<br>  保护资源的使用<br>  协调多个进程对资源请求的冲突</p>
</li>
</ul>
<p><strong>五大基本功能</strong>  </p>
<pre><code>进程/线程管理（CPU管理）
    进程线程状态、控制、同步互斥、通信、调度、……
存储管理
    分配/回收、地址转换、存储保护、内存扩充、……
文件管理
    文件目录、文件操作、磁盘空间、文件存取控制、……
设备管理
    设备驱动、分配回收、缓冲技术、……
用户接口
    系统命令、编程接口
</code></pre><h4 id="各种系统服务的提供者"><a href="#各种系统服务的提供者" class="headerlink" title="各种系统服务的提供者"></a>各种系统服务的提供者</h4><pre><code>在操作系统之上，从用户角度来看：
    操作系统为用户提供了一组功能强大、方便易用的命令或系统调用
典型的服务
    进程的创建、执行；文件和目录的操作；I/O设备的使用；各类统计信息；……
</code></pre><h4 id="对硬件机器的扩展"><a href="#对硬件机器的扩展" class="headerlink" title="对硬件机器的扩展"></a>对硬件机器的扩展</h4><pre><code>操作系统在应用程序与硬件之间建立了一个等价的扩展机器（虚拟机）  
对硬件抽象，提高可移植性；比底层硬件更容易编程
</code></pre><p>由面向底层变成了面向操作系统编程</p>
<h2 id="操作系统的主要特征"><a href="#操作系统的主要特征" class="headerlink" title="操作系统的主要特征"></a>操作系统的主要特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发(concurrency)：指处理多个同时性活动的能力  </p>
<pre><code>由于并发将会引发很多的问题：
    活动切换、保护、相互依赖的活动间的同步
在计算机系统中同时存在多个程序运行，单CPU上
    宏观上：这些程序同时在执行
    微观上：任何时刻只有一个程序真正在执行，即这些程序在CPU上是轮流执行的
并行(parallel)：与并发相似，但多指不同程序同时在多个硬件部件上执行
</code></pre><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><pre><code>共享(sharing)：
    操作系统与多个用户的程序共同使用计算机系统中的资源（共享有限的系统资源）
    操作系统要对系统资源进行合理分配和使用
    资源在一个时间段内交替被多个进程所用
互斥共享（如打印机）
同时共享（如可重入代码、磁盘文件）

问题：资源分配难以达到最优化，如何保护资源
</code></pre><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>一个物理实体映射为若干个对应的逻辑实体－－分时或分空间<br>虚拟是操作系统管理系统资源的重要手段，可提高资源利用率  </p>
<pre><code>CPU－－每个进程的&quot;虚处理机&quot;
存储器－－每个进程都有独立的虚拟地址空间（代码＋数据＋堆栈）
显示设备－－多窗口或虚拟终端
</code></pre><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>操作系统必须随时对以不可预测的次序发生的事件进行响应并处理</p>
<h2 id="典型操作系统的架构"><a href="#典型操作系统的架构" class="headerlink" title="典型操作系统的架构"></a>典型操作系统的架构</h2><h3 id="Windows架构"><a href="#Windows架构" class="headerlink" title="Windows架构"></a>Windows架构</h3><p>用户态：系统进程，服务进程，用户进程，环境子系统，动态链接库<br>内核态：系统服务分发器，内核态可调用接口，执行体，内核，设备驱动驱动程序，硬件抽象层，图形与窗口<br>物理硬件：硬件</p>
<h3 id="UNIX架构"><a href="#UNIX架构" class="headerlink" title="UNIX架构"></a>UNIX架构</h3><p>用户态：系统调用接口<br>内核态：进程控制子系统，文件系统，设备驱动程序（块设备，字符系统），硬件控制层，系统调用接口</p>
<h3 id="linux内核组间"><a href="#linux内核组间" class="headerlink" title="linux内核组间"></a>linux内核组间</h3><p>内核态：进程调度，文件系统，设备驱动程序，网络服务</p>
<h2 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h2><h3 id="操作系统的发展历程"><a href="#操作系统的发展历程" class="headerlink" title="操作系统的发展历程"></a>操作系统的发展历程</h3><p>操作系统发展是随着计算机硬件技术、应用需求的发展、软件新技术的出现而发展的</p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>充分利用硬件<br>提供更好的服务  </p>
<h3 id="传统操作系统的分类"><a href="#传统操作系统的分类" class="headerlink" title="传统操作系统的分类"></a>传统操作系统的分类</h3><p>批处理操作系统<br>分时系统<br>实时操作系统<br>个人计算机操作系统<br>网络操作系统<br>分布式操作系统<br>嵌入式操作系统  </p>
<h4 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h4><ol>
<li>用户将作业交给系统操作员  </li>
<li>系统操作员将许多用户的作业组成一批作业，输入到计算机系统中，在系统中形成一个自动转接的连续的作业流  </li>
<li>启动操作系统  </li>
<li>系统自动、依次执行每个作业  </li>
<li>由操作员将作业结果交给用户  </li>
</ol>
<hr>
<p>目标：提高资源利用率，增加作业处理吞吐量  </p>
<hr>
<pre><code>批处理系统中的作业包括： 
1. 用户程序  
2. 数据  
3. 作业说明书（用作业控制语言编写）
</code></pre><hr>
<p> 成批：通常由若干个作业组成，用户提交作业后只能等待处理结果，不能干预自己作业的执行</p>
<hr>
<p>批作业处理：<br>对一批作业中的每个作业进行相同的处理：从磁带读入用户作业和编译链接程序，编译链接用户作业以生成可执行程序；启动执行；执行并输出结果  </p>
<hr>
<pre><code>问题：慢速的输入输出处理直接由主机来完成，输入输出时，CPU处于等待状态  
解决方案：卫星机：完成面向用户的输入输出（纸带或卡片），中间结果暂存在磁带或磁盘上
</code></pre><hr>
<pre><code>SPOOLING系統（技術）  
利用磁盘作缓冲，将输入、计算、输出分别组织成独立的任务流，使I/O和计算真正并行  
工作原理：  
用户作业加载到磁盘上的输入井
按某种调度策略选择几个搭配得当的作业，调入内存
作业运行的结果输出到磁盘上的输出井
运行结果从磁盘上的输出井送到打印机 
</code></pre><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><pre><code>操作系统将CPU的时间划分成若干个片段，称为时间片
    操作系统以时间片为单位，轮流为每个终端用户服务，每次服务一个时间片
    其特点是利用人的错觉，使用户感觉不到计算机在服务他人
</code></pre><hr>
<pre><code>追求目标：
    及时响应(依据是响应时间)
响应时间：
    从终端发出命令到系统给予回答所经历的时间
</code></pre><h4 id="通过操作系统"><a href="#通过操作系统" class="headerlink" title="通过操作系统"></a>通过操作系统</h4><p>分时系统与批处理系统结合  </p>
<hr>
<pre><code>原则：分时优先，批处理在后
“前台”：需要频繁交互的作业
“后台”：时间性要求不强的作业
</code></pre><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>是指使计算机能及时响应外部事件的请求，在规定的严格时间内完成对该事件的处理，并控制所有实时设备和实时任务协调一致地工作</p>
<hr>
<pre><code>分类：
    第一类：实时过程控制
        工业控制、航空、军事控制、...
    第二类：实时通信（信息）处理
        电讯（自动交换机）、银行、飞机订票、股市行情
</code></pre><hr>
<pre><code>追求目标：
    对外部请求在严格时间范围内作出响应
    高可靠性
</code></pre><hr>
<p>硬实时系统<br>软实时系统</p>
<h4 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h4><p>计算机在某一时间内为单用户服务</p>
<hr>
<pre><code>追求目标：
    界面友好，使用方便
    丰富的应用软件
</code></pre><h4 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h4><pre><code>基于计算机网络
    在各种计算机操作系统上
        按网络体系结构协议标准开发的软件
功能：
    网络管理，通信，安全，资源共享和各种网络应用
追求目标：相互通信，资源共享
</code></pre><h4 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h4><pre><code>分布式系统：或以计算机网络为基础，或以多处理机为基础，基本特征是处理分布在不同计算机上

分布式操作系统：是一个统一的操作系统，允许若干个计算机可相互协作共同完成一项任务。操作系统可将各种系统任务在分布式系统中任何处理机上运行，自动实现全系统范围内的任务分配、自动调度、均衡各处理机的工作负载

处理能力增强、速度更快、可靠性增强、具有透明性
</code></pre><h4 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h4><pre><code>嵌入式系统
    在各种设备、装置或系统中，完成特定功能的软硬件系统汽车、手机、电视机、MP3播放器
    它们是一个大设备、装置或系统中的一部分，这个大设备、装置或系统可以不是“计算机”
    通常工作在反应式或对处理时间有较严格要求环境中

嵌入式操作系统（Embedded Operating System）
    运行在嵌入式系统环境中，对整个嵌入式系统以及它所操作、控制的各种部件装置等等资源进行统一协调、调度、指挥和控制的系统软件
</code></pre><h4 id="智能卡操作系统"><a href="#智能卡操作系统" class="headerlink" title="智能卡操作系统"></a>智能卡操作系统</h4><pre><code>智能卡：一种包含有一块CPU芯片的卡片
特点
    非常严格的运行能耗和存储空间的限制
    有些智能卡只有单项功能，诸如电子支付
专用的操作系统  

有些智能卡是面向Java的，即在智能卡的ROM中有一个Java虚拟机解释器。Java 程序被下载到卡中并由JVM解释器解释。有些卡可以同时处理多个Java 小程序，这就是多道程序，并且需要对它们进行调度。在两个或多个小程序同时运行时，资源管理和保护就成为突出的问题。这些问题必须由卡上的操作系统处理
</code></pre><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><pre><code>重点阅读教材
    第1章相关内容：1.1、1.2、1.4
    第10章相关内容：10.2.5
    第11章相关内容：11.3.1.

重点概念
    操作系统定义 操作系统的三个作用
    并发 共享 虚拟 随机 SPOOLing技术 Windows、Linux、UNIX的架构
</code></pre><h1 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h1><h2 id="处理器状态"><a href="#处理器状态" class="headerlink" title="处理器状态"></a>处理器状态</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>处理器由运算器、控制器、一系列的寄存器以及高速缓存构成  </p>
<pre><code>两类寄存器：
    用户可见寄存器：高级语言编译器通过优化算法分配并使用之，以减少程序访问内存次数
    控制和状态寄存器：用于控制处理器的操作
                        通常由操作系统代码使用
</code></pre><h4 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h4><p>用于控制处理器的操作<br>在某种特权级别下可以访问、修改  </p>
<pre><code>常见的控制和状态寄存器
    程序计数器（PC：Program Counter），记录将要取出的指令的地址
    指令寄存器（IR：Instruction Register），记录最近取出的指令
    程序状态字（PSW：Program Status Word），记录处理器的运行状态如条件码、模式、控制位等信息
</code></pre><h3 id="操作系统的需求，保护"><a href="#操作系统的需求，保护" class="headerlink" title="操作系统的需求，保护"></a>操作系统的需求，保护</h3><p>从操作系统的特征考虑<br>并发、共享<br>提出要求 → 实现保护与控制  </p>
<pre><code>需要硬件提供基本运行机制：
    处理器具有特权级别，能在不同的特权级运行的不同指令集合
     硬件机制可将OS与用户程序隔离
</code></pre><h3 id="处理器的状态"><a href="#处理器的状态" class="headerlink" title="处理器的状态"></a>处理器的状态</h3><p>现代处理器通常将CPU状态设计划分为两种、三种或四种<br>在程序状态字寄存器PSW中专门设置一位，根据运行程序对资源和指令的使用权限而设置不同的CPU状态  </p>
<h3 id="特权指令和非特权指令"><a href="#特权指令和非特权指令" class="headerlink" title="特权指令和非特权指令"></a>特权指令和非特权指令</h3><pre><code>操作系统需要两种CPU状态
    内核态(Kernel Mode)：运行操作系统程序
    用户态(User Mode)：运行用户程序
</code></pre><hr>
<p>特权(privilege)指令：只能由操作系统使用、用户程序不能使用的指令<br>非特权指令：用户程序可以使用的指令</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>X86支持4个处理器特权级别<br>特权环：R0、R1、R2和R3  </p>
<pre><code>从R0到R3，特权能力由高到低
    R0相当于内核态；R3相当于用户态；R1和R2则介于两者之间
    不同级别能够运行的指令集合不同
</code></pre><p>目前大多数基于x86处理器的操作系统<br>只用了R0和R3两个特权级别</p>
<h3 id="CPU状态之间的转换"><a href="#CPU状态之间的转换" class="headerlink" title="CPU状态之间的转换"></a>CPU状态之间的转换</h3><pre><code>用户态 → 内核态
    唯一途径 → 中断/异常/陷入机制
内核态 → 用户态
    设置程序状态字PSW
</code></pre><hr>
<pre><code>一条特殊的指令：陷入指令（又称访管指令）
    提供给用户程序的接口，用于调用操作系统的功能（服务）
    例如：int，trap，syscall，sysenter/sysexit
</code></pre><h2 id="中断和异常机制"><a href="#中断和异常机制" class="headerlink" title="中断和异常机制"></a>中断和异常机制</h2><pre><code>中断/异常 对于操作系统的重要性
    就好比：汽车的发动机、飞机的引擎
→→ 可以说 操作系统
    是由“中断驱动”或者 “事件驱动”的
</code></pre><hr>
<pre><code>主要作用
    及时处理设备发来的中断请求
    可使OS捕获用户程序提出的服务请求
    防止用户程序执行过程中的破坏性活动
    … … 等等
</code></pre><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>CPU对系统发生的某个事件作出的一种反应<br>CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序  </p>
<pre><code>特点：
•是随机发生的
•是自动处理的
•是可恢复的

事件的发生改变了处理器的控制流
</code></pre><h3 id="为什么引入中断与异常"><a href="#为什么引入中断与异常" class="headerlink" title="为什么引入中断与异常"></a>为什么引入中断与异常</h3><pre><code>中断的引入：为了支持CPU和设备之间的并行操作
    当CPU启动设备进行输入/输出后，设备便可以独立工作，CPU转去处理与此次输入/输出不相关的事情；
    当设备完成输入/输出后，通过向CPU发中断报告此次输入/输出的结果，让CPU决定如何处理以后的事情

异常的引入：表示CPU执行指令时本身出现的问题
    如算术溢出、除零、取数时的奇偶错，访存地址时越界或执行了“陷入指令” 等，
    这时硬件改变了CPU当前的执行流程，转到相应的错误处理程序或异常处理程序或执行系统调用
</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>中断：外部事件，正在运行的程序所不期望的<br>异常：由正在执行的指令引发  </p>
<pre><code>中断(外中断)
    I/O中断
    时钟中断
    硬件故障

异常(内中断)
    系统调用
    页故障/页错误
    保护性异常
    断点指令
    其他程序性异常
    (如算术溢出等)
</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>类别        原因                        异步/同步        返回行为
中断
Interrupt    来自I/O设备、其他硬件部件    异步            总是返回到下一条指令
陷入Trap    有意识安排的                  同步            返回到下一条指令

故障Fault    可恢复的错误                  同步            返回到当前指令

终止Abort    不可恢复的错误                 同步            不会返回
</code></pre><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>中断/异常机制是现代计算机系统的核心机制之一<br>硬件和软件相互配合而使计算机系统得以充分发挥能力</p>
<hr>
<pre><code>硬件该做什么事？ —— 中断/异常响应
    捕获中断源发出的中断/异常请求，以一定方式响应，将处理器控制权交给特定的处理程序
软件要做什么事？ —— 中断/异常处理程序
    识别中断/异常类型并完成相应的处理
</code></pre><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><pre><code>中断响应：
     发现中断、接收中断的过程
     由中断硬件部件完成
</code></pre><h4 id="过程示意"><a href="#过程示意" class="headerlink" title="过程示意"></a>过程示意</h4><p>开始-&gt;取下一条指令-&gt;执行指令-&gt;检查指令-&gt;处理中断</p>
<hr>
<pre><code>在每条指令执行周期的最后时刻扫描中断寄存器，查看是否有中断信号？
若有中断，中断硬件将该中断触发器内容按规定编码送入PSW的相应位，称为中断码，通过查中断向量表引出中断处理程序
若无中断信号，继续执行下一条指令
</code></pre><h4 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h4><pre><code>中断向量：
    一个内存单元，存放中断处理程序入口地址和程序运行时所需的处理机状态字
</code></pre><hr>
<p>执行流程按中断号/异常类型的不同，通过中断向量表<br>转移控制权给中断处理程序<br>中断向量表<br>中断处理程序</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><pre><code>1. 设备发中断信号
2. 硬件保存现场
3. 根据中断码查表
4. 把中断处理程序入口地址等推送到相应的寄存器
5. 执行中断处理程序
</code></pre><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>设计操作系统时，为每一类中断/异常事件编好相应的处理程序，并设置好中断向量表  </p>
<pre><code>系统运行时若响应中断，中断硬件部件将CPU控制权转给中断处理程序：
    保存相关寄存器信息
    分析中断/异常的具体原因
    执行对应的处理功能
    恢复现场，返回被事件打断的程序
</code></pre><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><pre><code>以设备输入输出中断为例： 
    打印机给CPU发中断信号
    CPU处理完当前指令后检测到中断，判断出中断来源并向相关设备发确认信号

    CPU开始为软件处理中断做准备：
        处理器状态被切换到内核态
        在系统栈中保存被中断程序的重要上下文环境，主要是程序计数器PC、程序状态字PSW

    PU根据中断码查中断向量表，获得与该中断相关的处理程序的入口地址，并将PC设置成该地址，新的指令周期开始时，CPU控制转移到中断处理程序

    中断处理程序开始工作
        在系统栈中保存现场信息
        检查I/O设备的状态信息，操纵I/O设备或者在设备和内存之间传送数据等等

    中断处理结束时，CPU检测到中断返回指令，从系统栈中恢复被中断程序的上下文环境 ，CPU状态恢复成原来的状态，PSW和PC恢复成中断前的值，CPU开始一个新的指令周期
</code></pre><hr>
<pre><code>I/O中断处理程序
通常分为两类处理：

    I/O操作正常结束
        若有程序正等待此次I/O的结果，则应将其唤醒
        若要继续I/O操作，需要准备好数据重新启动I/O

    I/O操作出现错误
        需要重新执行失败的I/O操作
        重试次数有上限，达到时系统将判定硬件故障
</code></pre><h2 id="实例：x86处理器"><a href="#实例：x86处理器" class="headerlink" title="实例：x86处理器"></a>实例：x86处理器</h2><pre><code>中断
    由硬件信号引发的，分为可屏蔽和不可屏蔽中断
异常
    由指令执行引发的，比如除零异常
    80x86处理器发布了大约20种不同的异常
    对于某些异常，CPU会在执行异常处理程序之前产生硬件出错码，并压入内核态堆栈
系统调用
    异常的一种，用户态到内核态的唯一入口
</code></pre><h2 id="x86处理器对中断的支持"><a href="#x86处理器对中断的支持" class="headerlink" title="x86处理器对中断的支持"></a>x86处理器对中断的支持</h2><pre><code>中断控制器（PIC或APIC）
    负责将硬件的中断信号转换为中断向量，并引发CPU中断

实模式：中断向量表 (Interrupt Vector)
    存放中断服务程序的入口地址
        入口地址＝段地址左移4位＋偏移地址
        不支持CPU运行状态切换
        中断处理与一般的过程调用相似

保护模式：中断描述符表 (Interrupt Descriptor Table)
    采用门(gate) 描述符数据结构表示中断向量
</code></pre><hr>
<pre><code>中断向量表/中断描述符表
    四种类型门描述符
        任务门(Task Gate)
        中断门(Interrupt Gate)
            给出段选择符 (Segment Selector)、中断/异常程序的段内偏移量 (Offset)
            通过中断门后系统会自动禁止中断
        陷阱门(Trap Gate)
            与中断门类似，但通过陷阱门后系统不会自动禁止中断
        调用门(Call Gate)
</code></pre><hr>
<pre><code>中断/异常的硬件处理过程：
    确定与中断或异常关联的向量i
    通过IDTR寄存器找到IDT表，获得中断描述符（表中的第i项）
    从GDTR寄存器获得GDT的地址；结合中断描述符中的段选择符，在GDT表获取对应的段描述符；从该段描述符中得到中断或异常处理程序所在的段基址
    特权级检查
</code></pre><hr>
<pre><code>检查是否发生了特权级的变化，如果是，则进行堆栈切换(必须使用与新的特权级相关的栈)
硬件压栈，保存上下文环境；如果异常产生了硬件出错码，也将它保存在栈中
如果是中断，清IF位
通过中断描述符中的段内偏移量和段描述符中的基地址，找到中断/异常处理程序的入口地址，执行其第一条指令
</code></pre><h2 id="系统调用机制"><a href="#系统调用机制" class="headerlink" title="系统调用机制"></a>系统调用机制</h2><pre><code>系统调用：用户在编程时可以调用的操作系统功能
</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><pre><code>系统调用是操作系统提供给编程人员的唯一接口
使CPU状态从用户态陷入内核态
</code></pre><h3 id="典型系统调用"><a href="#典型系统调用" class="headerlink" title="典型系统调用"></a>典型系统调用</h3><pre><code>每个操作系统都提供几百种系统调用（进程控制、进程通信、文件使用、目录操作、设备管理、信息维护等）
</code></pre><h3 id="系统调用机制的设计"><a href="#系统调用机制的设计" class="headerlink" title="系统调用机制的设计"></a>系统调用机制的设计</h3><pre><code>中断/异常机制
    支持系统调用服务的实现
选择一条特殊指令：陷入指令(亦称访管指令)
    引发异常，完成用户态到内核态的切换
系统调用号和参数 
    每个系统调用都事先给定一个编号(功能号)
    编译器也会参与
系统调用表
    存放系统调用服务例程的入口地址
</code></pre><h3 id="参数传递过程问题"><a href="#参数传递过程问题" class="headerlink" title="参数传递过程问题"></a>参数传递过程问题</h3><pre><code>怎样实现用户程序的参数传递给内核？

常用的3种实现方法：
    由陷入指令自带参数：陷入指令的长度有限，且还要携带系统调用功
    能号，只能自带有限的参数
    通过通用寄存器传递参数：这些寄存器是操作系统和用户程序都能访
    问的，但寄存器的个数会限制传递参数的数量
    在内存中开辟专用堆栈区来传递参数
</code></pre><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><pre><code>当CPU执行到特殊的陷入指令时：  
    中断/异常机制：硬件保护现场；通过查中断向量表把控制权转给系统调用总入口程序
    系统调用总入口程序：保存现场；将参数保存在内核堆栈里；通过查系统调用表把控制权转给相应的系统调用处理例程或内核函数
    执行系统调用例程
    恢复现场，返回用户程序
</code></pre><h2 id="基于x86处理器的linux的系统调用实现"><a href="#基于x86处理器的linux的系统调用实现" class="headerlink" title="基于x86处理器的linux的系统调用实现"></a>基于x86处理器的linux的系统调用实现</h2><pre><code>陷入指令选择128号
    int $0x80
</code></pre><hr>
<pre><code>门描述符
    系统初始化时：对IDT表中的128号门初始化
    门描述符的2、3两个字节：内核代码段选择符
    0、1、6、7四个字节：偏移量（指向system_call()）
    门类型：15，陷阱门，为什么？执行系统调用的过程中，还接收中断
    DPL：3，与用户级别相同，允许用户进程使用该门描述符
</code></pre><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><pre><code>由于特权级的改变，要切换栈
    用户栈 → 内核栈
    CPU从任务状态段TSS中装入新的栈指针（SS︰ESP），指向内核栈

内核栈
    用户栈的信息（SS︰ESP）、EFLAGS、用户态CS 、EIP 寄存器的内容压栈（返回用）
    将EFLAGS压栈后，复位TF，IF位保持不变
    用128在IDT中找到该门描述符，从中找出段选择符装入代码段寄存器CS
    代码段描述符中的基地址 + 陷阱门描述符中的偏移量 → 定位 system_call()的入口地址
</code></pre><h3 id="调用执行流程"><a href="#调用执行流程" class="headerlink" title="调用执行流程"></a>调用执行流程</h3><p>应用程序-&gt;封装例程-&gt;陷入处理-&gt;内核函数-&gt;</p>
<h3 id="OS底层工作步骤"><a href="#OS底层工作步骤" class="headerlink" title="OS底层工作步骤"></a>OS底层工作步骤</h3><pre><code>1. 硬件压栈：程序计数器等
2. 硬件从中断向量装入新的程序计数器等
3. 汇编语言过程保存寄存器值
4. 汇编语言过程设置新的堆栈
5. C语言中断服务程序运行（例：读并缓冲输入）
6. 进程调度程序决定下一个将运行的进程
7. C语言过程返回至汇编代码
8. 汇编语言过程开始运行新的当前进程
</code></pre><h2 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h2><pre><code>理解计算机系统的保护机制
    掌握处理器状态
     掌握特权指令与非特权指令
 掌握中断/异常机制
     掌握中断/异常的基本概念
     理解中断/异常机制的工作原理
 掌握系统调用机制
    掌握系统调用设计原理
    掌握系统调用执行过程
</code></pre><hr>
<pre><code>重点阅读教材
    第1章相关内容：1.3、1.6
    第2章 第52页 图2-5及说明该图思路的段落
重点概念
    CPU状态 内核态/用户态 特权指令/非特权指令
    中断 异常 中断响应 中断向量 中断处理程序
    系统调用 陷入指令 系统调用号 系统调用表
</code></pre><h1 id="进程-线程模型"><a href="#进程-线程模型" class="headerlink" title="进程/线程模型"></a>进程/线程模型</h1><h2 id="进程基本概念"><a href="#进程基本概念" class="headerlink" title="进程基本概念"></a>进程基本概念</h2><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><pre><code>多道程序设计
    允许多个程序同时进入内存并运行，其目的是为了提高系统效率
</code></pre><h3 id="并发环境与并发程序"><a href="#并发环境与并发程序" class="headerlink" title="并发环境与并发程序"></a>并发环境与并发程序</h3><pre><code>并发环境：
        一段时间间隔内，单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态，并且次序不是事先确定的

并发程序：在并发环境中执行的程序
</code></pre><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><pre><code>定义：Process
    进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位
又称 任务（Task or Job）
</code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre><code>程序的一次执行过程
是正在运行程序的抽象
将一个CPU变幻成多个虚拟的CPU
系统资源以进程为单位分配，如内存、文件、……
    每个具有独立的地址空间
操作系统将CPU调度给需要的进程
</code></pre><h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><pre><code>PCB：Process Control Block
    又称 进程描述符、进程属性
    操作系统用于管理控制进程的一个专门数据结构
    记录进程的各种属性，描述进程的动态变化过程

PCB是系统感知进程存在的唯一标志
    → 进程与PCB是一一对应的

进程表：所有进程的PCB集合
</code></pre><hr>
<pre><code>进程描述信息
    进程标识符(process ID)，唯一，通常是一个整数
    进程名，通常基于可执行文件名，不唯一
    用户标识符(user ID)
    进程组关系

当前状态
    优先级(priority)
    代码执行入口地址
    程序的磁盘地址
    运行统计信息(执行时间、页面调度)
    进程间同步和通信
    进程的队列指针
    进程的消息队列指针

所拥有的资源和使用情况
    虚拟地址空间的状况
    打开文件列表

CPU现场信息
    寄存器值(通用寄存器、程序计数器PC、程序状态字PSW、栈指针)
    指向该进程页表的指针
</code></pre><hr>
<p>Linux：task_struct<br>Windows：EPROCESS、KPROCESS、PEB  </p>
<h4 id="Linux：task-struct"><a href="#Linux：task-struct" class="headerlink" title="Linux：task_struct"></a>Linux：task_struct</h4><p>非常之多</p>
<h2 id="进程状态及状态转换"><a href="#进程状态及状态转换" class="headerlink" title="进程状态及状态转换"></a>进程状态及状态转换</h2><h3 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h3><pre><code>进程的三种基本状态：
运行态、就绪态、等待态

运行态（Running）
    占有CPU，并在CPU上运行
就绪态（Ready）
    已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
等待态（Waiting/Blocked）阻塞态、封锁态、睡眠态
    因等待某一事件而暂时不能运行
</code></pre><h3 id="三状态模型以及状态转换"><a href="#三状态模型以及状态转换" class="headerlink" title="三状态模型以及状态转换"></a>三状态模型以及状态转换</h3><pre><code>就绪 → 运行
    调度程序选择一个新的进程运行

运行 → 就绪
    运行进程用完了时间片
    一个高优先级进程进入就绪状态，抢占正在运行的进程

运行 → 等待
    当一个进程等待某个事件发生时
        请求OS服务
        对资源的访问尚不能进行
        等待I/O结果
        等待另一进程提供信息

等待 → 就绪
    所等待的事件发生了
</code></pre><h3 id="其他状态"><a href="#其他状态" class="headerlink" title="其他状态"></a>其他状态</h3><pre><code>创建
    已完成创建一进程所必要的工作
        –PID、PCB
    但尚未同意执行该进程
        –因为资源有限

终止
    终止执行后，进程进入该状态
    可完成一些数据统计工作
    资源回收

挂起
    用于调节负载
    进程不占用内存空间，其进程映像交换到磁盘上
</code></pre><h3 id="五状态进程模型"><a href="#五状态进程模型" class="headerlink" title="五状态进程模型"></a>五状态进程模型</h3><p><img src="http://i.imgur.com/Md58ooA.jpg" alt=""></p>
<h3 id="七状态进程模型"><a href="#七状态进程模型" class="headerlink" title="七状态进程模型"></a>七状态进程模型</h3><p>添加了就绪挂起和阻塞挂起<br><img src="http://i.imgur.com/QtK5q30.jpg" alt=""></p>
<h3 id="linux状态示意图"><a href="#linux状态示意图" class="headerlink" title="linux状态示意图"></a>linux状态示意图</h3><p><img src="http://i.imgur.com/zfUhtic.jpg" alt=""></p>
<h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><p>操作系统为每一类进程建立一个或多个队列<br>队列元素为PCB<br>伴随进程状态的改变，其PCB从一个队列进入另一个队列<br><img src="http://i.imgur.com/XZeZzlY.jpg" alt=""></p>
<h3 id="五状态进程的队列模型"><a href="#五状态进程的队列模型" class="headerlink" title="五状态进程的队列模型"></a>五状态进程的队列模型</h3><p><img src="http://i.imgur.com/SdcJiLx.jpg" alt=""></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><pre><code>进程控制操作完成进程各状态之间的转换，由具有特定功能的原语完成
    进程创建原语
    进程撤消原语
    阻塞原语
    唤醒原语
    挂起原语
    激活原语
    改变进程优先级
</code></pre><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><pre><code>给新进程分配一个唯一标识以及进程控制块
为进程分配地址空间
初始化进程控制块
设置默认值 (如: 状态为 New，...)
设置相应的队列指针
    如: 把新进程加到就绪队列链表中
</code></pre><h3 id="进程的撤销"><a href="#进程的撤销" class="headerlink" title="进程的撤销"></a>进程的撤销</h3><pre><code>结束进程
    收回进程所占有的资源
    关闭打开的文件、断开网络连接、回收分配的内存、……
    撤消该进程的PCB
</code></pre><h3 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h3><pre><code>处于运行状态的进程，在其运行过程中期待某一事件发生，如等待键盘输入、等待磁盘数据传输完成、等待其它进程发送消息，当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态
</code></pre><h3 id="Unix的几个进程控制操作"><a href="#Unix的几个进程控制操作" class="headerlink" title="Unix的几个进程控制操作"></a>Unix的几个进程控制操作</h3><pre><code>fork() 通过复制调用进程来建立新的进程，是最基本的进程建立过程

exec() 包括一系列系统调用，它们都是通过用一段新的程序代码覆盖原来的地址空间，实现进程执行代码的转换

wait() 提供初级进程同步操作，能使一个进程等待另外一个进程的结束

exit() 用来终止一个进程的运行
</code></pre><h4 id="Unix的FORK-的实现"><a href="#Unix的FORK-的实现" class="headerlink" title="Unix的FORK()的实现"></a>Unix的FORK()的实现</h4><pre><code>为子进程分配一个空闲的进程描述符
    proc 结构
分配给子进程唯一标识 pid
以一次一页的方式复制父进程地址空间？
从父进程处继承共享资源，如打开的文件和当前工作目录等
将子进程的状态设为就绪，插入到就绪队列
对子进程返回标识符 0
向父进程返回子进程的 pid
</code></pre><p>Linux使用了写时复制技术COW加快创建进程Copy-On-Write</p>
<p>示例方法</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
void main(int argc, char *argv[])
{
    pid_t pid;
    pid = fork(); /* 创建一个子进程 */
    if (pid &lt; 0) { /* 出错 */
        fprintf(stderr, “fork failed”);
        exit(-1); }
    else if (pid == 0) { /* 子进程 */
        execlp(“/bin/ls”, “ls”, NULL); }
    else { /* 父进程 */
        wait(NULL); /* 父进程等待子进程结束 */
        printf(“child complete”);
        exit(0);
}
}
</code></pre><h2 id="深入理解进程概念"><a href="#深入理解进程概念" class="headerlink" title="深入理解进程概念"></a>深入理解进程概念</h2><h3 id="关于进程的讨论"><a href="#关于进程的讨论" class="headerlink" title="关于进程的讨论"></a>关于进程的讨论</h3><p><img src="http://i.imgur.com/cS7YiDl.jpg" alt=""></p>
<h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><pre><code>进程更能准确刻画并发，而程序不能
程序是静态的，进程是动态的
进程有生命周期的，有诞生有消亡，是短暂的；而程序是相对长久的
一个程序可对应多个进程
进程具有创建其他进程的功能
</code></pre><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><p>操作系统给每个进程都分配了一个地址空间</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>int myval;
int main(int argc, char *argv[])
{
myval = atoi(argv[1]);
while (1)
    printf(“myval is %d, loc 0x%lx\n”,
        myval, (long) &amp;myval);
}
</code></pre><p><strong>输出结果</strong><br><img src="http://i.imgur.com/2ejIZu1.jpg" alt=""></p>
<h4 id="进程地址空间图示"><a href="#进程地址空间图示" class="headerlink" title="进程地址空间图示"></a>进程地址空间图示</h4><p><img src="http://i.imgur.com/6iYnFgF.jpg" alt=""></p>
<h3 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h3><pre><code>对进程执行活动全过程的静态描述
    由进程地址空间内容、硬件寄存器内容及与该进程相关的内核数据结构、内核栈组成

用户相关：进程地址空间（包括代码段、数据段、堆和栈、共享库……）
寄存器相关：程序计数器、指令寄存器、程序状态寄存器、栈指针、通用寄存器等的值
内核相关：
    静态部分：PCB及各种资源数据结构
    动态部分：内核栈（不同进程在进入内核后使用不同的内核栈）
</code></pre><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><pre><code>将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换

进程运行时，其硬件状态保存在CPU上的寄存器中
寄存器：程序计数器、程序状态寄存器、栈指针、通用寄存器、其他控制寄存器的值

进程不运行时，这些寄存器的值保存在进程控制块PCB中；当操作系统要运行一个新的进程时，将PCB中的相关值送到对应的寄存器中
</code></pre><h2 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h2><h3 id="为什么在进程中再派生线程？"><a href="#为什么在进程中再派生线程？" class="headerlink" title="为什么在进程中再派生线程？"></a>为什么在进程中再派生线程？</h3><pre><code>三个理由
    应用的需要
    开销的考虑
    性能的考虑
</code></pre><h3 id="典型的应用"><a href="#典型的应用" class="headerlink" title="典型的应用"></a>典型的应用</h3><pre><code>Web服务器
工作方式
    从客户端接收网页请求（http协议）
    从磁盘上检索相关网页，读入内存
    将网页返回给对应的客户端
如何提高服务器工作效率？
    网页缓存（Web page Cache）
</code></pre><h4 id="如果没有线程"><a href="#如果没有线程" class="headerlink" title="如果没有线程"></a>如果没有线程</h4><pre><code>两种解决方案：
    一个服务进程
        顺序编程；性能下降
    有限状态机
        编程模型复杂；采用非阻塞I/O
</code></pre><h4 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h4><h4 id="开销的考虑"><a href="#开销的考虑" class="headerlink" title="开销的考虑"></a>开销的考虑</h4><pre><code>进程相关的操作：
    创建进程
    撤消进程
    进程通信
    进程切换
→ 时间/空间开销大，限制了并发度的提高
</code></pre><hr>
<pre><code>线程的开销小
    创建一个新线程花费时间少（撤销亦如此）
    两个线程切换花费时间少
    线程之间相互通信无须调用内核（同一进程内的线程共享内存和文件）
</code></pre><hr>
<pre><code>多个线程，有的计算，有的I/O
    多个处理器
</code></pre><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h4><p>线程继承了进程的属性<br>线程：进程中的一个运行实体，是CPU的调度单位 有时将线程称为轻量级进程<br>在同一进程增加了多个执行序列（线程）</p>
<h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><pre><code>线程：
    有标示符ID
    有状态及状态转换 → 需要提供一些操作
    不运行时需要保存的上下文
        有上下文环境：程序计数器等寄存器
    有自己的栈和栈指针 

    共享所在进程的地址空间和其他资源

    可以创建、撤消另一个线程
        程序开始是以一个单线程进程方式运行的
</code></pre><h2 id="线程机制的实现"><a href="#线程机制的实现" class="headerlink" title="线程机制的实现"></a>线程机制的实现</h2><pre><code>用户级线程
核心级线程
混合—两者结合方法
</code></pre><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><pre><code>在用户空间建立线程库：提供一组管理线程的过程
运行时系统：完成线程的管理工作（操作、线程表）
内核管理的还是进程，不知道线程的存在
线程切换不需要内核态特权
例子：UNIX
</code></pre><h4 id="POSIX线程库"><a href="#POSIX线程库" class="headerlink" title="POSIX线程库"></a>POSIX线程库</h4><p><img src="http://i.imgur.com/0OmstJz.jpg" alt=""></p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><pre><code>优点：
    线程切换快
    调度算法是应用程序特定的
    用户级线程可运行在任何操作系统上（只需要实现线程库）
缺点：
    内核只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上
    大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中所有线程也被阻塞（如何改变？）
</code></pre><h3 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h3><pre><code>内核管理所有线程管理，并向应用程序提供API接口
内核维护进程和线程的上下文
线程的切换需要内核支持
以线程为基础进行调度
例子：Windows
</code></pre><h3 id="混合模型"><a href="#混合模型" class="headerlink" title="混合模型"></a>混合模型</h3><pre><code>线程创建在用户空间完成
线程调度等在核心态完成
</code></pre><h2 id="重点小结"><a href="#重点小结" class="headerlink" title="重点小结"></a>重点小结</h2><pre><code>并发性 任何进程都可以与其他进程一起向前推进
动态性 进程是正在执行程序的实例
    进程是动态产生，动态消亡的
    进程在其生命周期内，在三种基本状态之间转换
独立性 
    进程是资源分配的一个独立单位 例如：各进程的地址空间相互独立
交互性 
    指进程在执行过程中可能与其他进程产生直接或间接的关系
异步性 
    每个进程都以其相对独立的、不可预知的速度向前推进
进程映像 
    程序 + 数据 + 栈(用户栈、内核栈) + PCB
</code></pre><hr>
<pre><code>线程
    多线程应用场景
    线程基本概念、属性
    线程实现机制

可再入程序（可重入）：
    可被多个进程同时调用的程序，具有下列性质：
    它是纯代码的，即在执行过程中自身不改变；调用它的进程应该提供数据区
</code></pre><hr>
<pre><code>重点阅读教材
第2章相关内容：2.1、2.2(除2.2.8-2.2.10外)
</code></pre><h1 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是处理器调度"><a href="#什么是处理器调度" class="headerlink" title="什么是处理器调度"></a>什么是处理器调度</h3><pre><code>CPU调度
    —— 其任务是控制、协调进程对CPU的竞争
    即按一定的调度算法从就绪队列中选择一个进程，把CPU的使用权交给被选中的进程
    如果没有就绪进程，系统会安排一个系统空闲进程或idle进程
</code></pre><hr>
<pre><code>系统场景
    N个进程就绪、等待上CPU运行
    M个CPU，M ≥ 1
    需要决策：给哪一个进程分配哪一个CPU？
</code></pre><h3 id="要解决的三个问题"><a href="#要解决的三个问题" class="headerlink" title="要解决的三个问题"></a>要解决的三个问题</h3><pre><code>WHAT：按什么原则选择下一个要执行的进程
    — 调度算法

WHEN：何时选择
    — 调度时机

HOW： 如何让被选中的进程上CPU运行
    — 调度过程（进程的上下文切换）
</code></pre><h3 id="调度的时机"><a href="#调度的时机" class="headerlink" title="调度的时机"></a>调度的时机</h3><pre><code>事件发生 → 当前运行的进程暂停运行 → 硬件机制响应后 → 进入操作系统，处理相应的事件 → 结束处理后：
某些进程的状态会发生变化，也可能又创建了一些新的进程
→ 就绪队列有调整 → 需要进程调度根据预设的调度算法从就绪队列选一个进程
</code></pre><hr>
<pre><code>典型的事件举例：
创建、唤醒、退出等进程控制操作
进程等待I/O、I/O中断
时钟中断，如：时间片用完、计时器到时
进程执行过程中出现abort异常
</code></pre><hr>
<h4 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h4><pre><code>进程正常终止 或 由于某种错误而终止
新进程创建 或 一个等待进程变成就绪
当一个进程从运行态进入阻塞态
当一个进程从运行态变为就绪态
</code></pre><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><pre><code>进程调度程序从就绪队列选择了要运行的进程：
    这个进程可以是刚刚被暂停执行的进程，也可能是另一个新的进程
进程切换
    进程切换：是指一个进程让出处理器，由另一个进程占用处理器的过程
</code></pre><hr>
<pre><code>进程切换主要包括两部分工作：
    切换全局页目录以加载一个新的地址空间
    切换内核栈和硬件上下文，其中硬件上下文包括了内核执行新进程需要的全部信息，如CPU相关寄存器

切换过程包括了对原来运行进程各种状态的保存和对新的进程各种状态的恢复
</code></pre><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><p>场景：进程A下CPU，进程B上CPU  </p>
<pre><code>保存进程A的上下文环境（程序计数器、程序状态字、其他寄存器……）
用新状态和其他相关信息更新进程A的PCB
把进程A移至合适的队列（就绪、阻塞……）
将进程B的状态设置为运行态
从进程B的PCB中恢复上下文（程序计数器 、程序状态字、其他寄存器……）
</code></pre><h4 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h4><pre><code>直接开销：内核完成切换所用的CPU时间
    保存和恢复寄存器……
    切换地址空间（相关指令比较昂贵）
间接开销
    高速缓存(Cache)、缓冲区缓存(Buffer Cache)和TLB(Translation Look-aside Buffer)失效
</code></pre><h3 id="调度算法的设计"><a href="#调度算法的设计" class="headerlink" title="调度算法的设计"></a>调度算法的设计</h3><pre><code>什么情况下需要仔细斟酌调度算法？
    批处理系统 → 多道程序设计系统 → 批处理与分时的混合系统 → 个人计算机 → 网络服务器
</code></pre><h4 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h4><pre><code>吞吐量 Throughput — 每单位时间完成的进程数目
周转时间TT(Turnaround Time)
    每个进程从提出请求到运行完成的时间
响应时间RT(Response Time)
    从提出请求到第一次回应的时间

其他
    CPU 利用率(CPU Utilization)
        CPU做有效工作的时间比例
    等待时间(Waiting time)
        每个进程在就绪队列(ready queue)中等待的时间
</code></pre><h2 id="设计调度算法要考虑的几个问题"><a href="#设计调度算法要考虑的几个问题" class="headerlink" title="设计调度算法要考虑的几个问题"></a>设计调度算法要考虑的几个问题</h2><h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><pre><code>静态优先级：
    进程创建时指定，运行过程中不再改变
动态优先级：
    进程创建时指定了一个优先级，运行过程中可以动态变化
如：等待时间较长的进程可提升其优先级
</code></pre><h3 id="进程就绪队列组织"><a href="#进程就绪队列组织" class="headerlink" title="进程就绪队列组织"></a>进程就绪队列组织</h3><p>按优先级排队</p>
<p>另一种排队方式</p>
<h3 id="抢占与非抢占"><a href="#抢占与非抢占" class="headerlink" title="抢占与非抢占"></a>抢占与非抢占</h3><pre><code>指占用CPU的方式：
    可抢占式Preemptive（可剥夺式）
        当有比正在运行的进程优先级更高的进程就绪时，系统可强行剥夺正在运行进程的CPU，提供给具有更高优先级的进程使用
    不可抢占式Non-preemptive（不可剥夺式 ）
        某一进程被调度运行后，除非由于它自身的原因不能运行，否则一直运行下去
</code></pre><h3 id="IO密集型与CPU密集型进程"><a href="#IO密集型与CPU密集型进程" class="headerlink" title="IO密集型与CPU密集型进程"></a>IO密集型与CPU密集型进程</h3><pre><code>按进程执行过程中的行为划分：
    I/O密集型或I/O型(I/O-bound)
        频繁的进行I/O，通常会花费很多时间等待I/O操作的完成
     CPU密集型或CPU型或计算密集型(CPU-bound)
        需要大量的CPU时间进行计算
</code></pre><h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><pre><code>Time slice 或 quantum
一个时间段，分配给调度上CPU的进程，确定了允许该进程运行的时间长度
如何选择时间片呢？
</code></pre><h2 id="批处理系统的调度算法"><a href="#批处理系统的调度算法" class="headerlink" title="批处理系统的调度算法"></a>批处理系统的调度算法</h2><pre><code>先来先服务（FCFS-First Come First Serve）
最短作业优先（SJF-Shortest Job First）
最短剩余时间优先
（SRTN-Shortest Remaining Time Next）
最高相应比优先
（HRRN-Highest Response Ratio Next）
</code></pre><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><pre><code>First Come First Serve
    先进先出 First In First Out (FIFO)
    按照进程就绪的先后顺序使用CPU
    非抢占

优缺点
公平
实现简单
长进程后面的短进程需要等很长时间，不利于用户体验
</code></pre><h3 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h3><pre><code>Shortest Job First
具有最短完成时间的进程优先执行
非抢占式

最短剩余时间优先
    Shortest Remaining Time Next(SRTN)
SJF抢占式版本，即当一个新就绪的进程比当前运行进程具有更短的完成时间时，系统抢占当前进程，选择新就绪的进程执行
</code></pre><hr>
<pre><code>优缺点
    最短的平均周转时间
        在所有进程同时可运行时，采用SJF调度算法可以得到最短的平均周转时间
不公平
源源不断的短任务到来，可能使长的任务长时间得不到运行 → 产生 “饥饿”现象 (starvation)
</code></pre><h3 id="最高相应比优先HRRN"><a href="#最高相应比优先HRRN" class="headerlink" title="最高相应比优先HRRN"></a>最高相应比优先HRRN</h3><pre><code>Highest Response Ratio Next
是一个综合的算法
调度时，首先计算每个进程的响应比R；之后，总是选择 R 最高的进程执行
</code></pre><hr>
<pre><code>响应比R = 周转时间 / 处理时间 =（处理时间 + 等待时间）/ 处理时间 = 1 +（等待时间 / 处理时间）
</code></pre><h2 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a>交互式系统的调度算法</h2><p>轮转调度（RR-Round Robin）<br>最高优先级调度（HPF—Highest Priority First）<br>多级反馈队列（Multiple feedback queue）<br>最短进程优先（Shortest Process Next）</p>
<h3 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h3><pre><code>目标
    为短任务改善平均响应时间
解决问题的思路
    周期性切换
    每个进程分配一个时间片
    时钟中断 → 轮换
</code></pre><hr>
<pre><code>如何选择合适的时间片?
    太长 --大于典型的交互时间
        降级为先来先服务算法
        延长短进程的响应时间
    太短 --小于典型的交互时间
        进程切换浪费CPU时间
</code></pre><hr>
<pre><code>优缺点
    公平
    有利于交互式计算，响应时间快
    由于进程切换，时间片轮转算法要花费较高的开销
假设时间片 10ms，如果进程切换花费0.1ms，CPU开销约占1%
    RR对不同大小的进程是有利的
    但是对于相同大小的进程呢？
</code></pre><p>但是对于相同大小的进程呢？</p>
<h3 id="虚拟轮转法"><a href="#虚拟轮转法" class="headerlink" title="虚拟轮转法"></a>虚拟轮转法</h3><p>有一个辅助队列，选择其中的IO进程，辅助队列为空，再从就绪队列中选</p>
<h3 id="最高优先级调度"><a href="#最高优先级调度" class="headerlink" title="最高优先级调度"></a>最高优先级调度</h3><pre><code>选择优先级最高的进程投入运行
通常：系统进程优先级 高于 用户进程
    前台进程优先级 高于 后台进程
    操作系统更偏好 I/O型进程
优先级可以是静态不变的，也可以动态调整
    优先数可以决定优先级
就绪队列可以按照优先级组织
实现简单；不公平
</code></pre><hr>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><pre><code>又称：优先级反置、翻转、倒挂
现象
    一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行
</code></pre><hr>
<pre><code>设H是高优先级进程，L是低优先级进程， M是中优先级进程（CPU型）
    场景：L进入临界区执行，之后被抢占；
        H也要进入临界区，失败，被阻塞；
        M上CPU执行，L无法执行所以H也无法执行
</code></pre><hr>
<pre><code>影响
    系统错误
    高优先级进程停滞不前，导致系统性能降低

解决方案
    设置优先级上限
    优先级继承
    使用中断禁止
</code></pre><h2 id="多级反馈队列调度算法、各种调度算法小结等"><a href="#多级反馈队列调度算法、各种调度算法小结等" class="headerlink" title="多级反馈队列调度算法、各种调度算法小结等"></a>多级反馈队列调度算法、各种调度算法小结等</h2><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><pre><code>Multilevel Feedback
是UNIX的一个分支BSD （加州大学伯克利分校开发和发布的）5.3版所采用的调度算法
是一个综合调度算法
</code></pre><hr>
<pre><code>设置多个就绪队列，第一级队列优先级最高
给不同就绪队列中的进程分配长度不同的时间片，第一级队列时间片最小；随着队列优先级别的降低，时间片增大
当第一级队列为空时，在第二级队列调度，以此类推
各级队列按照时间片轮转方式 进行调度
当一个新创建进程就绪后，进入第一级队列
进程用完时间片而放弃CPU，进入下一级就绪队列
由于阻塞而放弃CPU的进程进入相应的等待队列，一旦等待的事件发生，该进程回到原来一级就绪队列（？）
</code></pre><hr>
<pre><code>若允许抢占
    当有一个优先级更高的进程就绪时，可以抢占CPU
    被抢占的进程回到原来一级就绪队列末尾（或者？）
</code></pre><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p><img src="img/opSystem/forth/1.jpg" alt=""></p>
<h3 id="多处理器调度算法设计"><a href="#多处理器调度算法设计" class="headerlink" title="多处理器调度算法设计"></a>多处理器调度算法设计</h3><pre><code>不仅要决定选择哪一个进程执行
    还需要决定在哪一个CPU上执行
要考虑进程在多个CPU之间迁移时的开销
    高速缓存失效、TLB失效
    尽可能使进程总是在同一个CPU上执行
        如果每个进程可以调度到所有CPU上，假如进程上次在CPU1上执行，本次被调度到CPU2，则会增加高速缓存失效、TLB失效；如果每个进程尽量调度到指定的CPU上，各种失效就会减少
考虑负载均衡问题
</code></pre><h2 id="典型操作系统的调度算法"><a href="#典型操作系统的调度算法" class="headerlink" title="典型操作系统的调度算法"></a>典型操作系统的调度算法</h2><pre><code>UNIX 动态优先数法
5.3BSD 多级反馈队列法
Linux 抢占式调度
Windows 基于优先级的抢占式多任务调度
Solaris 综合调度算法
</code></pre><h3 id="LINUX调度算法的发展历史"><a href="#LINUX调度算法的发展历史" class="headerlink" title="LINUX调度算法的发展历史"></a>LINUX调度算法的发展历史</h3><pre><code>Linux2.4简单的基于优先级调度

Linux2.6O(1)调度器

Linux2.6 SD调度器补丁

Linux2.6RSDL调度器补丁

Linux2.6CFS调度器：完全公平调度算法
</code></pre><h3 id="Windows线程调度"><a href="#Windows线程调度" class="headerlink" title="Windows线程调度"></a>Windows线程调度</h3><pre><code>调度单位是线程
采用基于动态优先级的、抢占式调度，结合时间配额的调整
</code></pre><hr>
<pre><code>就绪线程按优先级进入相应队列
系统总是选择优先级最高的就绪线程运行
同一优先级的各线程按时间片轮转进行调度
多CPU系统中允许多个线程并行运行
</code></pre><hr>
<pre><code>引发线程调度的条件：
    一个线程的优先级改变了
    一个线程改变了它的亲和(Affinity)处理机集合

    线程正常终止 或 由于某种错误而终止
    新线程创建 或 一个等待线程变成就绪
    当一个线程从运行态进入阻塞态
    当一个线程从运行态变为就绪态
</code></pre><hr>
<pre><code>Windows使用32个线程优先级，分成三类
零页线程：0级
    用于对系统中空闲物理页面清零
实时优先级线程不改变其优先级
可变优先级线程：其优先级可以在一定范围内升高或降    低 基本优先级 和 当前优先级
</code></pre><h3 id="线程的时间配额"><a href="#线程的时间配额" class="headerlink" title="线程的时间配额"></a>线程的时间配额</h3><pre><code>时间配额不是一个时间长度值，而一个称为配额单位(quantum unit)的整数
一个线程用完了自己的时间配额时，如果没有其他相同优先级的线程，Windows将重新给该线程分配一个新的时间配额，让它继续运行
</code></pre><hr>
<pre><code>时间配额的一种特殊作用
    假设用户首先启动了一个运行时间很长的电子表格计算程序，然后切换到一个游戏程序(需要复杂图形计算并显示，CPU型)
    如果前台的游戏进程提高它的优先级，则后台的电子表格计算进程就几乎得不到CPU时间了
    但增加游戏进程的时间配额，则不会停止执行电子表格计算，只是给游戏进程的CPU时间多一些而已
</code></pre><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><pre><code>主动切换
抢占
时间配额用完
</code></pre><h4 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h4><pre><code>当线程被抢占时，它被放回相应优先级的就绪队列的队首
    处于实时优先级的线程在被抢占时，时间配额被重置为一个完整的时间配额
    处于可变优先级的线程在被抢占时，时间配额不变，重新得到CPU后将运行剩余的时间配额
</code></pre><h4 id="时间配额用完"><a href="#时间配额用完" class="headerlink" title="时间配额用完"></a>时间配额用完</h4><pre><code>假设线程A的时间配额用完
    A的优先级没有降低
    如果队列中有其他就绪线程，选择下一个线程执行，A回到原来就绪队列末尾
    如果队列中没有其他就绪线程，系统给线程A分配一个新的时间配额，让它继续运行

    A的优先级降低了，Windows 将选择一个更高优先级的线程
</code></pre><h3 id="线程优先级与时间配额调整"><a href="#线程优先级与时间配额调整" class="headerlink" title="线程优先级与时间配额调整"></a>线程优先级与时间配额调整</h3><pre><code>Windows的调度策略
    如何体现对某类线程具有倾向性？
    如何解决由于调度策略中潜在的不公平性而带来饥饿现象？
    如何改善系统吞吐量、响应时间等整体特征？

解决方案
    提升线程的优先级
    给线程分配一个很大的时间配额
</code></pre><h4 id="线程优先级提升"><a href="#线程优先级提升" class="headerlink" title="线程优先级提升"></a>线程优先级提升</h4><pre><code>下列5种情况，Windows 会提升线程的当前优先级：
    I/O操作完成
    信号量或事件等待结束
    前台进程中的线程完成一个等待操作
    由于窗口活动而唤醒窗口线程
    线程处于就绪态超过了一定的时间还没有运行
        —— “饥饿”现象
针对可变优先级范围内(1至15)的线程优先级
</code></pre><hr>
<p>I/O操作完成后的线程优先级提升</p>
<pre><code>在完成I/O操作后，Windows 将临时提升等待该操作线程的优先级，保证该线程能更快上CPU运行进行数据处理
优先级的提升值由设备驱动程序决定，提升建议值保存在系统文件“Wdm.h”或“Ntddk.h”中
优先级的提升幅度与对I/O请求的响应时间要求是一致的，响应时间要求越高，优先级提升幅度越大
设备驱动程序在完成I/O请求时通过内核函数IoCompleteRequest来指定优先级提升的幅度
为避免不公平，在I/O操作完成唤醒等待线程时会将该线程的时间配额减1
</code></pre><hr>
<p>“饥饿”线程优先级提升 </p>
<pre><code>系统线程“平衡集管理器(balance set manager)” 每秒钟扫描一次就绪队列，发现是否存在等待时间超过300个时钟中断间隔的线程
平衡集管理器将这些线程的优先级提升到15，并分配给它一个长度为正常值4倍的时间配额
当被提升的线程用完它的时间配额后，立即衰减到它原来的基本优先级
</code></pre><h2 id="重点-2"><a href="#重点-2" class="headerlink" title="重点"></a>重点</h2><h3 id="本讲重点"><a href="#本讲重点" class="headerlink" title="本讲重点"></a>本讲重点</h3><pre><code>掌握处理器调度的相关概念
    调度时机、进程切换
    调度标准：吞吐量、周转时间、响应时间
    优先级/优先数、抢占/非抢占、I/O型与CPU型
掌握主要的调度算法
    先来先服务、短作业优先、最高相应比优先
    时间片轮转、 最高优先级
    多级反馈队列
了解Windows、多处理器调度的基本思想
</code></pre><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><pre><code>重点阅读教材
第2章相关内容：2.4
第11章相关内容：11.4.3中的调度部分

重点概念
调度时机 进程切换 抢占/非抢占 时间片
优先级反转 饥饿 优先级与优先数 优先级提升
先来先服务 短作业优先 最高相应比优先
时间片轮转 最高优先级 多级队列反馈
吞吐量 周转时间 响应时间
</code></pre>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/21/计算机组成原理/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/22/spring揭秘读书笔记/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="lily" />
          <p class="site-author-name" itemprop="name">lily</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统概述"><span class="nav-number">1.</span> <span class="nav-text">操作系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统做了什么？"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统做了什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从上述步骤中得到了什么"><span class="nav-number">1.1.1.</span> <span class="nav-text">从上述步骤中得到了什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#换个角度看用户程序的执行"><span class="nav-number">1.1.2.</span> <span class="nav-text">换个角度看用户程序的执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的定义与作用"><span class="nav-number">1.2.</span> <span class="nav-text">操作系统的定义与作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——"><span class="nav-number">1.2.1.</span> <span class="nav-text">操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#几个关键词"><span class="nav-number">1.2.2.</span> <span class="nav-text">几个关键词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三个作用"><span class="nav-number">1.2.3.</span> <span class="nav-text">三个作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#资源的管理者"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">资源的管理者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#各种系统服务的提供者"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">各种系统服务的提供者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对硬件机器的扩展"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">对硬件机器的扩展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的主要特征"><span class="nav-number">1.3.</span> <span class="nav-text">操作系统的主要特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发"><span class="nav-number">1.3.1.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享"><span class="nav-number">1.3.2.</span> <span class="nav-text">共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟"><span class="nav-number">1.3.3.</span> <span class="nav-text">虚拟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机"><span class="nav-number">1.3.4.</span> <span class="nav-text">随机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#典型操作系统的架构"><span class="nav-number">1.4.</span> <span class="nav-text">典型操作系统的架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows架构"><span class="nav-number">1.4.1.</span> <span class="nav-text">Windows架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX架构"><span class="nav-number">1.4.2.</span> <span class="nav-text">UNIX架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux内核组间"><span class="nav-number">1.4.3.</span> <span class="nav-text">linux内核组间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的分类"><span class="nav-number">1.5.</span> <span class="nav-text">操作系统的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的发展历程"><span class="nav-number">1.5.1.</span> <span class="nav-text">操作系统的发展历程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">目标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传统操作系统的分类"><span class="nav-number">1.5.2.</span> <span class="nav-text">传统操作系统的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#批处理操作系统"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">批处理操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分时系统"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">分时系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过操作系统"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">通过操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实时操作系统"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">实时操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#个人计算机操作系统"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">个人计算机操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络操作系统"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">网络操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式操作系统"><span class="nav-number">1.5.2.7.</span> <span class="nav-text">分布式操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#嵌入式操作系统"><span class="nav-number">1.5.2.8.</span> <span class="nav-text">嵌入式操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#智能卡操作系统"><span class="nav-number">1.5.2.9.</span> <span class="nav-text">智能卡操作系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点"><span class="nav-number">1.6.</span> <span class="nav-text">重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统原理"><span class="nav-number">2.</span> <span class="nav-text">操作系统原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#处理器状态"><span class="nav-number">2.1.</span> <span class="nav-text">处理器状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU"><span class="nav-number">2.1.1.</span> <span class="nav-text">CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#控制和状态寄存器"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">控制和状态寄存器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的需求，保护"><span class="nav-number">2.1.2.</span> <span class="nav-text">操作系统的需求，保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理器的状态"><span class="nav-number">2.1.3.</span> <span class="nav-text">处理器的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特权指令和非特权指令"><span class="nav-number">2.1.4.</span> <span class="nav-text">特权指令和非特权指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例"><span class="nav-number">2.1.5.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU状态之间的转换"><span class="nav-number">2.1.6.</span> <span class="nav-text">CPU状态之间的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中断和异常机制"><span class="nav-number">2.2.</span> <span class="nav-text">中断和异常机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">2.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么引入中断与异常"><span class="nav-number">2.2.2.</span> <span class="nav-text">为什么引入中断与异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件"><span class="nav-number">2.2.3.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">2.2.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作原理"><span class="nav-number">2.3.</span> <span class="nav-text">工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中断响应"><span class="nav-number">2.3.1.</span> <span class="nav-text">中断响应</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#过程示意"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">过程示意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断向量表"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">中断向量表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过程"><span class="nav-number">2.3.2.</span> <span class="nav-text">过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断处理程序"><span class="nav-number">2.3.3.</span> <span class="nav-text">中断处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-1"><span class="nav-number">2.3.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例：x86处理器"><span class="nav-number">2.4.</span> <span class="nav-text">实例：x86处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x86处理器对中断的支持"><span class="nav-number">2.5.</span> <span class="nav-text">x86处理器对中断的支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统调用机制"><span class="nav-number">2.6.</span> <span class="nav-text">系统调用机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用"><span class="nav-number">2.6.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型系统调用"><span class="nav-number">2.6.2.</span> <span class="nav-text">典型系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统调用机制的设计"><span class="nav-number">2.6.3.</span> <span class="nav-text">系统调用机制的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数传递过程问题"><span class="nav-number">2.6.4.</span> <span class="nav-text">参数传递过程问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行过程"><span class="nav-number">2.6.5.</span> <span class="nav-text">执行过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于x86处理器的linux的系统调用实现"><span class="nav-number">2.7.</span> <span class="nav-text">基于x86处理器的linux的系统调用实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过程-1"><span class="nav-number">2.7.1.</span> <span class="nav-text">过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用执行流程"><span class="nav-number">2.7.2.</span> <span class="nav-text">调用执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OS底层工作步骤"><span class="nav-number">2.7.3.</span> <span class="nav-text">OS底层工作步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-1"><span class="nav-number">2.8.</span> <span class="nav-text">重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程-线程模型"><span class="nav-number">3.</span> <span class="nav-text">进程/线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程基本概念"><span class="nav-number">3.1.</span> <span class="nav-text">进程基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多道程序设计"><span class="nav-number">3.1.1.</span> <span class="nav-text">多道程序设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发环境与并发程序"><span class="nav-number">3.1.2.</span> <span class="nav-text">并发环境与并发程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的定义"><span class="nav-number">3.1.3.</span> <span class="nav-text">进程的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程控制块PCB"><span class="nav-number">3.1.4.</span> <span class="nav-text">进程控制块PCB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux：task-struct"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">Linux：task_struct</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程状态及状态转换"><span class="nav-number">3.2.</span> <span class="nav-text">进程状态及状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的三种基本状态"><span class="nav-number">3.2.1.</span> <span class="nav-text">进程的三种基本状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三状态模型以及状态转换"><span class="nav-number">3.2.2.</span> <span class="nav-text">三状态模型以及状态转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他状态"><span class="nav-number">3.2.3.</span> <span class="nav-text">其他状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五状态进程模型"><span class="nav-number">3.2.4.</span> <span class="nav-text">五状态进程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七状态进程模型"><span class="nav-number">3.2.5.</span> <span class="nav-text">七状态进程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux状态示意图"><span class="nav-number">3.2.6.</span> <span class="nav-text">linux状态示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程队列"><span class="nav-number">3.2.7.</span> <span class="nav-text">进程队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五状态进程的队列模型"><span class="nav-number">3.2.8.</span> <span class="nav-text">五状态进程的队列模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程控制"><span class="nav-number">3.3.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的创建"><span class="nav-number">3.3.1.</span> <span class="nav-text">进程的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的撤销"><span class="nav-number">3.3.2.</span> <span class="nav-text">进程的撤销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程阻塞"><span class="nav-number">3.3.3.</span> <span class="nav-text">进程阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unix的几个进程控制操作"><span class="nav-number">3.3.4.</span> <span class="nav-text">Unix的几个进程控制操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Unix的FORK-的实现"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">Unix的FORK()的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解进程概念"><span class="nav-number">3.4.</span> <span class="nav-text">深入理解进程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于进程的讨论"><span class="nav-number">3.4.1.</span> <span class="nav-text">关于进程的讨论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程与程序的区别"><span class="nav-number">3.4.2.</span> <span class="nav-text">进程与程序的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程地址空间"><span class="nav-number">3.4.3.</span> <span class="nav-text">进程地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-1"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程地址空间图示"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">进程地址空间图示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程映像"><span class="nav-number">3.4.4.</span> <span class="nav-text">进程映像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文切换"><span class="nav-number">3.4.5.</span> <span class="nav-text">上下文切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的引入"><span class="nav-number">3.5.</span> <span class="nav-text">线程的引入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么在进程中再派生线程？"><span class="nav-number">3.5.1.</span> <span class="nav-text">为什么在进程中再派生线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型的应用"><span class="nav-number">3.5.2.</span> <span class="nav-text">典型的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如果没有线程"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">如果没有线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#web服务器"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">web服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开销的考虑"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">开销的考虑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">3.5.3.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的基本概念"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">线程的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的属性"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">线程的属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程机制的实现"><span class="nav-number">3.6.</span> <span class="nav-text">线程机制的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用户级线程"><span class="nav-number">3.6.1.</span> <span class="nav-text">用户级线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#POSIX线程库"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">POSIX线程库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-2"><span class="nav-number">3.6.1.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心级线程"><span class="nav-number">3.6.2.</span> <span class="nav-text">核心级线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#混合模型"><span class="nav-number">3.6.3.</span> <span class="nav-text">混合模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点小结"><span class="nav-number">3.7.</span> <span class="nav-text">重点小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#处理器调度"><span class="nav-number">4.</span> <span class="nav-text">处理器调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念-1"><span class="nav-number">4.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是处理器调度"><span class="nav-number">4.1.1.</span> <span class="nav-text">什么是处理器调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#要解决的三个问题"><span class="nav-number">4.1.2.</span> <span class="nav-text">要解决的三个问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度的时机"><span class="nav-number">4.1.3.</span> <span class="nav-text">调度的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时机"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程切换"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">进程切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具体步骤"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">具体步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开销"><span class="nav-number">4.1.3.4.</span> <span class="nav-text">开销</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度算法的设计"><span class="nav-number">4.1.4.</span> <span class="nav-text">调度算法的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#衡量指标"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">衡量指标</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计调度算法要考虑的几个问题"><span class="nav-number">4.2.</span> <span class="nav-text">设计调度算法要考虑的几个问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程优先级"><span class="nav-number">4.2.1.</span> <span class="nav-text">进程优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程就绪队列组织"><span class="nav-number">4.2.2.</span> <span class="nav-text">进程就绪队列组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抢占与非抢占"><span class="nav-number">4.2.3.</span> <span class="nav-text">抢占与非抢占</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO密集型与CPU密集型进程"><span class="nav-number">4.2.4.</span> <span class="nav-text">IO密集型与CPU密集型进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间片"><span class="nav-number">4.2.5.</span> <span class="nav-text">时间片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#批处理系统的调度算法"><span class="nav-number">4.3.</span> <span class="nav-text">批处理系统的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#先来先服务"><span class="nav-number">4.3.1.</span> <span class="nav-text">先来先服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#短作业优先"><span class="nav-number">4.3.2.</span> <span class="nav-text">短作业优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最高相应比优先HRRN"><span class="nav-number">4.3.3.</span> <span class="nav-text">最高相应比优先HRRN</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交互式系统的调度算法"><span class="nav-number">4.4.</span> <span class="nav-text">交互式系统的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#轮转调度"><span class="nav-number">4.4.1.</span> <span class="nav-text">轮转调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟轮转法"><span class="nav-number">4.4.2.</span> <span class="nav-text">虚拟轮转法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最高优先级调度"><span class="nav-number">4.4.3.</span> <span class="nav-text">最高优先级调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级反转"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">优先级反转</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多级反馈队列调度算法、各种调度算法小结等"><span class="nav-number">4.5.</span> <span class="nav-text">多级反馈队列调度算法、各种调度算法小结等</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多级反馈队列调度算法"><span class="nav-number">4.5.1.</span> <span class="nav-text">多级反馈队列调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-3"><span class="nav-number">4.5.2.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多处理器调度算法设计"><span class="nav-number">4.5.3.</span> <span class="nav-text">多处理器调度算法设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#典型操作系统的调度算法"><span class="nav-number">4.6.</span> <span class="nav-text">典型操作系统的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LINUX调度算法的发展历史"><span class="nav-number">4.6.1.</span> <span class="nav-text">LINUX调度算法的发展历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows线程调度"><span class="nav-number">4.6.2.</span> <span class="nav-text">Windows线程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的时间配额"><span class="nav-number">4.6.3.</span> <span class="nav-text">线程的时间配额</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度策略"><span class="nav-number">4.6.4.</span> <span class="nav-text">调度策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#抢占"><span class="nav-number">4.6.4.1.</span> <span class="nav-text">抢占</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间配额用完"><span class="nav-number">4.6.4.2.</span> <span class="nav-text">时间配额用完</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程优先级与时间配额调整"><span class="nav-number">4.6.5.</span> <span class="nav-text">线程优先级与时间配额调整</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程优先级提升"><span class="nav-number">4.6.5.1.</span> <span class="nav-text">线程优先级提升</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-2"><span class="nav-number">4.7.</span> <span class="nav-text">重点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本讲重点"><span class="nav-number">4.7.1.</span> <span class="nav-text">本讲重点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#要求"><span class="nav-number">4.7.2.</span> <span class="nav-text">要求</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lily</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  

  

  

  

  


</body>
</html>

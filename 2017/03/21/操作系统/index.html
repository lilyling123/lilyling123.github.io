<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://yoursite.com/2017/03/21/操作系统/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="操作系统">
<meta property="og:image" content="http://i.imgur.com/Md58ooA.jpg">
<meta property="og:image" content="http://i.imgur.com/QtK5q30.jpg">
<meta property="og:image" content="http://i.imgur.com/zfUhtic.jpg">
<meta property="og:image" content="http://i.imgur.com/XZeZzlY.jpg">
<meta property="og:image" content="http://i.imgur.com/SdcJiLx.jpg">
<meta property="og:image" content="http://i.imgur.com/cS7YiDl.jpg">
<meta property="og:image" content="http://i.imgur.com/2ejIZu1.jpg">
<meta property="og:image" content="http://i.imgur.com/6iYnFgF.jpg">
<meta property="og:image" content="http://i.imgur.com/0OmstJz.jpg">
<meta property="og:image" content="http://yoursite.com/img/opSystem/forth/1.jpg">
<meta property="og:image" content="http://i.imgur.com/vl6oxdi.jpg">
<meta property="og:image" content="http://i.imgur.com/ifkpI4v.jpg">
<meta property="og:image" content="http://i.imgur.com/kiLLuu6.jpg">
<meta property="og:image" content="http://i.imgur.com/XM6g4tn.jpg">
<meta property="og:image" content="http://i.imgur.com/6CmUVag.jpg">
<meta property="og:image" content="http://i.imgur.com/QRMKEIh.jpg">
<meta property="og:image" content="http://i.imgur.com/EZuWkXa.jpg">
<meta property="og:image" content="http://i.imgur.com/uNs6069.jpg">
<meta property="og:image" content="http://i.imgur.com/gHeUaSg.jpg">
<meta property="og:image" content="http://i.imgur.com/06aIUmm.jpg">
<meta property="og:image" content="http://i.imgur.com/fwqMmfW.jpg">
<meta property="og:image" content="http://i.imgur.com/AjKr58E.jpg">
<meta property="og:image" content="http://i.imgur.com/o03xMIo.jpg">
<meta property="og:image" content="http://i.imgur.com/OKGbAYs.jpg">
<meta property="og:image" content="http://i.imgur.com/Eb0yzM5.jpg">
<meta property="og:image" content="http://i.imgur.com/kA8DNSC.jpg">
<meta property="og:image" content="http://i.imgur.com/MI0JAbj.jpg">
<meta property="og:image" content="http://i.imgur.com/0nN34dY.jpg">
<meta property="og:updated_time" content="2017-04-02T06:44:37.847Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统">
<meta name="twitter:description" content="操作系统">
<meta name="twitter:image" content="http://i.imgur.com/Md58ooA.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/03/21/操作系统/"/>





  <title> 操作系统 | Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/21/操作系统/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                操作系统
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-21T15:06:07+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>操作系统<br><a id="more"></a> </p>
<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h2 id="操作系统做了什么？"><a href="#操作系统做了什么？" class="headerlink" title="操作系统做了什么？"></a>操作系统做了什么？</h2><pre><code>#include &lt;stdio.h&gt; int main(int argc, char *argv[]) { 
puts(&quot;hello world&quot;); return 0; 
}
</code></pre><hr>
<pre><code>1. 用户告诉操作系统执行helloworld程序(如何告知？)  
2. 操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址（文件格式？）   
3. 操作系统：创建一个新的进程，并将helloworld可执行文件映射到该进程结构，表示由该进程执行helloworld程序  
4. 操作系统：为helloworld程序设置CPU上下文环境，并跳到程序开始处（假设调度程序选中hello程序）  
5. 执行helloworld程序的第一条指令，发生缺页异常  
6. 操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序   
7. helloworld程序执行puts函数（系统调用），在显示器上写一字符串   
8. 操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程  
9. 操作系统：控制设备的进程告诉设备的窗口系统它要显示字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区  
10. 视频硬件将像素转换成显示器可接收的一组控制/数据信号  
11. 显示器解释信号，激发液晶屏  
12. OK！！！我们在屏幕上看到了“hello world”
</code></pre><h3 id="从上述步骤中得到了什么"><a href="#从上述步骤中得到了什么" class="headerlink" title="从上述步骤中得到了什么"></a>从上述步骤中得到了什么</h3><p>os进程与用户程序的切换  </p>
<h3 id="换个角度看用户程序的执行"><a href="#换个角度看用户程序的执行" class="headerlink" title="换个角度看用户程序的执行"></a>换个角度看用户程序的执行</h3><h2 id="操作系统的定义与作用"><a href="#操作系统的定义与作用" class="headerlink" title="操作系统的定义与作用"></a>操作系统的定义与作用</h2><h3 id="操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——"><a href="#操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——" class="headerlink" title="操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——"></a>操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——</h3><ul>
<li>它们能以尽量有效、合理的方式组织和管理计算机的软硬件资源  </li>
<li>合理地组织计算机的工作 流程，控制程序的执行并向用户提供各种服务功能  </li>
<li><p>使得用户能够灵活、方便地使用计算机，使整个计算机系统高效率运行  </p>
<h3 id="几个关键词"><a href="#几个关键词" class="headerlink" title="几个关键词"></a>几个关键词</h3><p>  有效：系统效率，资源利用率</p>
<pre><code>CPU利用率充足与否？I/O设备是否忙碌？
</code></pre><p>  合理：</p>
<pre><code>各种软硬件资源的管理是否公平合理
如果不公平、不合理，则可能会产生问题？
</code></pre><p>  方便使用：</p>
<pre><code>两种角度：用户界面 与 编程接口
</code></pre><h3 id="三个作用"><a href="#三个作用" class="headerlink" title="三个作用"></a>三个作用</h3><h4 id="资源的管理者"><a href="#资源的管理者" class="headerlink" title="资源的管理者"></a>资源的管理者</h4><p>自底向上 硬件资源：软件资源：<br><strong>怎样管理资源</strong><br><pre><br>跟踪记录资源的使用状况，如：哪些资源空闲，分配给谁使用，允许使用多长时间等<br>确定资源分配策略——算法：静态分配策略，动态分配策略<br>实施资源的分配和回收<br>提高资源利用率<br>保护资源的使用<br>协调多个进程对资源请求的冲突<br></pre><br><strong>五大基本功能</strong>  </p>
<p>  进程/线程管理（CPU管理）</p>
<pre><code>进程线程状态、控制、同步互斥、通信、调度、……
</code></pre><p>  存储管理</p>
<pre><code>分配/回收、地址转换、存储保护、内存扩充、……
</code></pre><p>  文件管理</p>
<pre><code>文件目录、文件操作、磁盘空间、文件存取控制、……
</code></pre><p>  设备管理</p>
<pre><code>设备驱动、分配回收、缓冲技术、……
</code></pre><p>  用户接口</p>
<pre><code>系统命令、编程接口
</code></pre><h4 id="各种系统服务的提供者"><a href="#各种系统服务的提供者" class="headerlink" title="各种系统服务的提供者"></a>各种系统服务的提供者</h4><p>  在操作系统之上，从用户角度来看：</p>
<pre><code>操作系统为用户提供了一组功能强大、方便易用的命令或系统调用
</code></pre><p>  典型的服务</p>
<pre><code>进程的创建、执行；文件和目录的操作；I/O设备的使用；各类统计信息；……
</code></pre><h4 id="对硬件机器的扩展"><a href="#对硬件机器的扩展" class="headerlink" title="对硬件机器的扩展"></a>对硬件机器的扩展</h4><p>  操作系统在应用程序与硬件之间建立了一个等价的扩展机器（虚拟机）<br>  对硬件抽象，提高可移植性；比底层硬件更容易编程</p>
</li>
</ul>
<p>由面向底层变成了面向操作系统编程</p>
<h2 id="操作系统的主要特征"><a href="#操作系统的主要特征" class="headerlink" title="操作系统的主要特征"></a>操作系统的主要特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发(concurrency)：指处理多个同时性活动的能力  </p>
<pre><code>由于并发将会引发很多的问题：
    活动切换、保护、相互依赖的活动间的同步
在计算机系统中同时存在多个程序运行，单CPU上
    宏观上：这些程序同时在执行
    微观上：任何时刻只有一个程序真正在执行，即这些程序在CPU上是轮流执行的
并行(parallel)：与并发相似，但多指不同程序同时在多个硬件部件上执行
</code></pre><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><pre><code>共享(sharing)：
    操作系统与多个用户的程序共同使用计算机系统中的资源（共享有限的系统资源）
    操作系统要对系统资源进行合理分配和使用
    资源在一个时间段内交替被多个进程所用
互斥共享（如打印机）
同时共享（如可重入代码、磁盘文件）

问题：资源分配难以达到最优化，如何保护资源
</code></pre><h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>一个物理实体映射为若干个对应的逻辑实体－－分时或分空间<br>虚拟是操作系统管理系统资源的重要手段，可提高资源利用率  </p>
<pre><code>CPU－－每个进程的&quot;虚处理机&quot;
存储器－－每个进程都有独立的虚拟地址空间（代码＋数据＋堆栈）
显示设备－－多窗口或虚拟终端
</code></pre><h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>操作系统必须随时对以不可预测的次序发生的事件进行响应并处理</p>
<h2 id="典型操作系统的架构"><a href="#典型操作系统的架构" class="headerlink" title="典型操作系统的架构"></a>典型操作系统的架构</h2><h3 id="Windows架构"><a href="#Windows架构" class="headerlink" title="Windows架构"></a>Windows架构</h3><p>用户态：系统进程，服务进程，用户进程，环境子系统，动态链接库<br>内核态：系统服务分发器，内核态可调用接口，执行体，内核，设备驱动驱动程序，硬件抽象层，图形与窗口<br>物理硬件：硬件</p>
<h3 id="UNIX架构"><a href="#UNIX架构" class="headerlink" title="UNIX架构"></a>UNIX架构</h3><p>用户态：系统调用接口<br>内核态：进程控制子系统，文件系统，设备驱动程序（块设备，字符系统），硬件控制层，系统调用接口</p>
<h3 id="linux内核组间"><a href="#linux内核组间" class="headerlink" title="linux内核组间"></a>linux内核组间</h3><p>内核态：进程调度，文件系统，设备驱动程序，网络服务</p>
<h2 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h2><h3 id="操作系统的发展历程"><a href="#操作系统的发展历程" class="headerlink" title="操作系统的发展历程"></a>操作系统的发展历程</h3><p>操作系统发展是随着计算机硬件技术、应用需求的发展、软件新技术的出现而发展的</p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>充分利用硬件<br>提供更好的服务  </p>
<h3 id="传统操作系统的分类"><a href="#传统操作系统的分类" class="headerlink" title="传统操作系统的分类"></a>传统操作系统的分类</h3><p>批处理操作系统<br>分时系统<br>实时操作系统<br>个人计算机操作系统<br>网络操作系统<br>分布式操作系统<br>嵌入式操作系统  </p>
<h4 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h4><ol>
<li>用户将作业交给系统操作员  </li>
<li>系统操作员将许多用户的作业组成一批作业，输入到计算机系统中，在系统中形成一个自动转接的连续的作业流  </li>
<li>启动操作系统  </li>
<li>系统自动、依次执行每个作业  </li>
<li>由操作员将作业结果交给用户  </li>
</ol>
<hr>
<p>目标：提高资源利用率，增加作业处理吞吐量  </p>
<hr>
<pre><code>批处理系统中的作业包括： 
1. 用户程序  
2. 数据  
3. 作业说明书（用作业控制语言编写）
</code></pre><hr>
<p> 成批：通常由若干个作业组成，用户提交作业后只能等待处理结果，不能干预自己作业的执行</p>
<hr>
<p>批作业处理：<br>对一批作业中的每个作业进行相同的处理：从磁带读入用户作业和编译链接程序，编译链接用户作业以生成可执行程序；启动执行；执行并输出结果  </p>
<hr>
<pre><code>问题：慢速的输入输出处理直接由主机来完成，输入输出时，CPU处于等待状态  
解决方案：卫星机：完成面向用户的输入输出（纸带或卡片），中间结果暂存在磁带或磁盘上
</code></pre><hr>
<pre><code>SPOOLING系統（技術）  
利用磁盘作缓冲，将输入、计算、输出分别组织成独立的任务流，使I/O和计算真正并行  
工作原理：  
用户作业加载到磁盘上的输入井
按某种调度策略选择几个搭配得当的作业，调入内存
作业运行的结果输出到磁盘上的输出井
运行结果从磁盘上的输出井送到打印机 
</code></pre><h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><pre><code>操作系统将CPU的时间划分成若干个片段，称为时间片
    操作系统以时间片为单位，轮流为每个终端用户服务，每次服务一个时间片
    其特点是利用人的错觉，使用户感觉不到计算机在服务他人
</code></pre><hr>
<pre><code>追求目标：
    及时响应(依据是响应时间)
响应时间：
    从终端发出命令到系统给予回答所经历的时间
</code></pre><h4 id="通过操作系统"><a href="#通过操作系统" class="headerlink" title="通过操作系统"></a>通过操作系统</h4><p>分时系统与批处理系统结合  </p>
<hr>
<pre><code>原则：分时优先，批处理在后
“前台”：需要频繁交互的作业
“后台”：时间性要求不强的作业
</code></pre><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>是指使计算机能及时响应外部事件的请求，在规定的严格时间内完成对该事件的处理，并控制所有实时设备和实时任务协调一致地工作</p>
<hr>
<pre><code>分类：
    第一类：实时过程控制
        工业控制、航空、军事控制、...
    第二类：实时通信（信息）处理
        电讯（自动交换机）、银行、飞机订票、股市行情
</code></pre><hr>
<pre><code>追求目标：
    对外部请求在严格时间范围内作出响应
    高可靠性
</code></pre><hr>
<p>硬实时系统<br>软实时系统</p>
<h4 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h4><p>计算机在某一时间内为单用户服务</p>
<hr>
<pre><code>追求目标：
    界面友好，使用方便
    丰富的应用软件
</code></pre><h4 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h4><pre><code>基于计算机网络
    在各种计算机操作系统上
        按网络体系结构协议标准开发的软件
功能：
    网络管理，通信，安全，资源共享和各种网络应用
追求目标：相互通信，资源共享
</code></pre><h4 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h4><pre><code>分布式系统：或以计算机网络为基础，或以多处理机为基础，基本特征是处理分布在不同计算机上

分布式操作系统：是一个统一的操作系统，允许若干个计算机可相互协作共同完成一项任务。操作系统可将各种系统任务在分布式系统中任何处理机上运行，自动实现全系统范围内的任务分配、自动调度、均衡各处理机的工作负载

处理能力增强、速度更快、可靠性增强、具有透明性
</code></pre><h4 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h4><pre><code>嵌入式系统
    在各种设备、装置或系统中，完成特定功能的软硬件系统汽车、手机、电视机、MP3播放器
    它们是一个大设备、装置或系统中的一部分，这个大设备、装置或系统可以不是“计算机”
    通常工作在反应式或对处理时间有较严格要求环境中

嵌入式操作系统（Embedded Operating System）
    运行在嵌入式系统环境中，对整个嵌入式系统以及它所操作、控制的各种部件装置等等资源进行统一协调、调度、指挥和控制的系统软件
</code></pre><h4 id="智能卡操作系统"><a href="#智能卡操作系统" class="headerlink" title="智能卡操作系统"></a>智能卡操作系统</h4><pre><code>智能卡：一种包含有一块CPU芯片的卡片
特点
    非常严格的运行能耗和存储空间的限制
    有些智能卡只有单项功能，诸如电子支付
专用的操作系统  

有些智能卡是面向Java的，即在智能卡的ROM中有一个Java虚拟机解释器。Java 程序被下载到卡中并由JVM解释器解释。有些卡可以同时处理多个Java 小程序，这就是多道程序，并且需要对它们进行调度。在两个或多个小程序同时运行时，资源管理和保护就成为突出的问题。这些问题必须由卡上的操作系统处理
</code></pre><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><pre><code>重点阅读教材
    第1章相关内容：1.1、1.2、1.4
    第10章相关内容：10.2.5
    第11章相关内容：11.3.1.

重点概念
    操作系统定义 操作系统的三个作用
    并发 共享 虚拟 随机 SPOOLing技术 Windows、Linux、UNIX的架构
</code></pre><h1 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h1><h2 id="处理器状态"><a href="#处理器状态" class="headerlink" title="处理器状态"></a>处理器状态</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>处理器由运算器、控制器、一系列的寄存器以及高速缓存构成  </p>
<pre><code>两类寄存器：
    用户可见寄存器：高级语言编译器通过优化算法分配并使用之，以减少程序访问内存次数
    控制和状态寄存器：用于控制处理器的操作
                        通常由操作系统代码使用
</code></pre><h4 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h4><p>用于控制处理器的操作<br>在某种特权级别下可以访问、修改  </p>
<pre><code>常见的控制和状态寄存器
    程序计数器（PC：Program Counter），记录将要取出的指令的地址
    指令寄存器（IR：Instruction Register），记录最近取出的指令
    程序状态字（PSW：Program Status Word），记录处理器的运行状态如条件码、模式、控制位等信息
</code></pre><h3 id="操作系统的需求，保护"><a href="#操作系统的需求，保护" class="headerlink" title="操作系统的需求，保护"></a>操作系统的需求，保护</h3><p>从操作系统的特征考虑<br>并发、共享<br>提出要求 → 实现保护与控制  </p>
<pre><code>需要硬件提供基本运行机制：
    处理器具有特权级别，能在不同的特权级运行的不同指令集合
     硬件机制可将OS与用户程序隔离
</code></pre><h3 id="处理器的状态"><a href="#处理器的状态" class="headerlink" title="处理器的状态"></a>处理器的状态</h3><p>现代处理器通常将CPU状态设计划分为两种、三种或四种<br>在程序状态字寄存器PSW中专门设置一位，根据运行程序对资源和指令的使用权限而设置不同的CPU状态  </p>
<h3 id="特权指令和非特权指令"><a href="#特权指令和非特权指令" class="headerlink" title="特权指令和非特权指令"></a>特权指令和非特权指令</h3><pre><code>操作系统需要两种CPU状态
    内核态(Kernel Mode)：运行操作系统程序
    用户态(User Mode)：运行用户程序
</code></pre><hr>
<p>特权(privilege)指令：只能由操作系统使用、用户程序不能使用的指令<br>非特权指令：用户程序可以使用的指令</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>X86支持4个处理器特权级别<br>特权环：R0、R1、R2和R3  </p>
<pre><code>从R0到R3，特权能力由高到低
    R0相当于内核态；R3相当于用户态；R1和R2则介于两者之间
    不同级别能够运行的指令集合不同
</code></pre><p>目前大多数基于x86处理器的操作系统<br>只用了R0和R3两个特权级别</p>
<h3 id="CPU状态之间的转换"><a href="#CPU状态之间的转换" class="headerlink" title="CPU状态之间的转换"></a>CPU状态之间的转换</h3><pre><code>用户态 → 内核态
    唯一途径 → 中断/异常/陷入机制
内核态 → 用户态
    设置程序状态字PSW
</code></pre><hr>
<pre><code>一条特殊的指令：陷入指令（又称访管指令）
    提供给用户程序的接口，用于调用操作系统的功能（服务）
    例如：int，trap，syscall，sysenter/sysexit
</code></pre><h2 id="中断和异常机制"><a href="#中断和异常机制" class="headerlink" title="中断和异常机制"></a>中断和异常机制</h2><pre><code>中断/异常 对于操作系统的重要性
    就好比：汽车的发动机、飞机的引擎
→→ 可以说 操作系统
    是由“中断驱动”或者 “事件驱动”的
</code></pre><hr>
<pre><code>主要作用
    及时处理设备发来的中断请求
    可使OS捕获用户程序提出的服务请求
    防止用户程序执行过程中的破坏性活动
    … … 等等
</code></pre><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>CPU对系统发生的某个事件作出的一种反应<br>CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序  </p>
<pre><code>特点：
•是随机发生的
•是自动处理的
•是可恢复的

事件的发生改变了处理器的控制流
</code></pre><h3 id="为什么引入中断与异常"><a href="#为什么引入中断与异常" class="headerlink" title="为什么引入中断与异常"></a>为什么引入中断与异常</h3><pre><code>中断的引入：为了支持CPU和设备之间的并行操作
    当CPU启动设备进行输入/输出后，设备便可以独立工作，CPU转去处理与此次输入/输出不相关的事情；
    当设备完成输入/输出后，通过向CPU发中断报告此次输入/输出的结果，让CPU决定如何处理以后的事情

异常的引入：表示CPU执行指令时本身出现的问题
    如算术溢出、除零、取数时的奇偶错，访存地址时越界或执行了“陷入指令” 等，
    这时硬件改变了CPU当前的执行流程，转到相应的错误处理程序或异常处理程序或执行系统调用
</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>中断：外部事件，正在运行的程序所不期望的<br>异常：由正在执行的指令引发  </p>
<pre><code>中断(外中断)
    I/O中断
    时钟中断
    硬件故障

异常(内中断)
    系统调用
    页故障/页错误
    保护性异常
    断点指令
    其他程序性异常
    (如算术溢出等)
</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><pre><code>类别        原因                        异步/同步        返回行为
中断
Interrupt    来自I/O设备、其他硬件部件    异步            总是返回到下一条指令
陷入Trap    有意识安排的                  同步            返回到下一条指令

故障Fault    可恢复的错误                  同步            返回到当前指令

终止Abort    不可恢复的错误                 同步            不会返回
</code></pre><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>中断/异常机制是现代计算机系统的核心机制之一<br>硬件和软件相互配合而使计算机系统得以充分发挥能力</p>
<hr>
<pre><code>硬件该做什么事？ —— 中断/异常响应
    捕获中断源发出的中断/异常请求，以一定方式响应，将处理器控制权交给特定的处理程序
软件要做什么事？ —— 中断/异常处理程序
    识别中断/异常类型并完成相应的处理
</code></pre><h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><pre><code>中断响应：
     发现中断、接收中断的过程
     由中断硬件部件完成
</code></pre><h4 id="过程示意"><a href="#过程示意" class="headerlink" title="过程示意"></a>过程示意</h4><p>开始-&gt;取下一条指令-&gt;执行指令-&gt;检查指令-&gt;处理中断</p>
<hr>
<pre><code>在每条指令执行周期的最后时刻扫描中断寄存器，查看是否有中断信号？
若有中断，中断硬件将该中断触发器内容按规定编码送入PSW的相应位，称为中断码，通过查中断向量表引出中断处理程序
若无中断信号，继续执行下一条指令
</code></pre><h4 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h4><pre><code>中断向量：
    一个内存单元，存放中断处理程序入口地址和程序运行时所需的处理机状态字
</code></pre><hr>
<p>执行流程按中断号/异常类型的不同，通过中断向量表<br>转移控制权给中断处理程序<br>中断向量表<br>中断处理程序</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><pre><code>1. 设备发中断信号
2. 硬件保存现场
3. 根据中断码查表
4. 把中断处理程序入口地址等推送到相应的寄存器
5. 执行中断处理程序
</code></pre><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>设计操作系统时，为每一类中断/异常事件编好相应的处理程序，并设置好中断向量表  </p>
<pre><code>系统运行时若响应中断，中断硬件部件将CPU控制权转给中断处理程序：
    保存相关寄存器信息
    分析中断/异常的具体原因
    执行对应的处理功能
    恢复现场，返回被事件打断的程序
</code></pre><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><pre><code>以设备输入输出中断为例： 
    打印机给CPU发中断信号
    CPU处理完当前指令后检测到中断，判断出中断来源并向相关设备发确认信号

    CPU开始为软件处理中断做准备：
        处理器状态被切换到内核态
        在系统栈中保存被中断程序的重要上下文环境，主要是程序计数器PC、程序状态字PSW

    PU根据中断码查中断向量表，获得与该中断相关的处理程序的入口地址，并将PC设置成该地址，新的指令周期开始时，CPU控制转移到中断处理程序

    中断处理程序开始工作
        在系统栈中保存现场信息
        检查I/O设备的状态信息，操纵I/O设备或者在设备和内存之间传送数据等等

    中断处理结束时，CPU检测到中断返回指令，从系统栈中恢复被中断程序的上下文环境 ，CPU状态恢复成原来的状态，PSW和PC恢复成中断前的值，CPU开始一个新的指令周期
</code></pre><hr>
<pre><code>I/O中断处理程序
通常分为两类处理：

    I/O操作正常结束
        若有程序正等待此次I/O的结果，则应将其唤醒
        若要继续I/O操作，需要准备好数据重新启动I/O

    I/O操作出现错误
        需要重新执行失败的I/O操作
        重试次数有上限，达到时系统将判定硬件故障
</code></pre><h2 id="实例：x86处理器"><a href="#实例：x86处理器" class="headerlink" title="实例：x86处理器"></a>实例：x86处理器</h2><pre><code>中断
    由硬件信号引发的，分为可屏蔽和不可屏蔽中断
异常
    由指令执行引发的，比如除零异常
    80x86处理器发布了大约20种不同的异常
    对于某些异常，CPU会在执行异常处理程序之前产生硬件出错码，并压入内核态堆栈
系统调用
    异常的一种，用户态到内核态的唯一入口
</code></pre><h2 id="x86处理器对中断的支持"><a href="#x86处理器对中断的支持" class="headerlink" title="x86处理器对中断的支持"></a>x86处理器对中断的支持</h2><pre><code>中断控制器（PIC或APIC）
    负责将硬件的中断信号转换为中断向量，并引发CPU中断

实模式：中断向量表 (Interrupt Vector)
    存放中断服务程序的入口地址
        入口地址＝段地址左移4位＋偏移地址
        不支持CPU运行状态切换
        中断处理与一般的过程调用相似

保护模式：中断描述符表 (Interrupt Descriptor Table)
    采用门(gate) 描述符数据结构表示中断向量
</code></pre><hr>
<pre><code>中断向量表/中断描述符表
    四种类型门描述符
        任务门(Task Gate)
        中断门(Interrupt Gate)
            给出段选择符 (Segment Selector)、中断/异常程序的段内偏移量 (Offset)
            通过中断门后系统会自动禁止中断
        陷阱门(Trap Gate)
            与中断门类似，但通过陷阱门后系统不会自动禁止中断
        调用门(Call Gate)
</code></pre><hr>
<pre><code>中断/异常的硬件处理过程：
    确定与中断或异常关联的向量i
    通过IDTR寄存器找到IDT表，获得中断描述符（表中的第i项）
    从GDTR寄存器获得GDT的地址；结合中断描述符中的段选择符，在GDT表获取对应的段描述符；从该段描述符中得到中断或异常处理程序所在的段基址
    特权级检查
</code></pre><hr>
<pre><code>检查是否发生了特权级的变化，如果是，则进行堆栈切换(必须使用与新的特权级相关的栈)
硬件压栈，保存上下文环境；如果异常产生了硬件出错码，也将它保存在栈中
如果是中断，清IF位
通过中断描述符中的段内偏移量和段描述符中的基地址，找到中断/异常处理程序的入口地址，执行其第一条指令
</code></pre><h2 id="系统调用机制"><a href="#系统调用机制" class="headerlink" title="系统调用机制"></a>系统调用机制</h2><pre><code>系统调用：用户在编程时可以调用的操作系统功能
</code></pre><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><pre><code>系统调用是操作系统提供给编程人员的唯一接口
使CPU状态从用户态陷入内核态
</code></pre><h3 id="典型系统调用"><a href="#典型系统调用" class="headerlink" title="典型系统调用"></a>典型系统调用</h3><pre><code>每个操作系统都提供几百种系统调用（进程控制、进程通信、文件使用、目录操作、设备管理、信息维护等）
</code></pre><h3 id="系统调用机制的设计"><a href="#系统调用机制的设计" class="headerlink" title="系统调用机制的设计"></a>系统调用机制的设计</h3><pre><code>中断/异常机制
    支持系统调用服务的实现
选择一条特殊指令：陷入指令(亦称访管指令)
    引发异常，完成用户态到内核态的切换
系统调用号和参数 
    每个系统调用都事先给定一个编号(功能号)
    编译器也会参与
系统调用表
    存放系统调用服务例程的入口地址
</code></pre><h3 id="参数传递过程问题"><a href="#参数传递过程问题" class="headerlink" title="参数传递过程问题"></a>参数传递过程问题</h3><pre><code>怎样实现用户程序的参数传递给内核？

常用的3种实现方法：
    由陷入指令自带参数：陷入指令的长度有限，且还要携带系统调用功
    能号，只能自带有限的参数
    通过通用寄存器传递参数：这些寄存器是操作系统和用户程序都能访
    问的，但寄存器的个数会限制传递参数的数量
    在内存中开辟专用堆栈区来传递参数
</code></pre><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><pre><code>当CPU执行到特殊的陷入指令时：  
    中断/异常机制：硬件保护现场；通过查中断向量表把控制权转给系统调用总入口程序
    系统调用总入口程序：保存现场；将参数保存在内核堆栈里；通过查系统调用表把控制权转给相应的系统调用处理例程或内核函数
    执行系统调用例程
    恢复现场，返回用户程序
</code></pre><h2 id="基于x86处理器的linux的系统调用实现"><a href="#基于x86处理器的linux的系统调用实现" class="headerlink" title="基于x86处理器的linux的系统调用实现"></a>基于x86处理器的linux的系统调用实现</h2><pre><code>陷入指令选择128号
    int $0x80
</code></pre><hr>
<pre><code>门描述符
    系统初始化时：对IDT表中的128号门初始化
    门描述符的2、3两个字节：内核代码段选择符
    0、1、6、7四个字节：偏移量（指向system_call()）
    门类型：15，陷阱门，为什么？执行系统调用的过程中，还接收中断
    DPL：3，与用户级别相同，允许用户进程使用该门描述符
</code></pre><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><pre><code>由于特权级的改变，要切换栈
    用户栈 → 内核栈
    CPU从任务状态段TSS中装入新的栈指针（SS︰ESP），指向内核栈

内核栈
    用户栈的信息（SS︰ESP）、EFLAGS、用户态CS 、EIP 寄存器的内容压栈（返回用）
    将EFLAGS压栈后，复位TF，IF位保持不变
    用128在IDT中找到该门描述符，从中找出段选择符装入代码段寄存器CS
    代码段描述符中的基地址 + 陷阱门描述符中的偏移量 → 定位 system_call()的入口地址
</code></pre><h3 id="调用执行流程"><a href="#调用执行流程" class="headerlink" title="调用执行流程"></a>调用执行流程</h3><p>应用程序-&gt;封装例程-&gt;陷入处理-&gt;内核函数-&gt;</p>
<h3 id="OS底层工作步骤"><a href="#OS底层工作步骤" class="headerlink" title="OS底层工作步骤"></a>OS底层工作步骤</h3><pre><code>1. 硬件压栈：程序计数器等
2. 硬件从中断向量装入新的程序计数器等
3. 汇编语言过程保存寄存器值
4. 汇编语言过程设置新的堆栈
5. C语言中断服务程序运行（例：读并缓冲输入）
6. 进程调度程序决定下一个将运行的进程
7. C语言过程返回至汇编代码
8. 汇编语言过程开始运行新的当前进程
</code></pre><h2 id="重点-1"><a href="#重点-1" class="headerlink" title="重点"></a>重点</h2><pre><code>理解计算机系统的保护机制
    掌握处理器状态
    掌握特权指令与非特权指令
掌握中断/异常机制
    掌握中断/异常的基本概念
    理解中断/异常机制的工作原理
掌握系统调用机制
    掌握系统调用设计原理
    掌握系统调用执行过程
</code></pre><hr>
<pre><code>重点阅读教材
    第1章相关内容：1.3、1.6
    第2章 第52页 图2-5及说明该图思路的段落
重点概念
    CPU状态 内核态/用户态 特权指令/非特权指令
    中断 异常 中断响应 中断向量 中断处理程序
    系统调用 陷入指令 系统调用号 系统调用表
</code></pre><h1 id="进程-线程模型"><a href="#进程-线程模型" class="headerlink" title="进程/线程模型"></a>进程/线程模型</h1><h2 id="进程基本概念"><a href="#进程基本概念" class="headerlink" title="进程基本概念"></a>进程基本概念</h2><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><pre><code>多道程序设计
    允许多个程序同时进入内存并运行，其目的是为了提高系统效率
</code></pre><h3 id="并发环境与并发程序"><a href="#并发环境与并发程序" class="headerlink" title="并发环境与并发程序"></a>并发环境与并发程序</h3><pre><code>并发环境：
        一段时间间隔内，单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态，并且次序不是事先确定的

并发程序：在并发环境中执行的程序
</code></pre><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><pre><code>定义：Process
    进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位
又称 任务（Task or Job）
</code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre><code>程序的一次执行过程
是正在运行程序的抽象
将一个CPU变幻成多个虚拟的CPU
系统资源以进程为单位分配，如内存、文件、……
    每个具有独立的地址空间
操作系统将CPU调度给需要的进程
</code></pre><h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><pre><code>PCB：Process Control Block
    又称 进程描述符、进程属性
    操作系统用于管理控制进程的一个专门数据结构
    记录进程的各种属性，描述进程的动态变化过程

PCB是系统感知进程存在的唯一标志
    → 进程与PCB是一一对应的

进程表：所有进程的PCB集合
</code></pre><hr>
<pre><code>进程描述信息
    进程标识符(process ID)，唯一，通常是一个整数
    进程名，通常基于可执行文件名，不唯一
    用户标识符(user ID)
    进程组关系

当前状态
    优先级(priority)
    代码执行入口地址
    程序的磁盘地址
    运行统计信息(执行时间、页面调度)
    进程间同步和通信
    进程的队列指针
    进程的消息队列指针

所拥有的资源和使用情况
    虚拟地址空间的状况
    打开文件列表

CPU现场信息
    寄存器值(通用寄存器、程序计数器PC、程序状态字PSW、栈指针)
    指向该进程页表的指针
</code></pre><hr>
<p>Linux：task_struct<br>Windows：EPROCESS、KPROCESS、PEB  </p>
<h4 id="Linux：task-struct"><a href="#Linux：task-struct" class="headerlink" title="Linux：task_struct"></a>Linux：task_struct</h4><p>非常之多</p>
<h2 id="进程状态及状态转换"><a href="#进程状态及状态转换" class="headerlink" title="进程状态及状态转换"></a>进程状态及状态转换</h2><h3 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h3><pre><code>进程的三种基本状态：
运行态、就绪态、等待态

运行态（Running）
    占有CPU，并在CPU上运行
就绪态（Ready）
    已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
等待态（Waiting/Blocked）阻塞态、封锁态、睡眠态
    因等待某一事件而暂时不能运行
</code></pre><h3 id="三状态模型以及状态转换"><a href="#三状态模型以及状态转换" class="headerlink" title="三状态模型以及状态转换"></a>三状态模型以及状态转换</h3><pre><code>就绪 → 运行
    调度程序选择一个新的进程运行

运行 → 就绪
    运行进程用完了时间片
    一个高优先级进程进入就绪状态，抢占正在运行的进程

运行 → 等待
    当一个进程等待某个事件发生时
        请求OS服务
        对资源的访问尚不能进行
        等待I/O结果
        等待另一进程提供信息

等待 → 就绪
    所等待的事件发生了
</code></pre><h3 id="其他状态"><a href="#其他状态" class="headerlink" title="其他状态"></a>其他状态</h3><pre><code>创建
    已完成创建一进程所必要的工作
        –PID、PCB
    但尚未同意执行该进程
        –因为资源有限

终止
    终止执行后，进程进入该状态
    可完成一些数据统计工作
    资源回收

挂起
    用于调节负载
    进程不占用内存空间，其进程映像交换到磁盘上
</code></pre><h3 id="五状态进程模型"><a href="#五状态进程模型" class="headerlink" title="五状态进程模型"></a>五状态进程模型</h3><p><img src="http://i.imgur.com/Md58ooA.jpg" alt=""></p>
<h3 id="七状态进程模型"><a href="#七状态进程模型" class="headerlink" title="七状态进程模型"></a>七状态进程模型</h3><p>添加了就绪挂起和阻塞挂起<br><img src="http://i.imgur.com/QtK5q30.jpg" alt=""></p>
<h3 id="linux状态示意图"><a href="#linux状态示意图" class="headerlink" title="linux状态示意图"></a>linux状态示意图</h3><p><img src="http://i.imgur.com/zfUhtic.jpg" alt=""></p>
<h3 id="进程队列"><a href="#进程队列" class="headerlink" title="进程队列"></a>进程队列</h3><p>操作系统为每一类进程建立一个或多个队列<br>队列元素为PCB<br>伴随进程状态的改变，其PCB从一个队列进入另一个队列<br><img src="http://i.imgur.com/XZeZzlY.jpg" alt=""></p>
<h3 id="五状态进程的队列模型"><a href="#五状态进程的队列模型" class="headerlink" title="五状态进程的队列模型"></a>五状态进程的队列模型</h3><p><img src="http://i.imgur.com/SdcJiLx.jpg" alt=""></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><pre><code>进程控制操作完成进程各状态之间的转换，由具有特定功能的原语完成
    进程创建原语
    进程撤消原语
    阻塞原语
    唤醒原语
    挂起原语
    激活原语
    改变进程优先级
</code></pre><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><pre><code>给新进程分配一个唯一标识以及进程控制块
为进程分配地址空间
初始化进程控制块
设置默认值 (如: 状态为 New，...)
设置相应的队列指针
    如: 把新进程加到就绪队列链表中
</code></pre><h3 id="进程的撤销"><a href="#进程的撤销" class="headerlink" title="进程的撤销"></a>进程的撤销</h3><pre><code>结束进程
    收回进程所占有的资源
    关闭打开的文件、断开网络连接、回收分配的内存、……
    撤消该进程的PCB
</code></pre><h3 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h3><pre><code>处于运行状态的进程，在其运行过程中期待某一事件发生，如等待键盘输入、等待磁盘数据传输完成、等待其它进程发送消息，当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态
</code></pre><h3 id="Unix的几个进程控制操作"><a href="#Unix的几个进程控制操作" class="headerlink" title="Unix的几个进程控制操作"></a>Unix的几个进程控制操作</h3><pre><code>fork() 通过复制调用进程来建立新的进程，是最基本的进程建立过程

exec() 包括一系列系统调用，它们都是通过用一段新的程序代码覆盖原来的地址空间，实现进程执行代码的转换

wait() 提供初级进程同步操作，能使一个进程等待另外一个进程的结束

exit() 用来终止一个进程的运行
</code></pre><h4 id="Unix的FORK-的实现"><a href="#Unix的FORK-的实现" class="headerlink" title="Unix的FORK()的实现"></a>Unix的FORK()的实现</h4><pre><code>为子进程分配一个空闲的进程描述符
    proc 结构
分配给子进程唯一标识 pid
以一次一页的方式复制父进程地址空间？
从父进程处继承共享资源，如打开的文件和当前工作目录等
将子进程的状态设为就绪，插入到就绪队列
对子进程返回标识符 0
向父进程返回子进程的 pid
</code></pre><p>Linux使用了写时复制技术COW加快创建进程Copy-On-Write</p>
<p>示例方法</p>
<pre><code>#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
void main(int argc, char *argv[])
{
    pid_t pid;
    pid = fork(); /* 创建一个子进程 */
    if (pid &lt; 0) { /* 出错 */
        fprintf(stderr, “fork failed”);
        exit(-1); }
    else if (pid == 0) { /* 子进程 */
        execlp(“/bin/ls”, “ls”, NULL); }
    else { /* 父进程 */
        wait(NULL); /* 父进程等待子进程结束 */
        printf(“child complete”);
        exit(0);
}
}
</code></pre><h2 id="深入理解进程概念"><a href="#深入理解进程概念" class="headerlink" title="深入理解进程概念"></a>深入理解进程概念</h2><h3 id="关于进程的讨论"><a href="#关于进程的讨论" class="headerlink" title="关于进程的讨论"></a>关于进程的讨论</h3><p><img src="http://i.imgur.com/cS7YiDl.jpg" alt=""></p>
<h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><pre><code>进程更能准确刻画并发，而程序不能
程序是静态的，进程是动态的
进程有生命周期的，有诞生有消亡，是短暂的；而程序是相对长久的
一个程序可对应多个进程
进程具有创建其他进程的功能
</code></pre><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><p>操作系统给每个进程都分配了一个地址空间</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>int myval;
int main(int argc, char *argv[])
{
myval = atoi(argv[1]);
while (1)
    printf(“myval is %d, loc 0x%lx\n”,
        myval, (long) &amp;myval);
}
</code></pre><p><strong>输出结果</strong><br><img src="http://i.imgur.com/2ejIZu1.jpg" alt=""></p>
<h4 id="进程地址空间图示"><a href="#进程地址空间图示" class="headerlink" title="进程地址空间图示"></a>进程地址空间图示</h4><p><img src="http://i.imgur.com/6iYnFgF.jpg" alt=""></p>
<h3 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h3><pre><code>对进程执行活动全过程的静态描述
    由进程地址空间内容、硬件寄存器内容及与该进程相关的内核数据结构、内核栈组成

用户相关：进程地址空间（包括代码段、数据段、堆和栈、共享库……）
寄存器相关：程序计数器、指令寄存器、程序状态寄存器、栈指针、通用寄存器等的值
内核相关：
    静态部分：PCB及各种资源数据结构
    动态部分：内核栈（不同进程在进入内核后使用不同的内核栈）
</code></pre><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><pre><code>将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换

进程运行时，其硬件状态保存在CPU上的寄存器中
寄存器：程序计数器、程序状态寄存器、栈指针、通用寄存器、其他控制寄存器的值

进程不运行时，这些寄存器的值保存在进程控制块PCB中；当操作系统要运行一个新的进程时，将PCB中的相关值送到对应的寄存器中
</code></pre><h2 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h2><h3 id="为什么在进程中再派生线程？"><a href="#为什么在进程中再派生线程？" class="headerlink" title="为什么在进程中再派生线程？"></a>为什么在进程中再派生线程？</h3><pre><code>三个理由
    应用的需要
    开销的考虑
    性能的考虑
</code></pre><h3 id="典型的应用"><a href="#典型的应用" class="headerlink" title="典型的应用"></a>典型的应用</h3><pre><code>Web服务器
工作方式
    从客户端接收网页请求（http协议）
    从磁盘上检索相关网页，读入内存
    将网页返回给对应的客户端
如何提高服务器工作效率？
    网页缓存（Web page Cache）
</code></pre><h4 id="如果没有线程"><a href="#如果没有线程" class="headerlink" title="如果没有线程"></a>如果没有线程</h4><pre><code>两种解决方案：
    一个服务进程
        顺序编程；性能下降
    有限状态机
        编程模型复杂；采用非阻塞I/O
</code></pre><h4 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h4><h4 id="开销的考虑"><a href="#开销的考虑" class="headerlink" title="开销的考虑"></a>开销的考虑</h4><pre><code>进程相关的操作：
    创建进程
    撤消进程
    进程通信
    进程切换
→ 时间/空间开销大，限制了并发度的提高
</code></pre><hr>
<pre><code>线程的开销小
    创建一个新线程花费时间少（撤销亦如此）
    两个线程切换花费时间少
    线程之间相互通信无须调用内核（同一进程内的线程共享内存和文件）
</code></pre><hr>
<pre><code>多个线程，有的计算，有的I/O
    多个处理器
</code></pre><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h4><p>线程继承了进程的属性<br>线程：进程中的一个运行实体，是CPU的调度单位 有时将线程称为轻量级进程<br>在同一进程增加了多个执行序列（线程）</p>
<h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><pre><code>线程：
    有标示符ID
    有状态及状态转换 → 需要提供一些操作
    不运行时需要保存的上下文
        有上下文环境：程序计数器等寄存器
    有自己的栈和栈指针 

    共享所在进程的地址空间和其他资源

    可以创建、撤消另一个线程
        程序开始是以一个单线程进程方式运行的
</code></pre><h2 id="线程机制的实现"><a href="#线程机制的实现" class="headerlink" title="线程机制的实现"></a>线程机制的实现</h2><pre><code>用户级线程
核心级线程
混合—两者结合方法
</code></pre><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><pre><code>在用户空间建立线程库：提供一组管理线程的过程
运行时系统：完成线程的管理工作（操作、线程表）
内核管理的还是进程，不知道线程的存在
线程切换不需要内核态特权
例子：UNIX
</code></pre><h4 id="POSIX线程库"><a href="#POSIX线程库" class="headerlink" title="POSIX线程库"></a>POSIX线程库</h4><p><img src="http://i.imgur.com/0OmstJz.jpg" alt=""></p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><pre><code>优点：
    线程切换快
    调度算法是应用程序特定的
    用户级线程可运行在任何操作系统上（只需要实现线程库）
缺点：
    内核只将处理器分配给进程，同一进程中的两个线程不能同时运行于两个处理器上
    大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中所有线程也被阻塞（如何改变？）
</code></pre><h3 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h3><pre><code>内核管理所有线程管理，并向应用程序提供API接口
内核维护进程和线程的上下文
线程的切换需要内核支持
以线程为基础进行调度
例子：Windows
</code></pre><h3 id="混合模型"><a href="#混合模型" class="headerlink" title="混合模型"></a>混合模型</h3><pre><code>线程创建在用户空间完成
线程调度等在核心态完成
</code></pre><h2 id="重点小结"><a href="#重点小结" class="headerlink" title="重点小结"></a>重点小结</h2><pre><code>并发性 任何进程都可以与其他进程一起向前推进
动态性 进程是正在执行程序的实例
    进程是动态产生，动态消亡的
    进程在其生命周期内，在三种基本状态之间转换
独立性 
    进程是资源分配的一个独立单位 例如：各进程的地址空间相互独立
交互性 
    指进程在执行过程中可能与其他进程产生直接或间接的关系
异步性 
    每个进程都以其相对独立的、不可预知的速度向前推进
进程映像 
    程序 + 数据 + 栈(用户栈、内核栈) + PCB
</code></pre><hr>
<pre><code>线程
    多线程应用场景
    线程基本概念、属性
    线程实现机制

可再入程序（可重入）：
    可被多个进程同时调用的程序，具有下列性质：
    它是纯代码的，即在执行过程中自身不改变；调用它的进程应该提供数据区
</code></pre><hr>
<pre><code>重点阅读教材
第2章相关内容：2.1、2.2(除2.2.8-2.2.10外)
</code></pre><h1 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是处理器调度"><a href="#什么是处理器调度" class="headerlink" title="什么是处理器调度"></a>什么是处理器调度</h3><pre><code>CPU调度
    —— 其任务是控制、协调进程对CPU的竞争
    即按一定的调度算法从就绪队列中选择一个进程，把CPU的使用权交给被选中的进程
    如果没有就绪进程，系统会安排一个系统空闲进程或idle进程
</code></pre><hr>
<pre><code>系统场景
    N个进程就绪、等待上CPU运行
    M个CPU，M ≥ 1
    需要决策：给哪一个进程分配哪一个CPU？
</code></pre><h3 id="要解决的三个问题"><a href="#要解决的三个问题" class="headerlink" title="要解决的三个问题"></a>要解决的三个问题</h3><pre><code>WHAT：按什么原则选择下一个要执行的进程
    — 调度算法

WHEN：何时选择
    — 调度时机

HOW： 如何让被选中的进程上CPU运行
    — 调度过程（进程的上下文切换）
</code></pre><h3 id="调度的时机"><a href="#调度的时机" class="headerlink" title="调度的时机"></a>调度的时机</h3><pre><code>事件发生 → 当前运行的进程暂停运行 → 硬件机制响应后 → 进入操作系统，处理相应的事件 → 结束处理后：
某些进程的状态会发生变化，也可能又创建了一些新的进程
→ 就绪队列有调整 → 需要进程调度根据预设的调度算法从就绪队列选一个进程
</code></pre><hr>
<pre><code>典型的事件举例：
创建、唤醒、退出等进程控制操作
进程等待I/O、I/O中断
时钟中断，如：时间片用完、计时器到时
进程执行过程中出现abort异常
</code></pre><hr>
<h4 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h4><pre><code>进程正常终止 或 由于某种错误而终止
新进程创建 或 一个等待进程变成就绪
当一个进程从运行态进入阻塞态
当一个进程从运行态变为就绪态
</code></pre><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><pre><code>进程调度程序从就绪队列选择了要运行的进程：
    这个进程可以是刚刚被暂停执行的进程，也可能是另一个新的进程
进程切换
    进程切换：是指一个进程让出处理器，由另一个进程占用处理器的过程
</code></pre><hr>
<pre><code>进程切换主要包括两部分工作：
    切换全局页目录以加载一个新的地址空间
    切换内核栈和硬件上下文，其中硬件上下文包括了内核执行新进程需要的全部信息，如CPU相关寄存器

切换过程包括了对原来运行进程各种状态的保存和对新的进程各种状态的恢复
</code></pre><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><p>场景：进程A下CPU，进程B上CPU  </p>
<pre><code>保存进程A的上下文环境（程序计数器、程序状态字、其他寄存器……）
用新状态和其他相关信息更新进程A的PCB
把进程A移至合适的队列（就绪、阻塞……）
将进程B的状态设置为运行态
从进程B的PCB中恢复上下文（程序计数器 、程序状态字、其他寄存器……）
</code></pre><h4 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h4><pre><code>直接开销：内核完成切换所用的CPU时间
    保存和恢复寄存器……
    切换地址空间（相关指令比较昂贵）
间接开销
    高速缓存(Cache)、缓冲区缓存(Buffer Cache)和TLB(Translation Look-aside Buffer)失效
</code></pre><h3 id="调度算法的设计"><a href="#调度算法的设计" class="headerlink" title="调度算法的设计"></a>调度算法的设计</h3><pre><code>什么情况下需要仔细斟酌调度算法？
    批处理系统 → 多道程序设计系统 → 批处理与分时的混合系统 → 个人计算机 → 网络服务器
</code></pre><h4 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a>衡量指标</h4><pre><code>吞吐量 Throughput — 每单位时间完成的进程数目
周转时间TT(Turnaround Time)
    每个进程从提出请求到运行完成的时间
响应时间RT(Response Time)
    从提出请求到第一次回应的时间

其他
    CPU 利用率(CPU Utilization)
        CPU做有效工作的时间比例
    等待时间(Waiting time)
        每个进程在就绪队列(ready queue)中等待的时间
</code></pre><h2 id="设计调度算法要考虑的几个问题"><a href="#设计调度算法要考虑的几个问题" class="headerlink" title="设计调度算法要考虑的几个问题"></a>设计调度算法要考虑的几个问题</h2><h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><pre><code>静态优先级：
    进程创建时指定，运行过程中不再改变
动态优先级：
    进程创建时指定了一个优先级，运行过程中可以动态变化
如：等待时间较长的进程可提升其优先级
</code></pre><h3 id="进程就绪队列组织"><a href="#进程就绪队列组织" class="headerlink" title="进程就绪队列组织"></a>进程就绪队列组织</h3><p>按优先级排队</p>
<p>另一种排队方式</p>
<h3 id="抢占与非抢占"><a href="#抢占与非抢占" class="headerlink" title="抢占与非抢占"></a>抢占与非抢占</h3><pre><code>指占用CPU的方式：
    可抢占式Preemptive（可剥夺式）
        当有比正在运行的进程优先级更高的进程就绪时，系统可强行剥夺正在运行进程的CPU，提供给具有更高优先级的进程使用
    不可抢占式Non-preemptive（不可剥夺式 ）
        某一进程被调度运行后，除非由于它自身的原因不能运行，否则一直运行下去
</code></pre><h3 id="IO密集型与CPU密集型进程"><a href="#IO密集型与CPU密集型进程" class="headerlink" title="IO密集型与CPU密集型进程"></a>IO密集型与CPU密集型进程</h3><pre><code>按进程执行过程中的行为划分：
    I/O密集型或I/O型(I/O-bound)
        频繁的进行I/O，通常会花费很多时间等待I/O操作的完成
     CPU密集型或CPU型或计算密集型(CPU-bound)
        需要大量的CPU时间进行计算
</code></pre><h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><pre><code>Time slice 或 quantum
一个时间段，分配给调度上CPU的进程，确定了允许该进程运行的时间长度
如何选择时间片呢？
</code></pre><h2 id="批处理系统的调度算法"><a href="#批处理系统的调度算法" class="headerlink" title="批处理系统的调度算法"></a>批处理系统的调度算法</h2><pre><code>先来先服务（FCFS-First Come First Serve）
最短作业优先（SJF-Shortest Job First）
最短剩余时间优先
（SRTN-Shortest Remaining Time Next）
最高相应比优先
（HRRN-Highest Response Ratio Next）
</code></pre><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><pre><code>First Come First Serve
    先进先出 First In First Out (FIFO)
    按照进程就绪的先后顺序使用CPU
    非抢占

优缺点
公平
实现简单
长进程后面的短进程需要等很长时间，不利于用户体验
</code></pre><h3 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h3><pre><code>Shortest Job First
具有最短完成时间的进程优先执行
非抢占式

最短剩余时间优先
    Shortest Remaining Time Next(SRTN)
SJF抢占式版本，即当一个新就绪的进程比当前运行进程具有更短的完成时间时，系统抢占当前进程，选择新就绪的进程执行
</code></pre><hr>
<pre><code>优缺点
    最短的平均周转时间
        在所有进程同时可运行时，采用SJF调度算法可以得到最短的平均周转时间
不公平
源源不断的短任务到来，可能使长的任务长时间得不到运行 → 产生 “饥饿”现象 (starvation)
</code></pre><h3 id="最高相应比优先HRRN"><a href="#最高相应比优先HRRN" class="headerlink" title="最高相应比优先HRRN"></a>最高相应比优先HRRN</h3><pre><code>Highest Response Ratio Next
是一个综合的算法
调度时，首先计算每个进程的响应比R；之后，总是选择 R 最高的进程执行
</code></pre><hr>
<pre><code>响应比R = 周转时间 / 处理时间 =（处理时间 + 等待时间）/ 处理时间 = 1 +（等待时间 / 处理时间）
</code></pre><h2 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a>交互式系统的调度算法</h2><p>轮转调度（RR-Round Robin）<br>最高优先级调度（HPF—Highest Priority First）<br>多级反馈队列（Multiple feedback queue）<br>最短进程优先（Shortest Process Next）</p>
<h3 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h3><pre><code>目标
    为短任务改善平均响应时间
解决问题的思路
    周期性切换
    每个进程分配一个时间片
    时钟中断 → 轮换
</code></pre><hr>
<pre><code>如何选择合适的时间片?
    太长 --大于典型的交互时间
        降级为先来先服务算法
        延长短进程的响应时间
    太短 --小于典型的交互时间
        进程切换浪费CPU时间
</code></pre><hr>
<pre><code>优缺点
    公平
    有利于交互式计算，响应时间快
    由于进程切换，时间片轮转算法要花费较高的开销
假设时间片 10ms，如果进程切换花费0.1ms，CPU开销约占1%
    RR对不同大小的进程是有利的
    但是对于相同大小的进程呢？
</code></pre><p>但是对于相同大小的进程呢？</p>
<h3 id="虚拟轮转法"><a href="#虚拟轮转法" class="headerlink" title="虚拟轮转法"></a>虚拟轮转法</h3><p>有一个辅助队列，选择其中的IO进程，辅助队列为空，再从就绪队列中选</p>
<h3 id="最高优先级调度"><a href="#最高优先级调度" class="headerlink" title="最高优先级调度"></a>最高优先级调度</h3><pre><code>选择优先级最高的进程投入运行
通常：系统进程优先级 高于 用户进程
    前台进程优先级 高于 后台进程
    操作系统更偏好 I/O型进程
优先级可以是静态不变的，也可以动态调整
    优先数可以决定优先级
就绪队列可以按照优先级组织
实现简单；不公平
</code></pre><hr>
<h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><pre><code>又称：优先级反置、翻转、倒挂
现象
    一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行
</code></pre><hr>
<pre><code>设H是高优先级进程，L是低优先级进程， M是中优先级进程（CPU型）
    场景：L进入临界区执行，之后被抢占；
        H也要进入临界区，失败，被阻塞；
        M上CPU执行，L无法执行所以H也无法执行
</code></pre><hr>
<pre><code>影响
    系统错误
    高优先级进程停滞不前，导致系统性能降低

解决方案
    设置优先级上限
    优先级继承
    使用中断禁止
</code></pre><h2 id="多级反馈队列调度算法、各种调度算法小结等"><a href="#多级反馈队列调度算法、各种调度算法小结等" class="headerlink" title="多级反馈队列调度算法、各种调度算法小结等"></a>多级反馈队列调度算法、各种调度算法小结等</h2><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><pre><code>Multilevel Feedback
是UNIX的一个分支BSD （加州大学伯克利分校开发和发布的）5.3版所采用的调度算法
是一个综合调度算法
</code></pre><hr>
<pre><code>设置多个就绪队列，第一级队列优先级最高
给不同就绪队列中的进程分配长度不同的时间片，第一级队列时间片最小；随着队列优先级别的降低，时间片增大
当第一级队列为空时，在第二级队列调度，以此类推
各级队列按照时间片轮转方式 进行调度
当一个新创建进程就绪后，进入第一级队列
进程用完时间片而放弃CPU，进入下一级就绪队列
由于阻塞而放弃CPU的进程进入相应的等待队列，一旦等待的事件发生，该进程回到原来一级就绪队列（？）
</code></pre><hr>
<pre><code>若允许抢占
    当有一个优先级更高的进程就绪时，可以抢占CPU
    被抢占的进程回到原来一级就绪队列末尾（或者？）
</code></pre><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p><img src="img/opSystem/forth/1.jpg" alt=""></p>
<h3 id="多处理器调度算法设计"><a href="#多处理器调度算法设计" class="headerlink" title="多处理器调度算法设计"></a>多处理器调度算法设计</h3><pre><code>不仅要决定选择哪一个进程执行
    还需要决定在哪一个CPU上执行
要考虑进程在多个CPU之间迁移时的开销
    高速缓存失效、TLB失效
    尽可能使进程总是在同一个CPU上执行
        如果每个进程可以调度到所有CPU上，假如进程上次在CPU1上执行，本次被调度到CPU2，则会增加高速缓存失效、TLB失效；如果每个进程尽量调度到指定的CPU上，各种失效就会减少
考虑负载均衡问题
</code></pre><h2 id="典型操作系统的调度算法"><a href="#典型操作系统的调度算法" class="headerlink" title="典型操作系统的调度算法"></a>典型操作系统的调度算法</h2><pre><code>UNIX 动态优先数法
5.3BSD 多级反馈队列法
Linux 抢占式调度
Windows 基于优先级的抢占式多任务调度
Solaris 综合调度算法
</code></pre><h3 id="LINUX调度算法的发展历史"><a href="#LINUX调度算法的发展历史" class="headerlink" title="LINUX调度算法的发展历史"></a>LINUX调度算法的发展历史</h3><pre><code>Linux2.4简单的基于优先级调度

Linux2.6O(1)调度器

Linux2.6 SD调度器补丁

Linux2.6RSDL调度器补丁

Linux2.6CFS调度器：完全公平调度算法
</code></pre><h3 id="Windows线程调度"><a href="#Windows线程调度" class="headerlink" title="Windows线程调度"></a>Windows线程调度</h3><pre><code>调度单位是线程
采用基于动态优先级的、抢占式调度，结合时间配额的调整
</code></pre><hr>
<pre><code>就绪线程按优先级进入相应队列
系统总是选择优先级最高的就绪线程运行
同一优先级的各线程按时间片轮转进行调度
多CPU系统中允许多个线程并行运行
</code></pre><hr>
<pre><code>引发线程调度的条件：
    一个线程的优先级改变了
    一个线程改变了它的亲和(Affinity)处理机集合

    线程正常终止 或 由于某种错误而终止
    新线程创建 或 一个等待线程变成就绪
    当一个线程从运行态进入阻塞态
    当一个线程从运行态变为就绪态
</code></pre><hr>
<pre><code>Windows使用32个线程优先级，分成三类
零页线程：0级
    用于对系统中空闲物理页面清零
实时优先级线程不改变其优先级
可变优先级线程：其优先级可以在一定范围内升高或降    低 基本优先级 和 当前优先级
</code></pre><h3 id="线程的时间配额"><a href="#线程的时间配额" class="headerlink" title="线程的时间配额"></a>线程的时间配额</h3><pre><code>时间配额不是一个时间长度值，而一个称为配额单位(quantum unit)的整数
一个线程用完了自己的时间配额时，如果没有其他相同优先级的线程，Windows将重新给该线程分配一个新的时间配额，让它继续运行
</code></pre><hr>
<pre><code>时间配额的一种特殊作用
    假设用户首先启动了一个运行时间很长的电子表格计算程序，然后切换到一个游戏程序(需要复杂图形计算并显示，CPU型)
    如果前台的游戏进程提高它的优先级，则后台的电子表格计算进程就几乎得不到CPU时间了
    但增加游戏进程的时间配额，则不会停止执行电子表格计算，只是给游戏进程的CPU时间多一些而已
</code></pre><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><pre><code>主动切换
抢占
时间配额用完
</code></pre><h4 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h4><pre><code>当线程被抢占时，它被放回相应优先级的就绪队列的队首
    处于实时优先级的线程在被抢占时，时间配额被重置为一个完整的时间配额
    处于可变优先级的线程在被抢占时，时间配额不变，重新得到CPU后将运行剩余的时间配额
</code></pre><h4 id="时间配额用完"><a href="#时间配额用完" class="headerlink" title="时间配额用完"></a>时间配额用完</h4><pre><code>假设线程A的时间配额用完
    A的优先级没有降低
    如果队列中有其他就绪线程，选择下一个线程执行，A回到原来就绪队列末尾
    如果队列中没有其他就绪线程，系统给线程A分配一个新的时间配额，让它继续运行

    A的优先级降低了，Windows 将选择一个更高优先级的线程
</code></pre><h3 id="线程优先级与时间配额调整"><a href="#线程优先级与时间配额调整" class="headerlink" title="线程优先级与时间配额调整"></a>线程优先级与时间配额调整</h3><pre><code>Windows的调度策略
    如何体现对某类线程具有倾向性？
    如何解决由于调度策略中潜在的不公平性而带来饥饿现象？
    如何改善系统吞吐量、响应时间等整体特征？

解决方案
    提升线程的优先级
    给线程分配一个很大的时间配额
</code></pre><h4 id="线程优先级提升"><a href="#线程优先级提升" class="headerlink" title="线程优先级提升"></a>线程优先级提升</h4><pre><code>下列5种情况，Windows 会提升线程的当前优先级：
    I/O操作完成
    信号量或事件等待结束
    前台进程中的线程完成一个等待操作
    由于窗口活动而唤醒窗口线程
    线程处于就绪态超过了一定的时间还没有运行
        —— “饥饿”现象
针对可变优先级范围内(1至15)的线程优先级
</code></pre><hr>
<p>I/O操作完成后的线程优先级提升</p>
<pre><code>在完成I/O操作后，Windows 将临时提升等待该操作线程的优先级，保证该线程能更快上CPU运行进行数据处理
优先级的提升值由设备驱动程序决定，提升建议值保存在系统文件“Wdm.h”或“Ntddk.h”中
优先级的提升幅度与对I/O请求的响应时间要求是一致的，响应时间要求越高，优先级提升幅度越大
设备驱动程序在完成I/O请求时通过内核函数IoCompleteRequest来指定优先级提升的幅度
为避免不公平，在I/O操作完成唤醒等待线程时会将该线程的时间配额减1
</code></pre><hr>
<p>“饥饿”线程优先级提升 </p>
<pre><code>系统线程“平衡集管理器(balance set manager)” 每秒钟扫描一次就绪队列，发现是否存在等待时间超过300个时钟中断间隔的线程
平衡集管理器将这些线程的优先级提升到15，并分配给它一个长度为正常值4倍的时间配额
当被提升的线程用完它的时间配额后，立即衰减到它原来的基本优先级
</code></pre><h2 id="重点-2"><a href="#重点-2" class="headerlink" title="重点"></a>重点</h2><h3 id="本讲重点"><a href="#本讲重点" class="headerlink" title="本讲重点"></a>本讲重点</h3><pre><code>掌握处理器调度的相关概念
    调度时机、进程切换
    调度标准：吞吐量、周转时间、响应时间
    优先级/优先数、抢占/非抢占、I/O型与CPU型
掌握主要的调度算法
    先来先服务、短作业优先、最高相应比优先
    时间片轮转、 最高优先级
    多级反馈队列
了解Windows、多处理器调度的基本思想
</code></pre><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><pre><code>重点阅读教材
第2章相关内容：2.4
第11章相关内容：11.4.3中的调度部分

重点概念
调度时机 进程切换 抢占/非抢占 时间片
优先级反转 饥饿 优先级与优先数 优先级提升
先来先服务 短作业优先 最高相应比优先
时间片轮转 最高优先级 多级队列反馈
吞吐量 周转时间 响应时间
</code></pre><h1 id="同步机制1"><a href="#同步机制1" class="headerlink" title="同步机制1"></a>同步机制1</h1><h2 id="进程的并发执行"><a href="#进程的并发执行" class="headerlink" title="进程的并发执行"></a>进程的并发执行</h2><p>进程的并发执行<br>进程互斥<br>进程同步<br>信号量及PV操作<br>经典的IPC问题</p>
<h3 id="进程并发执行"><a href="#进程并发执行" class="headerlink" title="进程并发执行"></a>进程并发执行</h3><h4 id="从进程的特征触发"><a href="#从进程的特征触发" class="headerlink" title="从进程的特征触发"></a>从进程的特征触发</h4><pre><code>并发
    进程的执行是间断性的
    进程的相对执行速度不可预测
共享
    进程/线程之间的制约性
不确定性
    进程执行的结果与其执行的相对速度有关，是不确定的
</code></pre><p>####与时间有关的错误  ####<br>两个进程的关键活动出现了交叉  </p>
<h3 id="并发执行过程分析"><a href="#并发执行过程分析" class="headerlink" title="并发执行过程分析"></a>并发执行过程分析</h3><pre><code>当前状态 (3,4,...,m) 2 2 (1,2)
可能的执行（假设g,c,p为get,copy,put的一次循环）
g,c,p (4,5,...,m) 3 3 (1,2,3) 正确
g,p,c (4,5,...,m) 3 3 (1,2,2) 错误
c,g,p (4,5,...,m) 3 2 (1,2,2) 错误
c,p,g (4,5,...,m) 3 2 (1,2,2) 错误
p,c,g (4,5,...,m) 3 2 (1,2,2) 错误
p,g,c (4,5,...,m) 3 3 (1,2,2) 错误
</code></pre><h3 id="进程前趋图"><a href="#进程前趋图" class="headerlink" title="进程前趋图"></a>进程前趋图</h3><p><img src="http://i.imgur.com/vl6oxdi.jpg" alt=""></p>
<h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序</p>
<h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><pre><code>由于各进程要求使用共享资源（变量、文件等），而这些资源需要排他性使用
各进程之间竞争使用这些资源
    —— 这一关系称为进程互斥

临界资源：critical resource
    系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源或共享变量

临界区(互斥区)：critical section(region)
    各个进程中对某个临界资源（共享变量）实施操作的程序片段
</code></pre><h3 id="临界区的使用原则"><a href="#临界区的使用原则" class="headerlink" title="临界区的使用原则"></a>临界区的使用原则</h3><pre><code>没有进程在临界区时，想进入临界区的进程可进入
不允许两个进程同时处于其临界区中
临界区外运行的进程不得阻塞其他进程进入临界区
不得使进程无限期等待进入临界区
</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><pre><code>软件方案
    Dekker解法、Peterson解法
硬件方案
    屏蔽中断、TSL(XCHG)指令
</code></pre><h2 id="软件解决方案"><a href="#软件解决方案" class="headerlink" title="软件解决方案"></a>软件解决方案</h2><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><pre><code>P:
    … …
    while (free) ;
    free = true;
    临界区
    free = false;
    … …
Q: 
    … … 
    while (free) ;
     free = true; 
    临界区 
    free = false;
     … …
</code></pre><hr>
<pre><code>free: 临界区空闲标志
true: 有进程在临界区 
false:无进程在临界区
初值：free为false
</code></pre><h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><pre><code>P:
    … …
    while (not turn) ;
    临界区
    turn = false;
    … …
Q:
    … …
    while (turn) ;
    临界区
    turn = true;
    … …
</code></pre><hr>
<pre><code>turn: 谁进临界区的标志 
true: P进程进临界区 
false: Q进程进临界区
初值任意
</code></pre><h3 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h3><pre><code>P:
    … …
    pturn = true;
    while (qturn) ;
    临界区
    pturn = false;
    … …

Q:
    … …
    qturn = true;
    while (pturn) ;
    临界区
    qturn = false;
    … …
</code></pre><hr>
<pre><code>pturn, qturn: 初值为false
P进入临界区的条件: pturn∧ not qturn
Q进入临界区的条件: not pturn∧ qturn
</code></pre><p>死锁问题</p>
<h3 id="解法4：DEKKER算法"><a href="#解法4：DEKKER算法" class="headerlink" title="解法4：DEKKER算法"></a>解法4：DEKKER算法</h3><pre><code>P:
    … …
    pturn = true;
    while (qturn) {
        if (turn == 2) {
            pturn = false;
            while (turn == 2);
            pturn = true;
            } }
    临界区
    turn = 2;
    pturn = false;
    … …

Q:
… …
qturn = true;
while (pturn) {
    if (turn == 1) {
        qturn = false;
        while (turn == 1);
        qturn = true;
    } }
临界区
turn = 1;
qturn = false;
… …
</code></pre><h3 id="解法5：PETTERSON算法"><a href="#解法5：PETTERSON算法" class="headerlink" title="解法5：PETTERSON算法"></a>解法5：PETTERSON算法</h3><pre><code>Peterson算法解决了互斥访问的问题，而且克服了强制轮流法的缺点，可以完全正常地工作（1981）
</code></pre><hr>
<pre><code>进程i：
    … …
    enter_region ( i );
    临界区
    leave_region ( i );
</code></pre><h2 id="进程互斥的硬件解决方法"><a href="#进程互斥的硬件解决方法" class="headerlink" title="进程互斥的硬件解决方法"></a>进程互斥的硬件解决方法</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><pre><code>“开关中断”指令
执行“关中断”指令
    临界区操作
执行“开中断”指令
</code></pre><hr>
<pre><code>简单，高效
代价高，限制CPU并发能力（临界区大小）
不适用于多处理器
适用于操作系统本身，不适于用户进程
</code></pre><h3 id="“测试并加锁”指令"><a href="#“测试并加锁”指令" class="headerlink" title="“测试并加锁”指令"></a>“测试并加锁”指令</h3><p>TSL指令：TEST AND SET LOCK    </p>
<pre><code>复制锁到寄存器并将锁置1
判断寄存器内容是否是零？
若不是零，跳转到enter_region
返回调用者，进入了临界区

在锁中置0
返回调用者
</code></pre><h3 id="交换指令"><a href="#交换指令" class="headerlink" title="交换指令"></a>交换指令</h3><pre><code>给寄存器中置1 
交换寄存器与锁变量的内容 
判断寄存器内容是否是零？ 
若不是零，跳转到enter_region 
返回调用者，进入了临界区

在锁中置0
返回调用者
</code></pre><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><pre><code>软件方法
    编程技巧
硬件方法
忙等待(busy waiting)
    进程在得到临界区访问权之前，持续测试而不做其他事情
    自旋锁 Spin lock (多处理器 √)
优先级反转（倒置）
</code></pre><h2 id="进程的同步"><a href="#进程的同步" class="headerlink" title="进程的同步"></a>进程的同步</h2><pre><code>进程同步：synchronization
    指系统中多个进程中发生的事件存在某种时序关系，需要相互合作，共同完成一项任务
</code></pre><hr>
<pre><code>具体地说，一个进程运行到某一点时，要求另一伙伴进程为它提供消息，在未获得消息之前，该进程进入阻塞态，获得消息后被唤醒进入就绪态
</code></pre><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><pre><code>问题描述：
    一个或多个生产者生产某种类型的数据放置在缓冲区中
    有消费者从缓冲区中取数据，每次取一项
    只能有一个生产者或消费者对缓冲区进行操作
</code></pre><h4 id="要解决的问题："><a href="#要解决的问题：" class="headerlink" title="要解决的问题："></a>要解决的问题：</h4><pre><code>当缓冲区已满时，生产者不会继续向其中添加数据；
当缓冲区为空时，消费者不会从中移走数据
生产者和消费者不能同时操作
</code></pre><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><pre><code>避免忙等待
睡眠 与 唤醒 操作(原语)
</code></pre><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#define N 100
int count=0;
void producer(void)
{ int item;
    while(TRUE) {
        item=produce_item();
        if(count==N) sleep();
        insert_item(item);
        count=count+1;
        if(count==1)
        wakeup(consumer);
    }
}
</code></pre><hr>
<pre><code>void consumer(void)
{
    int item;
    while(TRUE) {
        if(count==0) sleep();
        item=remove_item();
        count=count-1;
        if(count==N-1)
        wakeup(producer);
        consume_item(item);
    }
}
</code></pre><p>没有完全解决问题</p>
<h3 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h3><p><img src="http://i.imgur.com/ifkpI4v.jpg" alt=""></p>
<p><img src="http://i.imgur.com/kiLLuu6.jpg" alt=""></p>
<h2 id="信号量及P、V操作"><a href="#信号量及P、V操作" class="headerlink" title="信号量及P、V操作"></a>信号量及P、V操作</h2><pre><code>一个特殊变量
用于进程间传递信息的一个整数值
定义如下：
struc semaphore
{
    int count;
    queueType queue;
}
信号量说明：semaphore s;
对信号量可以实施的操作：初始化、P和V（P、V分别是荷兰语的test(proberen)和increment(verhogen)）
</code></pre><h3 id="P，V操作定义"><a href="#P，V操作定义" class="headerlink" title="P，V操作定义"></a>P，V操作定义</h3><pre><code>P(s)
{
    s.count --;
    if (s.count &lt; 0)
{
    该进程状态置为阻塞状态；
    将该进程插入相应的等待队列s.queue末尾；
    重新调度；
}
}
</code></pre><p>down, semWait</p>
<hr>
<pre><code>V(s)
{
    s.count ++;
    if (s.count &lt; = 0)
{
    唤醒相应等待队列s.queue中等待的一个进程；
    改变其状态为就绪态，并将其插入就绪队列；
}
}
</code></pre><p>up, semSignal</p>
<h4 id="有关说明"><a href="#有关说明" class="headerlink" title="有关说明"></a>有关说明</h4><pre><code>P、V操作为原语操作(primitive or atomic action)

在信号量上定义了三个操作
    初始化(非负数)、P操作、V操作

最初提出的是二元信号量（解决互斥）
    之后，推广到一般信号量（多值）或计数信号量（解决同步）
</code></pre><h3 id="PV操作解决进行间互斥问题"><a href="#PV操作解决进行间互斥问题" class="headerlink" title="PV操作解决进行间互斥问题"></a>PV操作解决进行间互斥问题</h3><pre><code>分析并发进程的关键活动，划定临界区
设置信号量 mutex，初值为1
在临界区前实施 P(mutex)
在临界区之后实施 V(mutex)
</code></pre><p><img src="http://i.imgur.com/XM6g4tn.jpg" alt=""></p>
<h2 id="生产者消费者问题-1"><a href="#生产者消费者问题-1" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h3 id="用信号量的解法"><a href="#用信号量的解法" class="headerlink" title="用信号量的解法"></a>用信号量的解法</h3><pre><code>void producer(void) 
{ int item; 
    while(TRUE) 
    { item=produce_item();
         P(&amp;empty); 
        P(&amp;mutex); 
        insert_item(item);
         V(&amp;mutex);
         V(&amp;full); 
    } }
</code></pre><hr>
<pre><code>void consumer(void)
{ int item;
    while(TRUE) {
        P(&amp;full);
        P(&amp;mutex);
        item=remove_item();
        V(&amp;mutex);
        V(&amp;empty);
        consume_item(item);
}
}
</code></pre><hr>
<pre><code>#define N 100 /* 缓冲区个数 */
typedef int semaphore; /* 信号量是一种特殊的整型数据 */
semaphore mutex =1; /* 互斥信号量：控制对临界区的访问 */
semaphore empty =N; /* 空缓冲区个数 */
semaphore full = 0; /* 满缓冲区个数 */
</code></pre><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><pre><code>思考：
若颠倒两个P操作的顺序？
思考：
若颠倒两个V操作的顺序？
</code></pre><h2 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h2><h3 id="信号量解法"><a href="#信号量解法" class="headerlink" title="信号量解法"></a>信号量解法</h3><pre><code>问题描述：
    多个进程共享一个数据区，这些进程分为两组：
        读者进程：只读数据区中的数据
        写者进程：只往数据区写数据

要求满足条件：
    允许多个读者同时执行读操作
    不允许多个写者同时操作
    不允许读者、写者同时操作
</code></pre><h3 id="第一类问题，读者优先"><a href="#第一类问题，读者优先" class="headerlink" title="第一类问题，读者优先"></a>第一类问题，读者优先</h3><pre><code>如果读者执行：
    无其他读者、写者，该读者可以读
    若已有写者等，但有其他读者正在读，则该读者也可以读
    若有写者正在写，该读者必须等

如果写者执行：
    无其他读者、写者，该写者可以写
    若有读者正在读，该写者等待
    若有其他写者正在写，该写者等待
</code></pre><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><pre><code>void reader(void)
{
    while (TRUE) {
    ……
    P (w);//第一个读者做
    读操作
    V(w);//最后一个读者做
    ……
}
}
</code></pre><hr>
<pre><code>void writer(void)
{
    while (TRUE) {
    ……
    P(w);
    写操作
    V(w);
    ……
}
}
</code></pre><p>解决不了多个同时读</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><pre><code>void reader(void)
{
while (TRUE) {
    P(mutex);
    rc = rc + 1;
    if (rc == 1) P (w);//Rc也需要保护
    V(mutex);

    读操作

    P(mutex);
    rc = rc - 1;
    if (rc == 0) V(w);
    V(mutex);
    其他操作
}
</code></pre><hr>
<pre><code>void writer(void)
{
while (TRUE) {
……
P(w);

写操作

V(w);
}
}
</code></pre><h3 id="LINUX提供的读写锁"><a href="#LINUX提供的读写锁" class="headerlink" title="LINUX提供的读写锁"></a>LINUX提供的读写锁</h3><pre><code>应用场景
    如果每个执行实体对临界区的访问或者是读或者是写共享变量，但是它们都不会既读又写时，读写锁是最好的选择

实例：Linux的IPX路由代码中使用了读-写锁，用ipx_routes_lock的读-写锁保护IPX路由表的并发访问
</code></pre><hr>
<pre><code>要通过查找路由表实现包转发的程序需要请求读锁；

需要添加和删除路由表中入口的程序必须获取写锁（由于通过读路由表的情况比更新路由表的情况多得多，使用读-写锁提高了性能）
</code></pre><h2 id="重点-3"><a href="#重点-3" class="headerlink" title="重点"></a>重点</h2><pre><code>基本概念
    竞争条件、临界区
    进程同步、进程互斥
    自旋锁（忙等待）
信号量、PV操作
经典问题模型及解决方案
    生产者-消费者问题、读者-写者问题
</code></pre><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><pre><code>重点阅读教材
第2章相关内容：2.3.1~2.3.5，2.5.2

重点概念
竞争条件 与时间有关的错误 忙等待
临界资源 临界区 进程互斥 进程同步
信号量 P、V操作 锁 自旋锁
生产者消费者问题 读者写者问题
</code></pre><h1 id="同步互斥机制2"><a href="#同步互斥机制2" class="headerlink" title="同步互斥机制2"></a>同步互斥机制2</h1><h2 id="管程的基本概念"><a href="#管程的基本概念" class="headerlink" title="管程的基本概念"></a>管程的基本概念</h2><pre><code>管程monitor
进程间通信
    Inter-Process Communication
典型操作系统的IPC机制
</code></pre><h3 id="为什么会出现管程"><a href="#为什么会出现管程" class="headerlink" title="为什么会出现管程"></a>为什么会出现管程</h3><pre><code>问题：
    信号量机制的不足：程序编写困难、易出错  
解决：
    Brinch Hansen(1973) 
    Hoare（1974）
方案：
    在程序设计语言中引入管程成分 
    一种高级同步机制
</code></pre><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre><code>是一个特殊的模块
有一个名字
由关于共享资源的数据结构及在其上操作的一组过程组成

进程与管程
进程只能通过调用管程中的过程来间接地访问管程中的数据结构
</code></pre><h3 id="有什么保证"><a href="#有什么保证" class="headerlink" title="有什么保证"></a>有什么保证</h3><pre><code>互斥
    管程是互斥进入的
        ——为了保证管程中数据结构的数据完整性
管程的互斥性是由编译器负责保证的

同步
    管程中设置条件变量及等待/唤醒操作以解决同步问题
    可以让一个进程或线程在条件变量上等待（此时，应先释放管程的使用权），也可以通过发送信号将等待在条件变量上的进程或线程唤醒
</code></pre><h3 id="会遇到什么问题"><a href="#会遇到什么问题" class="headerlink" title="会遇到什么问题"></a>会遇到什么问题</h3><pre><code>设问：
    是否会出现这样一种场景，有多个进程同时在管程中出现？
场景场景：
    当一个进入管程的进程执行等待操作时，它应当释放管程的互斥权

    当后面进入管程的进程执行唤醒操作时（例如P唤醒Q），管程中便存在两个同时处于活动状态的进程

如何解决？
    三种处理方法：
        P等待Q执行
        Q等待P继续执行
        规定唤醒操作为管程中最后一个可执行的操作
</code></pre><h2 id="Hoare管程"><a href="#Hoare管程" class="headerlink" title="Hoare管程"></a>Hoare管程</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><pre><code>因为管程是互斥进入的，所以当一个进程试图进入一个已被占用的管程时，应当在管程的入口处等待
    为此，管程的入口处设置一个进程等待队列，称作入口等待队列
如果进程P唤醒进程Q，则P等待Q执行；如果进程Q执行中又唤醒进程R，则Q等待R执行；……，如此，在管程内部可能会出现多个等待进程
    在管程内需要设置一个进程等待队列，称为紧急等待队列，紧急等待队列的优先级高于入口等待队列的优先级
</code></pre><h3 id="条件变量的实现"><a href="#条件变量的实现" class="headerlink" title="条件变量的实现"></a>条件变量的实现</h3><pre><code>条件变量——在管程内部说明和使用的一种特殊类型的变量
var c:condition;
对于条件变量，可以执行wait和signal操作
</code></pre><hr>
<pre><code>wait(c)：
    如果紧急等待队列非空，则唤醒第一个等待者；否则释放管程的互斥权，执行此操作的进程进入c链末尾
signal(c)：
    如果c链为空，则相当于空操作，执行此操作的进程继续执行；否则唤醒第一个等待者，执行此操作的进程进入紧急等待队列的末尾
</code></pre><h2 id="管程的实现"><a href="#管程的实现" class="headerlink" title="管程的实现"></a>管程的实现</h2><pre><code>管程实现的两个主要途径：
    * 直接构造 → 效率高
    * 间接构造
        → 用某种已经实现的同步机制去构造
</code></pre><h3 id="管程解决生产者消费者问题"><a href="#管程解决生产者消费者问题" class="headerlink" title="管程解决生产者消费者问题"></a>管程解决生产者消费者问题</h3><h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><pre><code>procedure producer;
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;
procedure consumer;
begin
    while true do
    begin
        item=ProducerConsumer.remove;
        consume_item(item);
    end
end;
</code></pre><h4 id="管程的实现-1"><a href="#管程的实现-1" class="headerlink" title="管程的实现"></a>管程的实现</h4><pre><code>monitor ProducerConsumer
    condition full, empty;
    integer count;
    procedure insert (item: integer);
    begin
        if count == N then wait(full);
        insert_item(item); count++;
        if count ==1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count ==0 then wait(empty);
        remove = remove_item; count--;
        if count==N-1 then signal(full);
    end;
    count:=0;
end monitor;
</code></pre><h3 id="java有类似管程的机制"><a href="#java有类似管程的机制" class="headerlink" title="java有类似管程的机制"></a>java有类似管程的机制</h3><h2 id="MESA管程"><a href="#MESA管程" class="headerlink" title="MESA管程"></a>MESA管程</h2><pre><code>Lampson和Redell，Mesa语言（1980）
Hoare管程的一个缺点
    两次额外的进程切换
解决：
    signal → notify
    notify：当一个正在管程中的进程执行notify(x)时，它使得x条件队列得到通知，发信号的进程继续执行
</code></pre><h3 id="使用NOTIFY要注意的问题"><a href="#使用NOTIFY要注意的问题" class="headerlink" title="使用NOTIFY要注意的问题"></a>使用NOTIFY要注意的问题</h3><pre><code>notify的结果：位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行

由于不能保证在它之前没有其他进程进入管程，因而这个进程必须重新检查条件
→ 用while循环取代if语句

导致对条件变量至少多一次额外的检测（但不再有额外的进程切换），并且对等待进程在notify之后何时运行没有任何限制
</code></pre><h3 id="解决生产者消费者问题"><a href="#解决生产者消费者问题" class="headerlink" title="解决生产者消费者问题"></a>解决生产者消费者问题</h3><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><pre><code>对notify的一个很有用的改进
    给每个条件原语关联一个监视计时器，不论是否被通知，一个等待时间超时的进程将被设为就绪态
    当该进程被调度执行时，会再次检查相关条件，如果条件满足则继续执行

超时可以防止如下情况的发生：
    当某些进程在产生相关条件的信号之前失败时，等待该条件的进程就会被无限制地推迟执行而处于饥饿状态
</code></pre><h3 id="引入BROADCAST"><a href="#引入BROADCAST" class="headerlink" title="引入BROADCAST"></a>引入BROADCAST</h3><pre><code>broadcast：使所有在该条件上等待的进程都被释放并进入就绪队列

    当一个进程不知道有多少进程将被激活时，这种方式是非常方便的
        例子：生产者/消费者问题中，假设insert和remove函数都适用于可变长度的字符块，此时，如果一个生产者往缓冲区中添加了一批字符，它不需要知道每个正在等待的消费者准备消耗多少字符，而仅仅执行一个broadcast，所有正在等待的进程都得到通知并再次尝试运行

当一个进程难以准确判定将激活哪个进程时，也可使用广播
</code></pre><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><pre><code>Mesa管程优于Hoare管程之处在于Mesa管程错误比较少
在Mesa管程中，由于每个过程 在收到信号后都重新检查管程变量，并且由于使用了while结构，一个进程不正确的broadcast广播或发信号notify，不会导致收到信号的程序出错
    收到信号的程序将检查相关的变量，如果期望的条件没有满足，它会重新继续等待
</code></pre><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><pre><code>管程：抽象数据类型
    有一个明确定义的操作集合，通过它且只有通过它才能操纵该数据类型的实例
实现管程结构必须保证下面几点：
    （1）只能通过管程的某个过程才能访问资源；
    （2）管程是互斥的，某个时刻只能有一个进程或线程调用管程中的过程
条件变量：为提供进程与其他进程通信或同步而引入
     wait/signal 或 wait/notify 或 wait/broadcast
</code></pre><h2 id="PTHREAD中的同步机制"><a href="#PTHREAD中的同步机制" class="headerlink" title="PTHREAD中的同步机制"></a>PTHREAD中的同步机制</h2><p><img src="http://i.imgur.com/6CmUVag.jpg" alt=""></p>
<h3 id="生产者消费者问题-2"><a href="#生产者消费者问题-2" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p><img src="http://i.imgur.com/QRMKEIh.jpg" alt=""><br>实现的是mesa管程的语义</p>
<h3 id="cond-wait"><a href="#cond-wait" class="headerlink" title="cond_wait"></a>cond_wait</h3><pre><code>pthread_cond_wait的执行分解为三个主要动作：
    1、解锁
    2、等待
        当收到一个解除等待的信号（pthread_cond_signal或者pthread_cond_broad_cast）之后，pthread_cond_wait马上需要做的动作是：
    3、上锁
</code></pre><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="为什么需要通信机制？"><a href="#为什么需要通信机制？" class="headerlink" title="为什么需要通信机制？"></a>为什么需要通信机制？</h3><pre><code>信号量及管程的不足
不适用多处理器情况

进程通信机制
    消息传递send &amp; receive原语

适用于：分布式系统、基于共享内存的多处理机系统、单处理机系统
可以解决进程间的同步问题、通信问题
</code></pre><h3 id="基本通信方式"><a href="#基本通信方式" class="headerlink" title="基本通信方式"></a>基本通信方式</h3><pre><code>消息传递
共享内存
管道
套接字
远程过程调用
</code></pre><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><img src="http://i.imgur.com/EZuWkXa.jpg" alt=""></p>
<h4 id="PV操作的实现send"><a href="#PV操作的实现send" class="headerlink" title="PV操作的实现send"></a>PV操作的实现send</h4><p><img src="http://i.imgur.com/uNs6069.jpg" alt=""></p>
<p>###共享内存 ###<br><img src="http://i.imgur.com/gHeUaSg.jpg" alt=""></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p><img src="http://i.imgur.com/06aIUmm.jpg" alt=""></p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><h3 id="远程过程调用"><a href="#远程过程调用" class="headerlink" title="远程过程调用"></a>远程过程调用</h3><h2 id="典型操作系统中的IPC机制"><a href="#典型操作系统中的IPC机制" class="headerlink" title="典型操作系统中的IPC机制"></a>典型操作系统中的IPC机制</h2><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><pre><code>UNIX
    管道、消息队列、共享内存、信号量、信号、套接字

Linux
    管道、消息队列、共享内存、信号量、信号、套接字

    内核同步机制：原子操作、自旋锁、读写锁、信号量、屏障、BKL

Windows
    同步对象：互斥对象、事件对象、信号量对象

    临界区对象

    互锁变量

    套接字、文件映射、管道、命名管道、邮件槽、剪贴板、动态数据交换、对象连接与嵌入、动态链接库、远程过程调用
</code></pre><h3 id="Linux的进程通信机制"><a href="#Linux的进程通信机制" class="headerlink" title="Linux的进程通信机制"></a>Linux的进程通信机制</h3><p><img src="http://i.imgur.com/fwqMmfW.jpg" alt=""></p>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><pre><code>不可分割，在执行完之前不会被其他任务或事件中断
常用于实现资源的引用计数
atomic_t
</code></pre><hr>
<pre><code>typedef struct { volatile int counter; } 

atomic_t;
原子操作API包括：
atomic_read(atomic_t * v);
atomic_set(atomic_t * v, int i);
void atomic_add(int i, atomic_t *v);
int atomic_sub_and_test(int i, atomic_t *v);
void atomic_inc(atomic_t *v);
int atomic_add_return(int i, atomic_t *v);
</code></pre><h4 id="屏障：栅栏"><a href="#屏障：栅栏" class="headerlink" title="屏障：栅栏"></a>屏障：栅栏</h4><pre><code>一种同步机制(又称栅栏、关卡)
 用于对一组线程进行协调
应用场景
一组线程协同完成一项任务，需要所有线程都到达一个汇合点后再一起向前推进
</code></pre><h2 id="重点-4"><a href="#重点-4" class="headerlink" title="重点"></a>重点</h2><pre><code>管程
    如何保证互斥
    如何保证同步——条件变量及wait/signal
    Hoare管程
    MESA管程
进程间通信
    消息传递、共享内存、管道
Pthread中的同步机制
Linux的IPC机制
</code></pre><h3 id="重点阅读和概念"><a href="#重点阅读和概念" class="headerlink" title="重点阅读和概念"></a>重点阅读和概念</h3><pre><code>重点阅读教材
第2章相关内容：2.3.6~2.3.9
</code></pre><hr>
<pre><code>管程 Hoare管程 Mesa管程
条件变量 wait/signal
Pthread中的互斥锁与条件变量
共享内存 消息传递 管道
Linux：原子操作 屏障 读写锁
</code></pre><h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><h2 id="基本概念：地址重定位"><a href="#基本概念：地址重定位" class="headerlink" title="基本概念：地址重定位"></a>基本概念：地址重定位</h2><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><pre><code>程序装载到内存才可以运行
    通常，程序以可执行文件格式保存在磁盘上

多道程序设计模型
    允许多个程序同时进入内存

每个进程有自己的地址空间
    一个进程执行时不能访问另一个进程的地址空间
    进程不能执行不适合的操作
</code></pre><h3 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h3><pre><code>多个进程与物理内存交互的问题  
包括合理分配内存等等
</code></pre><h3 id="进程地址空间-1"><a href="#进程地址空间-1" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><pre><code>内核地址空间  
用户地址空间：栈，堆，数据段，代码段，其他内容：共享库，内存映射文件
</code></pre><h3 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h3><pre><code>进程中的地址不是最终的物理地址
在进程运行前无法计算出物理地址
    因为：不能确定进程被加载到内存什么地方
</code></pre><hr>
<pre><code>需要***地址重定位***的支持
也是地址转换、地址变换、地址翻译、地址映射
</code></pre><h3 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a>地址重定位</h3><h4 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h4><pre><code>逻辑地址（相对地址，虚拟地址）
    用户程序经过编译、汇编后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余地址都相对于首地址而编址
    不能用逻辑地址在内存中读取信息
</code></pre><h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><pre><code>物理地址（绝对地址，实地址）
内存中存储单元的地址 可直接寻址
</code></pre><h4 id="地址重定位-1"><a href="#地址重定位-1" class="headerlink" title="地址重定位"></a>地址重定位</h4><pre><code>为了保证CPU执行指令时可正确访问内存单元，需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址，这一过程称为地址重定位
</code></pre><h3 id="静态重定位与动态重定位"><a href="#静态重定位与动态重定位" class="headerlink" title="静态重定位与动态重定位"></a>静态重定位与动态重定位</h3><pre><code>静态重定位： 当用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换

 一般可以由软件完成
</code></pre><hr>
<pre><code>动态重定位：
     在进程执行过程中进行地址变换
         → → 即逐条指令执行时完成地址转换 
需要硬件部件支持
</code></pre><h4 id="动态重定位实现"><a href="#动态重定位实现" class="headerlink" title="动态重定位实现"></a>动态重定位实现</h4><p><img src="http://i.imgur.com/AjKr58E.jpg" alt=""></p>
<h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><pre><code>等长划分与不等长划分：
    每一块称为分配单元

数据结构
    位图
    每个分配单元对应于位图中的一位，0表示空闲，1表示占用（或者相反）
空闲区表、已分配区表
    表中每一项记录了空闲区（或已分配区）的起始地址、长度、标志
空闲块链表
</code></pre><h3 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h3><pre><code>首次适配 first fit
    在空闲区表中找到第一个满足进程要求的空闲区
下次适配 next fit
    从上次找到的空闲区处接着查找
最佳适配 best fit
    查找整个空闲区表，找到能够满足进程要求的最小空闲区
最差适配 worst fit
    总是分配满足进程要求的最大空闲区

找到空闲区之后：
    将该空闲区分为两部分，一部分供进程使用，另一部分形成新的空闲区
</code></pre><h3 id="回收问题"><a href="#回收问题" class="headerlink" title="回收问题"></a>回收问题</h3><pre><code>内存回收算法
    当某一块归还后，前后空闲空间合并，修改内存空闲区表
    四种情况
        上相邻、下相邻、上下都相邻、上下都不相邻
</code></pre><h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><pre><code>一种经典的内存分配方案
主要思想：将内存按2的幂进行划分，组成若干空闲块链表；查找该链表找到能满足进程需求的最佳匹配块
算法：
    首先将整个可用空间看作一块： 2^U
    假设进程申请的空间大小为 s，如果满足
        2^U-1 &lt; s &lt;= 2^U，则分配整个块
    否则，将块划分为两个大小相等的伙伴，大小为2U-1
    一直划分下去直到产生大于或等于 s 的最小块
</code></pre><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="http://i.imgur.com/o03xMIo.jpg" alt=""></p>
<h2 id="基本内存管理方案"><a href="#基本内存管理方案" class="headerlink" title="基本内存管理方案"></a>基本内存管理方案</h2><pre><code>整个进程进入内存中一片连续区域
</code></pre><h3 id="单一连续区"><a href="#单一连续区" class="headerlink" title="单一连续区"></a>单一连续区</h3><pre><code>特点：一段时间内只有一个进程在内存
简单，内存利用率低
</code></pre><h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><pre><code>把内存空间分割成若干区域，称为分区
每个分区的大小可以相同也可以不同
分区大小固定不变
每个分区装一个且只能装一个进程
</code></pre><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>容易产生较长的排队队列<br>基本不用</p>
<h3 id="可变分区"><a href="#可变分区" class="headerlink" title="可变分区"></a>可变分区</h3><pre><code>根据进程的需要，把内存空闲空间分割出一个分区，分配给该进程
剩余部分成为新的空闲区
</code></pre><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>容易产生碎片化，可能导致内存利用率下降</p>
<h4 id="碎片问题解决"><a href="#碎片问题解决" class="headerlink" title="碎片问题解决"></a>碎片问题解决</h4><pre><code>碎片 → 很小的、不易利用的空闲区
        → 导致内存利用率下降
解决方案 → 紧缩技术（memory compaction）
    在内存移动程序，将所有小的空闲区合并为较大的空闲区
    又称：压缩技术，紧致技术，搬家技术
紧缩时要考虑的问题
    系统开销 ？ 移动时机 ？
</code></pre><h3 id="页式"><a href="#页式" class="headerlink" title="页式"></a>页式</h3><pre><code>设计思想
    用户进程地址空间被划分为大小相等的部分，称为页（page）或页面，从0开始编号
    内存空间按同样大小划分为大小相等的区域，称为页框（page frame），从0开始编号；也称为物理页面，页帧，内存块
    内存分配（规则）
        以页为单位进行分配，并按进程需要的页数来分配；逻辑上相邻的页，物理上不一定相邻
典型页面尺寸：4K 或 4M
</code></pre><h4 id="管理方案"><a href="#管理方案" class="headerlink" title="管理方案"></a>管理方案</h4><pre><code>划分是由系统自动完成的，对用户是透明的
逻辑地址
    页号 页内地址
</code></pre><p><img src="http://i.imgur.com/OKGbAYs.jpg" alt=""></p>
<h4 id="内存分配过程"><a href="#内存分配过程" class="headerlink" title="内存分配过程"></a>内存分配过程</h4><p><img src="http://i.imgur.com/Eb0yzM5.jpg" alt=""></p>
<p><img src="http://i.imgur.com/kA8DNSC.jpg" alt=""></p>
<h4 id="相关数据结构及地址转换"><a href="#相关数据结构及地址转换" class="headerlink" title="相关数据结构及地址转换"></a>相关数据结构及地址转换</h4><pre><code>页表
    页表项：记录了逻辑页号与页框号的对应关系
    每个进程一个页表，存放在内存
    页表起始地址保存在何处？

空闲内存管理

地址转换（硬件支持）
    CPU取到逻辑地址，自动划分为页号和页内地址；用页号查页表，得到页框号，再与页内偏移拼接成为物理地址
</code></pre><p>产生内碎片</p>
<h3 id="段式"><a href="#段式" class="headerlink" title="段式"></a>段式</h3><pre><code>设计思想
    用户进程地址空间：按程序自身的逻辑关系划分为若干个程序段，每个程序段都有一个段名

    内存空间被动态划分为若干长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定

    内存分配（规则）：以段为单位进行分配，每段在内存中占据连续空间，但各段之间可以不相邻

    逻辑地址 段号 段内地址：不能自动划分，必须显式给出
</code></pre><p>使用段表进行映射</p>
<h4 id="相关数据结构及地址转换-1"><a href="#相关数据结构及地址转换-1" class="headerlink" title="相关数据结构及地址转换"></a>相关数据结构及地址转换</h4><pre><code>段表
    每项记录了段号、段首地址和段长度之间的关系
    每个进程一个段表，存放在内存
    段表起始地址保存在何处？

物理内存管理

地址转换（硬件）
    CPU取到逻辑地址，用段号查段表，得到该段在内存的起始地址，与段内偏移地址计算出物理地址
</code></pre><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><pre><code>产生背景
    综合页式、段式方案的优点，克服二者的缺点
设计思想
用户进程划分：
    先按段划分，每一段再按页面划分
逻辑地址：
    段号    段内地址
        页号    页内地址
内存划分：同页式存储管理方案
内存分配：以页为单位进行分配
</code></pre><hr>
<pre><code>数据结构及有关操作
    段表：记录了每一段的页表始址和页表长度
    页表：记录了逻辑页号与页框号的对应关系
        每一段有一张页表，一个进程有多个页表
    空闲区管理：同页式管理
    内存分配、回收：同页式管理
地址转换
    段号    段内地址
        页号    页内地址
</code></pre><h2 id="交换技术（Swapping）"><a href="#交换技术（Swapping）" class="headerlink" title="交换技术（Swapping）"></a>交换技术（Swapping）</h2><h3 id="内存不足时如何管理"><a href="#内存不足时如何管理" class="headerlink" title="内存不足时如何管理"></a>内存不足时如何管理</h3><p>如何解决在较小的内存空间运行较大的进程呢？</p>
<h3 id="内存“扩充”技术"><a href="#内存“扩充”技术" class="headerlink" title="内存“扩充”技术"></a>内存“扩充”技术</h3><pre><code>内存紧缩技术（例如：可变分区）
覆盖技术 overlaying
交换技术 swapping
虚拟存储技术 virtual memory
</code></pre><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><p>主要用于早期的操作系统</p>
<pre><code>解决的问题 → 程序大小超过物理内存总和
程序执行过程中，程序的不同部分在内存中相互替代
    → 按照其自身的逻辑结构，将那些不会同时执行的程序段共享同一块内存区域
    → 要求程序各模块之间有明确的调用结构

程序员声明覆盖结构，操作系统完成自动覆盖
</code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="http://i.imgur.com/MI0JAbj.jpg" alt=""></p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><pre><code>设计思想
    内存空间紧张时，系统将内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域（进程在内存与磁盘之间的动态调度）

讨论：实现时遇到的问题
    进程的哪些内容要交换到磁盘？会遇到什么困难？
    在磁盘的什么位置保存被换出的进程？
    交换时机？
    如何选择被换出的进程？
    如何处理进程空间增长？
</code></pre><h4 id="关于讨论的问题"><a href="#关于讨论的问题" class="headerlink" title="关于讨论的问题"></a>关于讨论的问题</h4><pre><code>运行时创建或修改的内容：栈和堆

交换区：
    一般系统会指定一块特殊的磁盘区域作为交换空间（swap space），包含连续的磁道，操作系统可以使用底层的磁盘读写操作对其高效访问

何时需发生交换？
    只要不用就换出（很少再用）；内存空间不够或有不够的危险时换出
    与调度器结合使用

考虑进程的各种属性；不应换出处于等待I/O状态的进程
</code></pre><hr>
<p>预留出一些空间用于增长<br><img src="http://i.imgur.com/0nN34dY.jpg" alt=""></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/21/计算机组成原理/" rel="next" title="计算机组成">
                <i class="fa fa-chevron-left"></i> 计算机组成
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/22/spring揭秘读书笔记/" rel="prev" title="spring揭秘">
                spring揭秘 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="lily" />
          <p class="site-author-name" itemprop="name">lily</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统概述"><span class="nav-number">1.</span> <span class="nav-text">操作系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统做了什么？"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统做了什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从上述步骤中得到了什么"><span class="nav-number">1.1.1.</span> <span class="nav-text">从上述步骤中得到了什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#换个角度看用户程序的执行"><span class="nav-number">1.1.2.</span> <span class="nav-text">换个角度看用户程序的执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的定义与作用"><span class="nav-number">1.2.</span> <span class="nav-text">操作系统的定义与作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——"><span class="nav-number">1.2.1.</span> <span class="nav-text">操作系统是计算机系统中的一个系统软件，是一些程序模块的集合——</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#几个关键词"><span class="nav-number">1.2.2.</span> <span class="nav-text">几个关键词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三个作用"><span class="nav-number">1.2.3.</span> <span class="nav-text">三个作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#资源的管理者"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">资源的管理者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#各种系统服务的提供者"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">各种系统服务的提供者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对硬件机器的扩展"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">对硬件机器的扩展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的主要特征"><span class="nav-number">1.3.</span> <span class="nav-text">操作系统的主要特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发"><span class="nav-number">1.3.1.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享"><span class="nav-number">1.3.2.</span> <span class="nav-text">共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟"><span class="nav-number">1.3.3.</span> <span class="nav-text">虚拟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机"><span class="nav-number">1.3.4.</span> <span class="nav-text">随机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#典型操作系统的架构"><span class="nav-number">1.4.</span> <span class="nav-text">典型操作系统的架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows架构"><span class="nav-number">1.4.1.</span> <span class="nav-text">Windows架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNIX架构"><span class="nav-number">1.4.2.</span> <span class="nav-text">UNIX架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux内核组间"><span class="nav-number">1.4.3.</span> <span class="nav-text">linux内核组间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的分类"><span class="nav-number">1.5.</span> <span class="nav-text">操作系统的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的发展历程"><span class="nav-number">1.5.1.</span> <span class="nav-text">操作系统的发展历程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">目标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传统操作系统的分类"><span class="nav-number">1.5.2.</span> <span class="nav-text">传统操作系统的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#批处理操作系统"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">批处理操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分时系统"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">分时系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过操作系统"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">通过操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实时操作系统"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">实时操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#个人计算机操作系统"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">个人计算机操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络操作系统"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">网络操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式操作系统"><span class="nav-number">1.5.2.7.</span> <span class="nav-text">分布式操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#嵌入式操作系统"><span class="nav-number">1.5.2.8.</span> <span class="nav-text">嵌入式操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#智能卡操作系统"><span class="nav-number">1.5.2.9.</span> <span class="nav-text">智能卡操作系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点"><span class="nav-number">1.6.</span> <span class="nav-text">重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统原理"><span class="nav-number">2.</span> <span class="nav-text">操作系统原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#处理器状态"><span class="nav-number">2.1.</span> <span class="nav-text">处理器状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU"><span class="nav-number">2.1.1.</span> <span class="nav-text">CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#控制和状态寄存器"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">控制和状态寄存器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的需求，保护"><span class="nav-number">2.1.2.</span> <span class="nav-text">操作系统的需求，保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理器的状态"><span class="nav-number">2.1.3.</span> <span class="nav-text">处理器的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特权指令和非特权指令"><span class="nav-number">2.1.4.</span> <span class="nav-text">特权指令和非特权指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例"><span class="nav-number">2.1.5.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU状态之间的转换"><span class="nav-number">2.1.6.</span> <span class="nav-text">CPU状态之间的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中断和异常机制"><span class="nav-number">2.2.</span> <span class="nav-text">中断和异常机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">2.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么引入中断与异常"><span class="nav-number">2.2.2.</span> <span class="nav-text">为什么引入中断与异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件"><span class="nav-number">2.2.3.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">2.2.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工作原理"><span class="nav-number">2.3.</span> <span class="nav-text">工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中断响应"><span class="nav-number">2.3.1.</span> <span class="nav-text">中断响应</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#过程示意"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">过程示意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断向量表"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">中断向量表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过程"><span class="nav-number">2.3.2.</span> <span class="nav-text">过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断处理程序"><span class="nav-number">2.3.3.</span> <span class="nav-text">中断处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-1"><span class="nav-number">2.3.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例：x86处理器"><span class="nav-number">2.4.</span> <span class="nav-text">实例：x86处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x86处理器对中断的支持"><span class="nav-number">2.5.</span> <span class="nav-text">x86处理器对中断的支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统调用机制"><span class="nav-number">2.6.</span> <span class="nav-text">系统调用机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用"><span class="nav-number">2.6.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型系统调用"><span class="nav-number">2.6.2.</span> <span class="nav-text">典型系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统调用机制的设计"><span class="nav-number">2.6.3.</span> <span class="nav-text">系统调用机制的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数传递过程问题"><span class="nav-number">2.6.4.</span> <span class="nav-text">参数传递过程问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行过程"><span class="nav-number">2.6.5.</span> <span class="nav-text">执行过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于x86处理器的linux的系统调用实现"><span class="nav-number">2.7.</span> <span class="nav-text">基于x86处理器的linux的系统调用实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#过程-1"><span class="nav-number">2.7.1.</span> <span class="nav-text">过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用执行流程"><span class="nav-number">2.7.2.</span> <span class="nav-text">调用执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OS底层工作步骤"><span class="nav-number">2.7.3.</span> <span class="nav-text">OS底层工作步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-1"><span class="nav-number">2.8.</span> <span class="nav-text">重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程-线程模型"><span class="nav-number">3.</span> <span class="nav-text">进程/线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程基本概念"><span class="nav-number">3.1.</span> <span class="nav-text">进程基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多道程序设计"><span class="nav-number">3.1.1.</span> <span class="nav-text">多道程序设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发环境与并发程序"><span class="nav-number">3.1.2.</span> <span class="nav-text">并发环境与并发程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的定义"><span class="nav-number">3.1.3.</span> <span class="nav-text">进程的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程控制块PCB"><span class="nav-number">3.1.4.</span> <span class="nav-text">进程控制块PCB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux：task-struct"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">Linux：task_struct</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程状态及状态转换"><span class="nav-number">3.2.</span> <span class="nav-text">进程状态及状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的三种基本状态"><span class="nav-number">3.2.1.</span> <span class="nav-text">进程的三种基本状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三状态模型以及状态转换"><span class="nav-number">3.2.2.</span> <span class="nav-text">三状态模型以及状态转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他状态"><span class="nav-number">3.2.3.</span> <span class="nav-text">其他状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五状态进程模型"><span class="nav-number">3.2.4.</span> <span class="nav-text">五状态进程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七状态进程模型"><span class="nav-number">3.2.5.</span> <span class="nav-text">七状态进程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux状态示意图"><span class="nav-number">3.2.6.</span> <span class="nav-text">linux状态示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程队列"><span class="nav-number">3.2.7.</span> <span class="nav-text">进程队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五状态进程的队列模型"><span class="nav-number">3.2.8.</span> <span class="nav-text">五状态进程的队列模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程控制"><span class="nav-number">3.3.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的创建"><span class="nav-number">3.3.1.</span> <span class="nav-text">进程的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的撤销"><span class="nav-number">3.3.2.</span> <span class="nav-text">进程的撤销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程阻塞"><span class="nav-number">3.3.3.</span> <span class="nav-text">进程阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unix的几个进程控制操作"><span class="nav-number">3.3.4.</span> <span class="nav-text">Unix的几个进程控制操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Unix的FORK-的实现"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">Unix的FORK()的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入理解进程概念"><span class="nav-number">3.4.</span> <span class="nav-text">深入理解进程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于进程的讨论"><span class="nav-number">3.4.1.</span> <span class="nav-text">关于进程的讨论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程与程序的区别"><span class="nav-number">3.4.2.</span> <span class="nav-text">进程与程序的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程地址空间"><span class="nav-number">3.4.3.</span> <span class="nav-text">进程地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例-1"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程地址空间图示"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">进程地址空间图示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程映像"><span class="nav-number">3.4.4.</span> <span class="nav-text">进程映像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文切换"><span class="nav-number">3.4.5.</span> <span class="nav-text">上下文切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的引入"><span class="nav-number">3.5.</span> <span class="nav-text">线程的引入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么在进程中再派生线程？"><span class="nav-number">3.5.1.</span> <span class="nav-text">为什么在进程中再派生线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型的应用"><span class="nav-number">3.5.2.</span> <span class="nav-text">典型的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如果没有线程"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">如果没有线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#web服务器"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">web服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开销的考虑"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">开销的考虑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">3.5.3.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的基本概念"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">线程的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的属性"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">线程的属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程机制的实现"><span class="nav-number">3.6.</span> <span class="nav-text">线程机制的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用户级线程"><span class="nav-number">3.6.1.</span> <span class="nav-text">用户级线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#POSIX线程库"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">POSIX线程库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-2"><span class="nav-number">3.6.1.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心级线程"><span class="nav-number">3.6.2.</span> <span class="nav-text">核心级线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#混合模型"><span class="nav-number">3.6.3.</span> <span class="nav-text">混合模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点小结"><span class="nav-number">3.7.</span> <span class="nav-text">重点小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#处理器调度"><span class="nav-number">4.</span> <span class="nav-text">处理器调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念-1"><span class="nav-number">4.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是处理器调度"><span class="nav-number">4.1.1.</span> <span class="nav-text">什么是处理器调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#要解决的三个问题"><span class="nav-number">4.1.2.</span> <span class="nav-text">要解决的三个问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度的时机"><span class="nav-number">4.1.3.</span> <span class="nav-text">调度的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时机"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程切换"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">进程切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具体步骤"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">具体步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开销"><span class="nav-number">4.1.3.4.</span> <span class="nav-text">开销</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度算法的设计"><span class="nav-number">4.1.4.</span> <span class="nav-text">调度算法的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#衡量指标"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">衡量指标</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计调度算法要考虑的几个问题"><span class="nav-number">4.2.</span> <span class="nav-text">设计调度算法要考虑的几个问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程优先级"><span class="nav-number">4.2.1.</span> <span class="nav-text">进程优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程就绪队列组织"><span class="nav-number">4.2.2.</span> <span class="nav-text">进程就绪队列组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抢占与非抢占"><span class="nav-number">4.2.3.</span> <span class="nav-text">抢占与非抢占</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO密集型与CPU密集型进程"><span class="nav-number">4.2.4.</span> <span class="nav-text">IO密集型与CPU密集型进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间片"><span class="nav-number">4.2.5.</span> <span class="nav-text">时间片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#批处理系统的调度算法"><span class="nav-number">4.3.</span> <span class="nav-text">批处理系统的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#先来先服务"><span class="nav-number">4.3.1.</span> <span class="nav-text">先来先服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#短作业优先"><span class="nav-number">4.3.2.</span> <span class="nav-text">短作业优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最高相应比优先HRRN"><span class="nav-number">4.3.3.</span> <span class="nav-text">最高相应比优先HRRN</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交互式系统的调度算法"><span class="nav-number">4.4.</span> <span class="nav-text">交互式系统的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#轮转调度"><span class="nav-number">4.4.1.</span> <span class="nav-text">轮转调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟轮转法"><span class="nav-number">4.4.2.</span> <span class="nav-text">虚拟轮转法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最高优先级调度"><span class="nav-number">4.4.3.</span> <span class="nav-text">最高优先级调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级反转"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">优先级反转</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多级反馈队列调度算法、各种调度算法小结等"><span class="nav-number">4.5.</span> <span class="nav-text">多级反馈队列调度算法、各种调度算法小结等</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多级反馈队列调度算法"><span class="nav-number">4.5.1.</span> <span class="nav-text">多级反馈队列调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-3"><span class="nav-number">4.5.2.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多处理器调度算法设计"><span class="nav-number">4.5.3.</span> <span class="nav-text">多处理器调度算法设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#典型操作系统的调度算法"><span class="nav-number">4.6.</span> <span class="nav-text">典型操作系统的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LINUX调度算法的发展历史"><span class="nav-number">4.6.1.</span> <span class="nav-text">LINUX调度算法的发展历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows线程调度"><span class="nav-number">4.6.2.</span> <span class="nav-text">Windows线程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的时间配额"><span class="nav-number">4.6.3.</span> <span class="nav-text">线程的时间配额</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度策略"><span class="nav-number">4.6.4.</span> <span class="nav-text">调度策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#抢占"><span class="nav-number">4.6.4.1.</span> <span class="nav-text">抢占</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间配额用完"><span class="nav-number">4.6.4.2.</span> <span class="nav-text">时间配额用完</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程优先级与时间配额调整"><span class="nav-number">4.6.5.</span> <span class="nav-text">线程优先级与时间配额调整</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程优先级提升"><span class="nav-number">4.6.5.1.</span> <span class="nav-text">线程优先级提升</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-2"><span class="nav-number">4.7.</span> <span class="nav-text">重点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本讲重点"><span class="nav-number">4.7.1.</span> <span class="nav-text">本讲重点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#要求"><span class="nav-number">4.7.2.</span> <span class="nav-text">要求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步机制1"><span class="nav-number">5.</span> <span class="nav-text">同步机制1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的并发执行"><span class="nav-number">5.1.</span> <span class="nav-text">进程的并发执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程并发执行"><span class="nav-number">5.1.1.</span> <span class="nav-text">进程并发执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#从进程的特征触发"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">从进程的特征触发</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发执行过程分析"><span class="nav-number">5.1.2.</span> <span class="nav-text">并发执行过程分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程前趋图"><span class="nav-number">5.1.3.</span> <span class="nav-text">进程前趋图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程互斥"><span class="nav-number">5.2.</span> <span class="nav-text">进程互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#竞争条件"><span class="nav-number">5.2.1.</span> <span class="nav-text">竞争条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-2"><span class="nav-number">5.2.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#临界区的使用原则"><span class="nav-number">5.2.3.</span> <span class="nav-text">临界区的使用原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决方案"><span class="nav-number">5.2.4.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件解决方案"><span class="nav-number">5.3.</span> <span class="nav-text">软件解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法1"><span class="nav-number">5.3.1.</span> <span class="nav-text">解法1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法2"><span class="nav-number">5.3.2.</span> <span class="nav-text">解法2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法3"><span class="nav-number">5.3.3.</span> <span class="nav-text">解法3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法4：DEKKER算法"><span class="nav-number">5.3.4.</span> <span class="nav-text">解法4：DEKKER算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法5：PETTERSON算法"><span class="nav-number">5.3.5.</span> <span class="nav-text">解法5：PETTERSON算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程互斥的硬件解决方法"><span class="nav-number">5.4.</span> <span class="nav-text">进程互斥的硬件解决方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中断屏蔽方法"><span class="nav-number">5.4.1.</span> <span class="nav-text">中断屏蔽方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“测试并加锁”指令"><span class="nav-number">5.4.2.</span> <span class="nav-text">“测试并加锁”指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换指令"><span class="nav-number">5.4.3.</span> <span class="nav-text">交换指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结-4"><span class="nav-number">5.5.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的同步"><span class="nav-number">5.6.</span> <span class="nav-text">进程的同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者消费者问题"><span class="nav-number">5.6.1.</span> <span class="nav-text">生产者消费者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题描述"><span class="nav-number">5.6.1.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#要解决的问题："><span class="nav-number">5.6.1.2.</span> <span class="nav-text">要解决的问题：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决"><span class="nav-number">5.6.1.3.</span> <span class="nav-text">解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码实现"><span class="nav-number">5.6.1.4.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他例子"><span class="nav-number">5.6.2.</span> <span class="nav-text">其他例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量及P、V操作"><span class="nav-number">5.7.</span> <span class="nav-text">信号量及P、V操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#P，V操作定义"><span class="nav-number">5.7.1.</span> <span class="nav-text">P，V操作定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有关说明"><span class="nav-number">5.7.1.1.</span> <span class="nav-text">有关说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PV操作解决进行间互斥问题"><span class="nav-number">5.7.2.</span> <span class="nav-text">PV操作解决进行间互斥问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者消费者问题-1"><span class="nav-number">5.8.</span> <span class="nav-text">生产者消费者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用信号量的解法"><span class="nav-number">5.8.1.</span> <span class="nav-text">用信号量的解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#讨论"><span class="nav-number">5.8.2.</span> <span class="nav-text">讨论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读者写者问题"><span class="nav-number">5.9.</span> <span class="nav-text">读者写者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量解法"><span class="nav-number">5.9.1.</span> <span class="nav-text">信号量解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一类问题，读者优先"><span class="nav-number">5.9.2.</span> <span class="nav-text">第一类问题，读者优先</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法"><span class="nav-number">5.9.2.1.</span> <span class="nav-text">解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化"><span class="nav-number">5.9.2.2.</span> <span class="nav-text">优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LINUX提供的读写锁"><span class="nav-number">5.9.3.</span> <span class="nav-text">LINUX提供的读写锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-3"><span class="nav-number">5.10.</span> <span class="nav-text">重点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#要求-1"><span class="nav-number">5.10.1.</span> <span class="nav-text">要求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步互斥机制2"><span class="nav-number">6.</span> <span class="nav-text">同步互斥机制2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#管程的基本概念"><span class="nav-number">6.1.</span> <span class="nav-text">管程的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么会出现管程"><span class="nav-number">6.1.1.</span> <span class="nav-text">为什么会出现管程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">6.1.2.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有什么保证"><span class="nav-number">6.1.3.</span> <span class="nav-text">有什么保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#会遇到什么问题"><span class="nav-number">6.1.4.</span> <span class="nav-text">会遇到什么问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hoare管程"><span class="nav-number">6.2.</span> <span class="nav-text">Hoare管程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#说明"><span class="nav-number">6.2.1.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件变量的实现"><span class="nav-number">6.2.2.</span> <span class="nav-text">条件变量的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管程的实现"><span class="nav-number">6.3.</span> <span class="nav-text">管程的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#管程解决生产者消费者问题"><span class="nav-number">6.3.1.</span> <span class="nav-text">管程解决生产者消费者问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者消费者"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">生产者消费者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管程的实现-1"><span class="nav-number">6.3.1.2.</span> <span class="nav-text">管程的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java有类似管程的机制"><span class="nav-number">6.3.2.</span> <span class="nav-text">java有类似管程的机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MESA管程"><span class="nav-number">6.4.</span> <span class="nav-text">MESA管程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用NOTIFY要注意的问题"><span class="nav-number">6.4.1.</span> <span class="nav-text">使用NOTIFY要注意的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决生产者消费者问题"><span class="nav-number">6.4.2.</span> <span class="nav-text">解决生产者消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改进"><span class="nav-number">6.4.3.</span> <span class="nav-text">改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引入BROADCAST"><span class="nav-number">6.4.4.</span> <span class="nav-text">引入BROADCAST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较"><span class="nav-number">6.4.5.</span> <span class="nav-text">比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结-5"><span class="nav-number">6.4.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PTHREAD中的同步机制"><span class="nav-number">6.5.</span> <span class="nav-text">PTHREAD中的同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者消费者问题-2"><span class="nav-number">6.5.1.</span> <span class="nav-text">生产者消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cond-wait"><span class="nav-number">6.5.2.</span> <span class="nav-text">cond_wait</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信"><span class="nav-number">6.6.</span> <span class="nav-text">进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么需要通信机制？"><span class="nav-number">6.6.1.</span> <span class="nav-text">为什么需要通信机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本通信方式"><span class="nav-number">6.6.2.</span> <span class="nav-text">基本通信方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息传递"><span class="nav-number">6.6.3.</span> <span class="nav-text">消息传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PV操作的实现send"><span class="nav-number">6.6.3.1.</span> <span class="nav-text">PV操作的实现send</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道"><span class="nav-number">6.6.4.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#套接字"><span class="nav-number">6.6.5.</span> <span class="nav-text">套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程过程调用"><span class="nav-number">6.6.6.</span> <span class="nav-text">远程过程调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#典型操作系统中的IPC机制"><span class="nav-number">6.7.</span> <span class="nav-text">典型操作系统中的IPC机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-2"><span class="nav-number">6.7.1.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux的进程通信机制"><span class="nav-number">6.7.2.</span> <span class="nav-text">Linux的进程通信机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原子操作"><span class="nav-number">6.7.2.1.</span> <span class="nav-text">原子操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#屏障：栅栏"><span class="nav-number">6.7.2.2.</span> <span class="nav-text">屏障：栅栏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点-4"><span class="nav-number">6.8.</span> <span class="nav-text">重点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重点阅读和概念"><span class="nav-number">6.8.1.</span> <span class="nav-text">重点阅读和概念</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#存储管理"><span class="nav-number">7.</span> <span class="nav-text">存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念：地址重定位"><span class="nav-number">7.1.</span> <span class="nav-text">基本概念：地址重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本内容"><span class="nav-number">7.1.1.</span> <span class="nav-text">基本内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#需要解决的问题"><span class="nav-number">7.1.2.</span> <span class="nav-text">需要解决的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程地址空间-1"><span class="nav-number">7.1.3.</span> <span class="nav-text">进程地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#讨论-1"><span class="nav-number">7.1.4.</span> <span class="nav-text">讨论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址重定位"><span class="nav-number">7.1.5.</span> <span class="nav-text">地址重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑地址"><span class="nav-number">7.1.5.1.</span> <span class="nav-text">逻辑地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物理地址"><span class="nav-number">7.1.5.2.</span> <span class="nav-text">物理地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地址重定位-1"><span class="nav-number">7.1.5.3.</span> <span class="nav-text">地址重定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态重定位与动态重定位"><span class="nav-number">7.1.6.</span> <span class="nav-text">静态重定位与动态重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态重定位实现"><span class="nav-number">7.1.6.1.</span> <span class="nav-text">动态重定位实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理内存管理"><span class="nav-number">7.2.</span> <span class="nav-text">物理内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#空闲内存管理"><span class="nav-number">7.2.1.</span> <span class="nav-text">空闲内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配算法"><span class="nav-number">7.2.2.</span> <span class="nav-text">内存分配算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回收问题"><span class="nav-number">7.2.3.</span> <span class="nav-text">回收问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#伙伴系统"><span class="nav-number">7.3.</span> <span class="nav-text">伙伴系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">7.3.1.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本内存管理方案"><span class="nav-number">7.4.</span> <span class="nav-text">基本内存管理方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一连续区"><span class="nav-number">7.4.1.</span> <span class="nav-text">单一连续区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#固定分区"><span class="nav-number">7.4.2.</span> <span class="nav-text">固定分区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例"><span class="nav-number">7.4.2.1.</span> <span class="nav-text">案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变分区"><span class="nav-number">7.4.3.</span> <span class="nav-text">可变分区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题"><span class="nav-number">7.4.3.1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#碎片问题解决"><span class="nav-number">7.4.3.2.</span> <span class="nav-text">碎片问题解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页式"><span class="nav-number">7.4.4.</span> <span class="nav-text">页式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#管理方案"><span class="nav-number">7.4.4.1.</span> <span class="nav-text">管理方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存分配过程"><span class="nav-number">7.4.4.2.</span> <span class="nav-text">内存分配过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关数据结构及地址转换"><span class="nav-number">7.4.4.3.</span> <span class="nav-text">相关数据结构及地址转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段式"><span class="nav-number">7.4.5.</span> <span class="nav-text">段式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相关数据结构及地址转换-1"><span class="nav-number">7.4.5.1.</span> <span class="nav-text">相关数据结构及地址转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段页式"><span class="nav-number">7.4.6.</span> <span class="nav-text">段页式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交换技术（Swapping）"><span class="nav-number">7.5.</span> <span class="nav-text">交换技术（Swapping）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存不足时如何管理"><span class="nav-number">7.5.1.</span> <span class="nav-text">内存不足时如何管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存“扩充”技术"><span class="nav-number">7.5.2.</span> <span class="nav-text">内存“扩充”技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖技术"><span class="nav-number">7.5.3.</span> <span class="nav-text">覆盖技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例"><span class="nav-number">7.5.3.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换技术"><span class="nav-number">7.5.4.</span> <span class="nav-text">交换技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关于讨论的问题"><span class="nav-number">7.5.4.1.</span> <span class="nav-text">关于讨论的问题</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lily</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  

  

  

  

  


</body>
</html>

<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="ArrayList源码详解">
<meta property="og:type" content="article">
<meta property="og:title" content="ArrayList源码详解">
<meta property="og:url" content="http://yoursite.com/2017/04/02/源码系列/ArrayList源码详解/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="ArrayList源码详解">
<meta property="og:image" content="http://i.imgur.com/QnFJ42J.jpg">
<meta property="og:image" content="http://i.imgur.com/bXLpkEf.jpg">
<meta property="og:image" content="http://i.imgur.com/YD1v0xi.jpg">
<meta property="og:image" content="http://i.imgur.com/FxyZnqP.jpg">
<meta property="og:image" content="http://i.imgur.com/R3NedP0.jpg">
<meta property="og:updated_time" content="2017-04-02T13:59:16.982Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ArrayList源码详解">
<meta name="twitter:description" content="ArrayList源码详解">
<meta name="twitter:image" content="http://i.imgur.com/QnFJ42J.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/02/源码系列/ArrayList源码详解/"/>





  <title> ArrayList源码详解 | Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/02/源码系列/ArrayList源码详解/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="lily">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Hexo" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ArrayList源码详解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-02T21:55:40+08:00">
                2017-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>ArrayList源码详解<br><a id="more"></a> </p>
<h1 id="ArrayList详解"><a href="#ArrayList详解" class="headerlink" title="ArrayList详解"></a>ArrayList详解</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="http://i.imgur.com/QnFJ42J.jpg" alt=""></p>
<h2 id="已经介绍过的类和接口"><a href="#已经介绍过的类和接口" class="headerlink" title="已经介绍过的类和接口"></a>已经介绍过的类和接口</h2><pre><code>Iterable
Collection
List
</code></pre><h2 id="未介绍的类和接口"><a href="#未介绍的类和接口" class="headerlink" title="未介绍的类和接口"></a>未介绍的类和接口</h2><h3 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h3><p>实现所使用的标记接口，用来表明其支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。</p>
<h3 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h3><p>Cloneable接口是一个标记接口,也就是没有任何内容，clone方法是在Object种定义的,而且是protected型的,只有实现了这个接口,才可以在该类的实例上调用clone方法,否则会抛出CloneNotSupportException，但是此方法是浅拷贝而非深拷贝</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>当一个类实现了Seializable接口（该接口仅为标记接口，不包含任何方法定义），表示该类可以序列化，序列化的目的是将一个实现了Serializable接口的对象可以转换成一个字节序列，保存对象的状态。</p>
<p>把该字节序列保存起来（例如：保存在一个文件里），以后可以随时将该字节序列恢复为原来的对象。甚至可以将该字节序列放到其他计算机上或者通过网络传输到其他计算机上恢复，只有该计算机平台存在相应的类就可以正常恢复为原来的对象。</p>
<p>一个对象实现Serializable接口序列化，先要创建某些OutputStream对象，然后将其封装在一个ObjectOutputStream对象内，再调用writeObject（）方法，即可序列化一个对象，反序列化，InputStream，再调用readObject（）方法。（writeObject和readObject本身就是线程安全的，传输过程中是不允许被并发访问的，所以对象只能一个一个接连不断的传过来）。</p>
<h3 id="AbstractCollection"><a href="#AbstractCollection" class="headerlink" title="AbstractCollection"></a>AbstractCollection</h3><p><img src="http://i.imgur.com/bXLpkEf.jpg" alt=""></p>
<hr>
<p>AbstractCollection 是 Java 集合框架中 Collection 接口 的一个直接实现类<br>它实现了一些方法，也定义了几个抽象方法留给子类实现，因此它是一个抽象类。</p>
<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><pre><code>public abstract Iterator&lt;E&gt; iterator();
public abstract int size();
public boolean add(E object) {
        throw new UnsupportedOperationException();//直接调用会报错，需要子类去实现
}
</code></pre><h4 id="实现的方法"><a href="#实现的方法" class="headerlink" title="实现的方法"></a>实现的方法</h4><pre><code>//addAll() 添加一个集合内的全部元素:  
public boolean addAll(Collection&lt;? extends E&gt; collection) {
    boolean result = false;
    //获取待添加对象的迭代器
    Iterator&lt;? extends E&gt; it = collection.iterator();
    while (it.hasNext()) {
        //挨个遍历，调用 add() 方法添加，因此如果没有实现 add(E) 方法，addAll() 也不能用
        if (add(it.next())) {
            result = true;
        }
    }
    return result;
}
</code></pre><hr>
<pre><code>//clear() 删除所有元素：
public void clear() {
    //获取子类实现的迭代器，挨个遍历，删除
    Iterator&lt;E&gt; it = iterator();
    while (it.hasNext()) {
        it.next();
        //单线程使用迭代器的 remove() 方法不会导致 fail-fast
        it.remove();
    }
}
</code></pre><hr>
<pre><code>//contains() 是否包含某个元素：
//获取子类实现的迭代器，挨个遍历，比较
public boolean contains(Object object) {
    Iterator&lt;E&gt; it = iterator();
    if (object != null) {
        while (it.hasNext()) {
            //这个元素的类 需要重写 equals() 方法，不然结果难说
            if (object.equals(it.next())) {
                return true;
            }
        }
    } else {
        //目标元素是空也能查找，说明 AbstractCollection 默认是支持元素为 null 的
        while (it.hasNext()) {
            if (it.next() == null) {
                return true;
            }
        }
    }
    return false;
}
</code></pre><hr>
<pre><code>//containsAll() 是否包含指定集合中的全部元素:
public boolean containsAll(Collection&lt;?&gt; collection) {
    Iterator&lt;?&gt; it = collection.iterator();
    //挨个遍历指定集合
    while (it.hasNext()) {
        //contails 里也是遍历，双重循环，O(n^2)
        if (!contains(it.next())) {
            return false;
        }
    }
    return true;
}
</code></pre><hr>
<pre><code>//isEmpty() 是否为空:
public boolean isEmpty() {
    //调用子类实现的 size() 方法
    return size() == 0;
}
</code></pre><hr>
<pre><code>//remove() 删除某个元素:
public boolean remove(Object object) {
    //获取子类实现的 迭代器
    Iterator&lt;?&gt; it = iterator();
    if (object != null) {
        while (it.hasNext()) {
            if (object.equals(it.next())) {
                it.remove();
                return true;
            }
        }
    } else {
        while (it.hasNext()) {
            if (it.next() == null) {
                it.remove();
                return true;
            }
        }
    }
    return false;
}
</code></pre><hr>
<pre><code>//removeAll() 删除指定集合中包含在本集合的元素：
public boolean removeAll(Collection&lt;?&gt; collection) {
    boolean result = false;
    Iterator&lt;?&gt; it = iterator();
    while (it.hasNext()) {
        //双重循环
        if (collection.contains(it.next())) {
            it.remove();
            result = true;
        }
    }
    return result;
}
</code></pre><hr>
<pre><code>//retainAll() 保留共有的，删除指定集合中不共有的：
public boolean retainAll(Collection&lt;?&gt; collection) {
    boolean result = false;
    Iterator&lt;?&gt; it = iterator();
    while (it.hasNext()) {
        //排除异己，不在我集合中的统统删掉
        if (!collection.contains(it.next())) {
            it.remove();
            result = true;
        }
    }
    return result;
}
</code></pre><hr>
<pre><code>//toArray(), toArray(T[] contents) 转换成数组：
public Object[] toArray() {
//把集合转换成 ArrayList，然后再调用 ArrayList.toArray() 
    return toArrayList().toArray();
}

public &lt;T&gt; T[] toArray(T[] contents) {
    return toArrayList().toArray(contents);
}

@SuppressWarnings(&quot;unchecked&quot;)
private ArrayList&lt;Object&gt; toArrayList() {
    ArrayList&lt;Object&gt; result = new ArrayList&lt;Object&gt;(size());
    for (E entry : this) {
        result.add(entry);
    }
    return result;
}
</code></pre><hr>
<pre><code>//toString() 把内容转换成一个 String 进行展示:
public String toString() {
    if (isEmpty()) {
        return &quot;[]&quot;;
    }
    //注意默认容量是 size() 的 16 倍
    StringBuilder buffer = new StringBuilder(size() * 16);
    buffer.append(&apos;[&apos;);
    //仍旧用到了迭代器
    Iterator&lt;?&gt; it = iterator();
    while (it.hasNext()) {
        Object next = it.next();
        if (next != this) {
            //这个 Object 也得重写 toString() 方法，不然不能输出内容
            buffer.append(next);
        } else {
            buffer.append(&quot;(this Collection)&quot;);
        }
        if (it.hasNext()) {
            buffer.append(&quot;, &quot;);
        }
    }
    buffer.append(&apos;]&apos;);
    return buffer.toString();
}
</code></pre><h4 id="其它要点"><a href="#其它要点" class="headerlink" title="其它要点"></a>其它要点</h4><pre><code>AbstractCollection 默认的构造函数是 protected:
protected AbstractCollection() {
}
The programmer should generally provide a void (no argument) and Collection constructor, as per the recommendation in the Collection interface specification.
</code></pre><hr>
<pre><code>AbstractCollection 的 add(E) 方法默认是抛出异常，这样会不会容易导致问题？为什么不定义为抽象方法？

如果你想修改一个不可变的集合时，抛出 UnsupportedOperationException 是标准的行为，比如 当你用 Collections.unmodifiableXXX() 方法对某个集合进行处理后，再调用这个集合的 修改方法（add,remove,set…），都会报这个错；
因此 AbstractCollection.add(E) 抛出这个错误是准从标准；

不要给客户端暴露不需要的方法。
</code></pre><h3 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList"></a>AbstractList</h3><p>AbstractList 继承自 AbstractCollection 抽象类，实现了 List 接口 ，是 ArrayList 和 AbstractSequentiaList 的父类。<br>它实现了 List 的一些位置相关操作(比如 get,set,add,remove)，是第一个实现随机访问方法的集合类，但不支持添加和替换。<br><img src="http://i.imgur.com/YD1v0xi.jpg" alt=""></p>
<h4 id="对-AbstractCollection抽象方法的实现"><a href="#对-AbstractCollection抽象方法的实现" class="headerlink" title="对 AbstractCollection抽象方法的实现"></a>对 AbstractCollection抽象方法的实现</h4><pre><code>public Iterator&lt;E&gt; iterator() {
    return new Itr();
}
public int size();//仍然没有实现
</code></pre><h4 id="抽象方法或者子类必须自己实现的方法"><a href="#抽象方法或者子类必须自己实现的方法" class="headerlink" title="抽象方法或者子类必须自己实现的方法"></a>抽象方法或者子类必须自己实现的方法</h4><pre><code>public int size();//继承自父类

public abstract E get(int location);

public void add(int index, E element) {
        throw new UnsupportedOperationException();
    }

public E remove(int index) {
        throw new UnsupportedOperationException();
    }

public E set(int index, E element) {
        throw new UnsupportedOperationException();
    }
</code></pre><h4 id="实现的方法-1"><a href="#实现的方法-1" class="headerlink" title="实现的方法"></a>实现的方法</h4><pre><code>//indexOf(Object) 获取指定对象 首次出现 的索引：
public int indexOf(Object o) {
    //获取 ListIterator，此时游标位置为 0 
    ListIterator&lt;E&gt; it = listIterator();
    if (o==null) {
        //向后遍历
        while (it.hasNext())
            if (it.next()==null)
                //返回游标的前面元素索引
                return it.previousIndex();
    } else {
        while (it.hasNext())
            if (o.equals(it.next()))
                return it.previousIndex();
    }
    return -1;
}
//每次调用 listIterator.next() 方法 游标 都会后移一位，当 listIterator.next() == o 时（即找到我们需要的的元素），游标已经在 o 的后面，所以需要返回 游标的 previousIndex().
</code></pre><hr>
<pre><code>//lastIndexOf(Object) 获取指定对象最后一次出现的位置:
public int lastIndexOf(Object o) {
    //获取 ListIterator，此时游标在最后一位
    ListIterator&lt;E&gt; it = listIterator(size());
    if (o==null) {
        //向前遍历
        while (it.hasPrevious())
            if (it.previous()==null)
                //返回 it.nextIndex() 原因类似 2
                return it.nextIndex();
    } else {
        while (it.hasPrevious())
            if (o.equals(it.previous()))
                return it.nextIndex();
    }
    return -1;
}
</code></pre><hr>
<pre><code>//clear(), removeRange(int, int), 全部/范围 删除元素：
public void clear() {
    //传入由子类实现的 size()
    removeRange(0, size());
}

protected void removeRange(int fromIndex, int toIndex) {
    //获取 ListIterator 来进行迭代删除
    ListIterator&lt;E&gt; it = listIterator(fromIndex);
    for (int i=0, n=toIndex-fromIndex; i&lt;n; i++) {
        it.next();
        it.remove();
    }
}
</code></pre><hr>
<pre><code>//添加一组元素
public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
    rangeCheckForAdd(index);
    boolean modified = false;
    for (E e : c) {
        add(index++, e);
        modified = true;
    }
    return modified;
}
</code></pre><h4 id="两种内部迭代器"><a href="#两种内部迭代器" class="headerlink" title="两种内部迭代器"></a>两种内部迭代器</h4><p>AbstractList 内部已经提供了 Iterator, ListIterator 迭代器的实现类，分别为 Itr, ListItr</p>
<pre><code>//Itr 代码分析：
private class Itr implements Iterator&lt;E&gt; {
    //游标
    int cursor = 0;

    //上一次迭代到的元素的位置，每次使用完就会置为 -1
    int lastRet = -1;

    //用来判断是否发生并发操作的标示，如果这两个值不一致，就会报错
    int expectedModCount = modCount;

    public boolean hasNext() {
        return cursor != size();
    }

    public E next() {
        //时刻检查是否有并发修改操作
        checkForComodification();
        try {
            int i = cursor;
            //调用 子类实现的 get() 方法获取元素
            E next = get(i);
            //有迭代操作后就会记录上次迭代的位置
            lastRet = i;
            cursor = i + 1;
            return next;
        } catch (IndexOutOfBoundsException e) {
            checkForComodification();
            throw new NoSuchElementException();
        }
    }

    public void remove() {
        if (lastRet &lt; 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            //调用需要子类实现的 remove()方法
            AbstractList.this.remove(lastRet);
            if (lastRet &lt; cursor)
                cursor--;
            //删除后 上次迭代的记录就会置为 -1
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException e) {
            throw new ConcurrentModificationException();
        }
    }

    //检查是否有并发修改
    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}
</code></pre><hr>
<pre><code>//ListItr 代码分析:
//ListItr 是 Itr 的增强版
private class ListItr extends Itr implements ListIterator&lt;E&gt; {
    //构造函数没有检查index 是否！
    ListItr(int index) {
        cursor = index;
    }

    //除了一开始都有前面元素
    public boolean hasPrevious() {
        return cursor != 0;
    }

    public E previous() {
        checkForComodification();
        try {
            //获取游标前面一位元素
            int i = cursor - 1;
            E previous = get(i);
            lastRet = cursor = i;
            return previous;
        } catch (IndexOutOfBoundsException e) {
            checkForComodification();
            throw new NoSuchElementException();
        }
    }

    //下一个元素的位置就是当前游标所在位置
    public int nextIndex() {
        return cursor;
    }

    public int previousIndex() {
        return cursor-1;
    }

    public void set(E e) {
        if (lastRet &lt; 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            //子类得检查 lasRet 是否为 -1
            AbstractList.this.set(lastRet, e);
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    public void add(E e) {
        checkForComodification();

        try {
            int i = cursor;
            AbstractList.this.add(i, e);
            //又置为 -1 了
            lastRet = -1;
            cursor = i + 1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }
}
</code></pre><p>Iter和ListItr都在避免并发修改上做出了大量的努力，极力避免不安全的使用容器的行为</p>
<h4 id="两种内部类"><a href="#两种内部类" class="headerlink" title="两种内部类"></a>两种内部类</h4><p>在 subList 方法中我们发现在切分 子序列时会分为两类，RandomAccess or not：</p>
<p>在获得了一个List的subList视图之后，如果对List中的元素进行了改变List的size的操作，再次操作subList，就会抛出ConcurrentModificationException异常，此处需要注意</p>
<p>SubList 就是吭老族，虽然自立门户，等到要干活时，使用的都是父类的方法，父类的数据。</p>
<pre><code>public List&lt;E&gt; subList(int fromIndex, int toIndex) {
    return (this instanceof RandomAccess ?
            new RandomAccessSubList&lt;&gt;(this, fromIndex, toIndex) :
            new SubList&lt;&gt;(this, fromIndex, toIndex));
}
</code></pre><hr>
<pre><code>// AbstractList 的子类，表示父 List 的一部分
class SubList&lt;E&gt; extends AbstractList&lt;E&gt; {
    private final AbstractList&lt;E&gt; l;
    private final int offset;
    private int size;

//构造参数:
//list ：父 List
//fromIndex : 从父 List 中开始的位置
//toIndex : 在父 List 中哪里结束
SubList(AbstractList&lt;E&gt; list, int fromIndex, int toIndex) {
    if (fromIndex &lt; 0)
        throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);
    if (toIndex &gt; list.size())
        throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);
    if (fromIndex &gt; toIndex)
        throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +
                                           &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);
    l = list;
    offset = fromIndex;
    size = toIndex - fromIndex;
    //和父类使用同一个 modCount
    this.modCount = l.modCount;
}

//使用父类的 set()
public E set(int index, E element) {
    rangeCheck(index);
    checkForComodification();
    return l.set(index+offset, element);
}

//使用父类的 get()
public E get(int index) {
    rangeCheck(index);
    checkForComodification();
    return l.get(index+offset);
}

//子 List 的大小
public int size() {
    checkForComodification();
    return size;
}

public void add(int index, E element) {
    rangeCheckForAdd(index);
    checkForComodification();
    //根据子 List 开始的位置，加上偏移量，直接在父 List 上进行添加
    l.add(index+offset, element);
    this.modCount = l.modCount;
    size++;
}

public E remove(int index) {
    rangeCheck(index);
    checkForComodification();
    //根据子 List 开始的位置，加上偏移量，直接在父 List 上进行删除
    E result = l.remove(index+offset);
    this.modCount = l.modCount;
    size--;
    return result;
}

protected void removeRange(int fromIndex, int toIndex) {
    checkForComodification();
    //调用父类的 局部删除
    l.removeRange(fromIndex+offset, toIndex+offset);
    this.modCount = l.modCount;
    size -= (toIndex-fromIndex);
}

public boolean addAll(Collection&lt;? extends E&gt; c) {
    return addAll(size, c);
}

public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
    rangeCheckForAdd(index);
    int cSize = c.size();
    if (cSize==0)
        return false;

    checkForComodification();
    //还是使用的父类 addAll()
    l.addAll(offset+index, c);
    this.modCount = l.modCount;
    size += cSize;
    return true;
}

public Iterator&lt;E&gt; iterator() {
    return listIterator();
}

public ListIterator&lt;E&gt; listIterator(final int index) {
    checkForComodification();
    rangeCheckForAdd(index);

    //创建一个 匿名内部 ListIterator，指向的还是 父类的 listIterator
    return new ListIterator&lt;E&gt;() {
        private final ListIterator&lt;E&gt; i = l.listIterator(index+offset);

        public boolean hasNext() {
            return nextIndex() &lt; size;
        }

        public E next() {
            if (hasNext())
                return i.next();
            else
                throw new NoSuchElementException();
        }

        public boolean hasPrevious() {
            return previousIndex() &gt;= 0;
        }

        public E previous() {
            if (hasPrevious())
                return i.previous();
            else
                throw new NoSuchElementException();
        }

        public int nextIndex() {
            return i.nextIndex() - offset;
        }

        public int previousIndex() {
            return i.previousIndex() - offset;
        }

        public void remove() {
            i.remove();
            SubList.this.modCount = l.modCount;
            size--;
        }

        public void set(E e) {
            i.set(e);
        }

        public void add(E e) {
            i.add(e);
            SubList.this.modCount = l.modCount;
            size++;
        }
    };
}

public List&lt;E&gt; subList(int fromIndex, int toIndex) {
    return new SubList&lt;&gt;(this, fromIndex, toIndex);
}

private void rangeCheck(int index) {
    if (index &lt; 0 || index &gt;= size)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

private void rangeCheckForAdd(int index) {
    if (index &lt; 0 || index &gt; size)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

private String outOfBoundsMsg(int index) {
    return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;
}

private void checkForComodification() {
    if (this.modCount != l.modCount)
        throw new ConcurrentModificationException();
}
}
</code></pre><hr>
<pre><code>RandomAccessSubList 源码：

class RandomAccessSubList&lt;E&gt; extends SubList&lt;E&gt; implements RandomAccess {
    RandomAccessSubList(AbstractList&lt;E&gt; list, int fromIndex, int toIndex) {
        super(list, fromIndex, toIndex);
    }

    public List&lt;E&gt; subList(int fromIndex, int toIndex) {
        return new RandomAccessSubList&lt;&gt;(this, fromIndex, toIndex);
    }
}
</code></pre><h2 id="ArrayList实现"><a href="#ArrayList实现" class="headerlink" title="ArrayList实现"></a>ArrayList实现</h2><pre><code>ArrayList 是 Java 集合框架中 List接口 的一个实现类。

可以说 ArrayList 是我们使用最多的 List 集合，它有以下特点：

    容量不固定，想放多少放多少（当然有最大阈值，但一般达不到）
    有序的（元素输出顺序与输入顺序一致）
    元素可以为 null
    效率高 
    size(), isEmpty(), get(), set() iterator(), ListIterator() 方法的时间复杂度都是 O(1)

    add() 添加操作的时间复杂度平均为 O(n)
    其他所有操作的时间复杂度几乎都是 O(n)
    占用空间更小 
    对比 LinkedList，不用占用额外空间维护链表结构
</code></pre><p><img src="http://i.imgur.com/FxyZnqP.jpg" alt=""><br><img src="http://i.imgur.com/R3NedP0.jpg" alt=""></p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><pre><code>底层数据结构，数组：

transient Object[] elementData
由于数组类型为 Object，所以允许添加 null 。 
transient 说明这个数组无法序列化。 
初始时为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 。

默认的空数组：

private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

private static final Object[] EMPTY_ELEMENTDATA = {};
不清楚它俩啥区别。
</code></pre><hr>
<pre><code>数组初始容量为 10：

private static final int DEFAULT_CAPACITY = 10;
</code></pre><hr>
<pre><code>数组中当前元素个数：
private int size;
size &lt;= capacity
</code></pre><hr>
<pre><code>数组最大容量：
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
Integer.MAX_VALUE = 0x7fffffff

换算成二进制： 2^31 - 1，1111111111111111111111111111111

十进制就是 ：2147483647，二十一亿多。

一些虚拟器需要在数组前加个 头标签，所以减去 8 。 
当想要分配比 MAX_ARRAY_SIZE 大的个数就会报 OutOfMemoryError。
</code></pre><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><pre><code>//初始为空数组
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}

//根据指定容量，创建个对象数组
public ArrayList(int initialCapacity) {
    if (initialCapacity &gt; 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    }
}

//直接创建和指定集合一样内容的 ArrayList
public ArrayList(Collection&lt;? extends E&gt; c) {
    elementData = c.toArray();
    if ((size = elementData.length) != 0) {
        // c.toArray 有可能不返回一个 Object 数组
        if (elementData.getClass() != Object[].class)
            //使用 Arrays.copy 方法拷创建一个 Object 数组
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    } else {
        // replace with empty array.
        this.elementData = EMPTY_ELEMENTDATA;
    }
}
</code></pre><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><pre><code>public boolean add(E e) {
    //对数组的容量进行调整
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

//在指定位置添加一个元素
public void add(int index, E element) {
    rangeCheckForAdd(index);

    //对数组的容量进行调整
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    //由于是基于数组实现，所以index后面所有元素向后移动一位
    System.arraycopy(elementData, index, elementData, index + 1,
                     size - index);
    elementData[index] = element;
    size++;
}

//添加一个集合
public boolean addAll(Collection&lt;? extends E&gt; c) {
    //把该集合转为对象数组
    Object[] a = c.toArray();
    int numNew = a.length;
    //增加容量
    ensureCapacityInternal(size + numNew);  // Increments modCount
    //挨个向后迁移
    System.arraycopy(a, 0, elementData, size, numNew);
    size += numNew;
    //新数组有元素，就返回 true
    return numNew != 0;
}

//在指定位置，添加一个集合
public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
    rangeCheckForAdd(index);

    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacityInternal(size + numNew);  // Increments modCount

    int numMoved = size - index;
    //原来的数组挨个向后迁移
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index, elementData, index + numNew,
                         numMoved);
    //把新的集合数组 添加到指定位置
    System.arraycopy(a, 0, elementData, index, numNew);
    size += numNew;
    return numNew != 0;
}
</code></pre><h4 id="对数组的容量进行调整："><a href="#对数组的容量进行调整：" class="headerlink" title="对数组的容量进行调整："></a>对数组的容量进行调整：</h4><pre><code>public void ensureCapacity(int minCapacity) {
    int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
        // 不是默认的数组，说明已经添加了元素
        ? 0
        // 默认的容量
        : DEFAULT_CAPACITY;

    if (minCapacity &gt; minExpand) {
        //当前元素个数比默认容量大
        ensureExplicitCapacity(minCapacity);
    }
}

private void ensureCapacityInternal(int minCapacity) {
    //还没有添加元素
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        //最小容量取默认容量和 当前元素个数 最大值
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}
//只有发生增加元素的事件才会产生扩容
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // 容量不够了，需要扩容
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}                    
</code></pre><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><pre><code>private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    // 1.5 倍 原来容量
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);

    //如果当前容量还没达到 1.5 倍旧容量，就使用当前容量，省的站那么多地方
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;

    //新的容量居然超出了 MAX_ARRAY_SIZE
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        //最大容量可以是 Integer.MAX_VALUE
        newCapacity = hugeCapacity(minCapacity);

    // minCapacity 一般跟元素个数 size 很接近，所以新建的数组容量为 newCapacity 更宽松些
    elementData = Arrays.copyOf(elementData, newCapacity);
}

private static int hugeCapacity(int minCapacity) {
    if (minCapacity &lt; 0) // overflow
        throw new OutOfMemoryError();
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}
</code></pre><h4 id="查询，修改等操作，直接根据角标对数组操作，都很快："><a href="#查询，修改等操作，直接根据角标对数组操作，都很快：" class="headerlink" title="查询，修改等操作，直接根据角标对数组操作，都很快："></a>查询，修改等操作，直接根据角标对数组操作，都很快：</h4><pre><code>E elementData(int index) {
    return (E) elementData[index];
}

//获取
public E get(int index) {
    rangeCheck(index);
    //直接根据数组角标返回元素，快的一比
    return elementData(index);
}

//修改
public E set(int index, E element) {
    rangeCheck(index);
    E oldValue = elementData(index);

    //直接对数组操作
    elementData[index] = element;
    //返回原来的值
    return oldValue;
}
</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre><code>//根据位置删除
public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    //挨个往前移一位
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    //原数组中最后一个元素删掉
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}

//删除某个元素
public boolean remove(Object o) {
    if (o == null) {
        //挨个遍历找到目标
        for (int index = 0; index &lt; size; index++)
            if (elementData[index] == null) {
                //快速删除
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index &lt; size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}

//内部方法，“快速删除”，就是把重复的代码移到一个方法里
//没看出来比其他 remove 哪儿快了 - -
private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work
}

//保留公共的
public boolean retainAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    return batchRemove(c, true);
}

//删除或者保留指定集合中的元素
private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
    final Object[] elementData = this.elementData;
    //使用两个变量，一个负责向后扫描，一个从 0 开始，等待覆盖操作
    int r = 0, w = 0;
    boolean modified = false;
    try {
        //遍历 ArrayList 集合
        for (; r &lt; size; r++)
            //如果指定集合中是否有这个元素，根据 complement 判断是否往前覆盖删除
            if (c.contains(elementData[r]) == complement)
                elementData[w++] = elementData[r];
    } finally {
        //发生了异常，直接把 r 后面的复制到 w 后面
        if (r != size) {
            System.arraycopy(elementData, r,
                             elementData, w,
                             size - r);
            w += size - r;
        }
        if (w != size) {
            // 清除多余的元素，clear to let GC do its work
            for (int i = w; i &lt; size; i++)
                elementData[i] = null;
            modCount += size - w;
            size = w;
            modified = true;
        }
    }
    return modified;
}

//清楚全部
public void clear() {
    modCount++;
    //并没有直接使数组指向 null,而是逐个把元素置为空
    //下次使用时就不用重新 new 了
    for (int i = 0; i &lt; size; i++)
        elementData[i] = null;

    size = 0;
}
</code></pre><h4 id="判断状态"><a href="#判断状态" class="headerlink" title="判断状态"></a>判断状态</h4><pre><code>public boolean contains(Object o) {
    return indexOf(o) &gt;= 0;
}

//遍历，第一次找到就返回
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i &lt; size; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = 0; i &lt; size; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}

//倒着遍历
public int lastIndexOf(Object o) {
    if (o == null) {
        for (int i = size-1; i &gt;= 0; i--)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = size-1; i &gt;= 0; i--)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}
</code></pre><h4 id="转换成数组"><a href="#转换成数组" class="headerlink" title="转换成数组"></a>转换成数组</h4><pre><code>public Object[] toArray() {
    return Arrays.copyOf(elementData, size);
}

public &lt;T&gt; T[] toArray(T[] a) {
    //如果只是要把一部分转换成数组
    if (a.length &lt; size)
        // Make a new array of a&apos;s runtime type, but my contents:
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    //全部元素拷贝到 数组 a
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length &gt; size)
        a[size] = null;
    return a;
}
</code></pre><h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><pre><code>private class ListItr extends Itr implements ListIterator&lt;E&gt; {
    ListItr(int index) {
        super();
        cursor = index;
    }

    public boolean hasPrevious() {
        return cursor != 0;
    }

    public int nextIndex() {
        return cursor;
    }

    public int previousIndex() {
        return cursor - 1;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public E previous() {
        checkForComodification();
        int i = cursor - 1;
        if (i &lt; 0)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i &gt;= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i;
        return (E) elementData[lastRet = i];
    }

    public void set(E e) {
        if (lastRet &lt; 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.set(lastRet, e);
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    public void add(E e) {
        checkForComodification();

        try {
            int i = cursor;
            ArrayList.this.add(i, e);
            cursor = i + 1;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }
}
</code></pre>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/02/源码系列/java框架类源码探索/" rel="next" title="java框架类源码探索">
                <i class="fa fa-chevron-left"></i> java框架类源码探索
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="lily" />
          <p class="site-author-name" itemprop="name">lily</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ArrayList详解"><span class="nav-number">1.</span> <span class="nav-text">ArrayList详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类图"><span class="nav-number">1.1.</span> <span class="nav-text">类图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#已经介绍过的类和接口"><span class="nav-number">1.2.</span> <span class="nav-text">已经介绍过的类和接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未介绍的类和接口"><span class="nav-number">1.3.</span> <span class="nav-text">未介绍的类和接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomAccess"><span class="nav-number">1.3.1.</span> <span class="nav-text">RandomAccess</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cloneable"><span class="nav-number">1.3.2.</span> <span class="nav-text">Cloneable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serializable"><span class="nav-number">1.3.3.</span> <span class="nav-text">Serializable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractCollection"><span class="nav-number">1.3.4.</span> <span class="nav-text">AbstractCollection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象方法"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">抽象方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现的方法"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">实现的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其它要点"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">其它要点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractList"><span class="nav-number">1.3.5.</span> <span class="nav-text">AbstractList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对-AbstractCollection抽象方法的实现"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">对 AbstractCollection抽象方法的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象方法或者子类必须自己实现的方法"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">抽象方法或者子类必须自己实现的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现的方法-1"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">实现的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两种内部迭代器"><span class="nav-number">1.3.5.4.</span> <span class="nav-text">两种内部迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两种内部类"><span class="nav-number">1.3.5.5.</span> <span class="nav-text">两种内部类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList实现"><span class="nav-number">1.4.</span> <span class="nav-text">ArrayList实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#成员变量"><span class="nav-number">1.4.1.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重要方法"><span class="nav-number">1.4.2.</span> <span class="nav-text">重要方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加元素"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">添加元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对数组的容量进行调整："><span class="nav-number">1.4.2.3.</span> <span class="nav-text">对数组的容量进行调整：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩容"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询，修改等操作，直接根据角标对数组操作，都很快："><span class="nav-number">1.4.2.5.</span> <span class="nav-text">查询，修改等操作，直接根据角标对数组操作，都很快：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断状态"><span class="nav-number">1.4.2.7.</span> <span class="nav-text">判断状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转换成数组"><span class="nav-number">1.4.2.8.</span> <span class="nav-text">转换成数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现"><span class="nav-number">1.4.2.9.</span> <span class="nav-text">内部实现</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lily</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid="></script>
      <!-- UY END -->
  




  
  

  

  

  

  


</body>
</html>
